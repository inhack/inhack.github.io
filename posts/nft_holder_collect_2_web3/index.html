<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>NFT 홀더 목록 수집하기 (2) - Web3 | inhack</title>
<meta name="keywords" content="Ethereum, NFT, ERC721, Rust, Web3">
<meta name="description" content="
Web3 방식(이더리움 기반의 특정 NFT 프로젝트의 스마트컨트랙트에 직접 접근)을 이용하여 홀더 목록을 수집하는 방법에 대해 설명">
<meta name="author" content="inhack">
<link rel="canonical" href="https://inhack.github.io/posts/nft_holder_collect_2_web3/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.8b523f1730c922e314350296d83fd666efa16519ca136320a93df674d00b6325.css" integrity="sha256-i1I/FzDJIuMUNQKW2D/WZu&#43;hZRnKE2MgqT32dNALYyU=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.acb54fd32bbc1982428b8850317e45d076b95012730a5936667e6bc21777692a.js" integrity="sha256-rLVP0yu8GYJCi4hQMX5F0Ha5UBJzClk2Zn5rwhd3aSo="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://inhack.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://inhack.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://inhack.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://inhack.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://inhack.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://inhack.github.io/posts/nft_holder_collect_2_web3/">
<link rel="alternate" hreflang="kr" href="https://inhack.github.io/kr/posts/nft_holder_collect_2_web3/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="NFT 홀더 목록 수집하기 (2) - Web3" />
<meta property="og:description" content="
Web3 방식(이더리움 기반의 특정 NFT 프로젝트의 스마트컨트랙트에 직접 접근)을 이용하여 홀더 목록을 수집하는 방법에 대해 설명" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://inhack.github.io/posts/nft_holder_collect_2_web3/" /><meta property="og:image" content="https://inhack.github.io/papermod-cover.png"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-14T00:00:00&#43;00:00" />
<meta property="article:modified_time" content="2022-07-14T00:00:00&#43;00:00" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://inhack.github.io/papermod-cover.png"/>

<meta name="twitter:title" content="NFT 홀더 목록 수집하기 (2) - Web3"/>
<meta name="twitter:description" content="
Web3 방식(이더리움 기반의 특정 NFT 프로젝트의 스마트컨트랙트에 직접 접근)을 이용하여 홀더 목록을 수집하는 방법에 대해 설명"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://inhack.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "NFT 홀더 목록 수집하기 (2) - Web3",
      "item": "https://inhack.github.io/posts/nft_holder_collect_2_web3/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "NFT 홀더 목록 수집하기 (2) - Web3",
  "name": "NFT 홀더 목록 수집하기 (2) - Web3",
  "description": " Web3 방식(이더리움 기반의 특정 NFT 프로젝트의 스마트컨트랙트에 직접 접근)을 이용하여 홀더 목록을 수집하는 방법에 대해 설명\n",
  "keywords": [
    "Ethereum", "NFT", "ERC721", "Rust", "Web3"
  ],
  "articleBody": " Web3 방식(이더리움 기반의 특정 NFT 프로젝트의 스마트컨트랙트에 직접 접근)을 이용하여 홀더 목록을 수집하는 방법에 대해 설명\n1. 개요 이전 글(NFT 홀더 목록 수집하기 (1) - Web Crawling)에서는 Web Crawling 방식을 이용해 이더리움 기반 NFT 프로젝트의 홀더 목록을 수집하는 방법에 대해 설명하였다.\n해당 방식은 이더스캔 검색 결과를 크롤링하였으며, 이더스캔에서 최대 1000개의 홀더(지갑 주소) 목록만 출력해주기 때문에 전체 홀더 목록을 수집할 수 없는 단점이 존재했다.\n본 글에서는 Web Crawling 방식의 단점을 극복하여 NFT 프로젝트의 모든 홀더 목록을 수집하기 위한 방법에 대해 설명한다.\n홀더 목록을 가장 정확하게 수집할 수 있는 방법은 이더리움에 배포되어있는 대상 NFT 프로젝트의 스마트컨트랙트에 접근하여 NFT 토큰 별 소유하고 있는 지갑주소를 직접 쿼리하는 것 이다.\nRust의 Web3 라이브러리를 이용해 이더리움 네트워크 및 스마트컨트랙트에 접근하여 홀더 목록을 수집하는 기능에 대해 설명한다.\n또한 2개 이상의 NFT 홀더 목록을 수집하여, 두 프로젝트의 Mutual Holder를 계산하는 기능에 대해서도 설명한다. (Mutual Holder의 의미와 활용에 대해서는 뒤에서 설명)\n2. ERC721 컨트랙트 ERC721은 NFT(Non-Fungible Token) Standard 즉 스마트컨트랙트에서 NFT에 대한 API 구현을 위한 표준이며, NFT를 추적하거나 전송하기 위한 등의 기본 기능을 제공한다.\nNFT(Non-Fungible Token, 대체불가능 토큰) 디지털 자산에 대한 소유권을 나타내기 위한 목적을 가진다. (ERC20과 구별!)\n이더리움에서 ERC20 표준을 따라서 개발된 토큰(ex. WETH, AAVE, APE 등)은 다른 토큰을 대체할 수 있으며, 소수점 단위로 쪼개서 거래가 가능하다.\n하지만 ERC721 표준을 따라서 개발된 NFT 토큰은 다른 것과 대체 불가능하며 기본적으로는 쪼개서 거래가 불가능하다. (요즘 NFT 파생시장에서는 쪼개서 거래하는 등의 상품도 있는 것으로 알고 있음)\n다른 토큰과 대체 가능하다는 것과 불가능하다는 것의 차이는 무엇일까?\nERC20 토큰 WETH(WrappedETH) : Alice가 가진 1 WETH 토큰과 Bob이 가진 1 WETH 토큰은 같은 가치를 가지며 대체될 수 있다.\nERC721 토큰 BAYC : Alice가 가진 BAYC#1 토큰과 Bob이 가진 BAYC#2 토큰은 가치가 다르며 대체가 불가능하다. (BAYC#1과 BAYC#2는 각각 아트웍이 다르다!)\n이처럼 ERC721 표준을 따라 개발된 NFT 토큰은 각 토큰별로 id 값(1,2,..)을 가지며, 각 토큰별로 다른 가치를 가진다.\npragma solidity ^0.4.20; /// @title ERC-721 Non-Fungible Token Standard /// @dev See https://eips.ethereum.org/EIPS/eip-721 /// Note: the ERC-165 identifier for this interface is 0x80ac58cd. interface ERC721 /* is ERC165 */ { event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId); event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId); event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved); function balanceOf(address _owner) external view returns (uint256); function ownerOf(uint256 _tokenId) external view returns (address); function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) external payable; function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable; function transferFrom(address _from, address _to, uint256 _tokenId) external payable; function approve(address _approved, uint256 _tokenId) external payable; function setApprovalForAll(address _operator, bool _approved) external; function getApproved(uint256 _tokenId) external view returns (address); function isApprovedForAll(address _owner, address _operator) external view returns (bool); } interface ERC165 { function supportsInterface(bytes4 interfaceID) external view returns (bool); } ERC721은 위와 같은 인터페이스로 구성되며, NFT 토큰을 추적/전송 등을 지원하기 위한 기능으로 구성되어 있다.\nbalanceOf(address _owner) : 특정 지갑 주소(_owner)가 가진 NFT 토큰 수량 반환\nownerOf(uint256 _tokenId) : 특정 토큰(_tokenId)을 가진 지갑 주소 반환\nsafeTransferFrom() / transferFrom(), approve(), setApprovalForAll(), getApproved(), isApprovedForAll() : NFT 토큰 전송을 위한 기능\nERC165는 컨트랙트가 어떤 인터페이스를 구현하고 있는지 알려주기 위한 용도로 사용되며, NFT 컨트랙트 초기화 시 supportInterface()에 ERC721의 인터페이스 ID를 입력하여 실행함으로써 ERC721 인터페이스를 구현하고 있음을 다른 컨트랙트에게 알려줄 수 있다.\n인터페이스 ID는 지원하고 있는 인터페이스 함수들의 selector들을 모두 계산한 후, XOR한 결과값을 사용한다.\nbytes4(keccak256('balanceOf(address)')) == 0x70a08231 bytes4(keccak256('ownerOf(uint256)')) == 0x6352211e bytes4(keccak256('approve(address,uint256)')) == 0x095ea7b3 bytes4(keccak256('getApproved(uint256)')) == 0x081812fc bytes4(keccak256('setApprovalForAll(address,bool)')) == 0xa22cb465 bytes4(keccak256('isApprovedForAll(address,address)')) == 0xe985e9c bytes4(keccak256('transferFrom(address,address,uint256)')) == 0x23b872dd bytes4(keccak256('safeTransferFrom(address,address,uint256)')) == 0x42842e0e bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)')) == 0xb88d4fde 0x70a08231 ^ 0x6352211e ^ 0x095ea7b3 ^ 0x081812fc ^ 0xa22cb465 ^ 0xe985e9c ^ 0x23b872dd ^ 0x42842e0e ^ 0xb88d4fde == 0x80ac58cd supportInterface(0x80ac58cd); 위처럼 ERC165로 인터페이스 ID를 등록한 경우, 다른 컨트랙트에서 ERC165Checker를 이용하여 해당 컨트랙트가 위 ERC721의 인터페이스가 구현된 컨트랙트임을 확인할 수 있다.\n/// @dev Note: the ERC-165 identifier for this interface is 0x150b7a02. interface ERC721TokenReceiver { function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes _data) external returns(bytes4); } onERC721Received()는 safe transfer를 위해 필요한 인터페이스로, safe transfer를 통해 NFT 토큰을 전송받을 컨트랙트(Receiver)에서는 해당 인터페이스를 꼭 구현해줘야 한다.\nfunction safeTransferFrom( address from, address to, uint256 tokenId, bytes memory data ) public virtual override { require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner nor approved\"); _safeTransfer(from, to, tokenId, data); } NFT 토큰을 전송하려는 개체(Sender)가 토큰 전송을 위해 safeTransferFrom() 호출 시, 내부적으로 _safeTransfer()가 호출되고 해당 함수는 토큰을 전송하기 전에 Receiver 컨트랙트에 onERC721Received() 인터페이스가 구현되었는지 require문을 통해 체크한다.\n/// @title ERC-721 Non-Fungible Token Standard, optional metadata extension /// @dev See https://eips.ethereum.org/EIPS/eip-721 /// Note: the ERC-165 identifier for this interface is 0x5b5e139f. interface ERC721Metadata /* is ERC721 */ { function name() external view returns (string _name); function symbol() external view returns (string _symbol); function tokenURI(uint256 _tokenId) external view returns (string); } name()은 ERC721 NFT 토큰 이름(ex. Bored Ape Yacht Club)을 의미하고, symbol()은 ERC721 NFT 토큰의 심볼(ex. BAYC)을 의미한다.\ntokenURI()는 토큰 ID를 인자로 입력받아 해당 NFT 토큰의 JSON 객체 정보가 담긴 URI를 반환해준다.\nBAYC#1의 tokenURI()는 이더스캔에서 확인 할 수 있으며, “ipfs://QmeSjSinHpPnmXmspMjwiXyN6zS4E9zccariGR3jxcaWtq/1” 값을 가진다.\n해당 IPFS 값을 조회해보면 아래와 같이 JSON 객체 정보를 확인할 수 있으며, OpenSea에서 확인한 BAYC#1과 동일한 특성 정보를 가진 것을 확인할 수 있다.\n3. Web3 기반 수집 코드 개발 이더리움 로컬 풀노드(Full Node) 구동 이더리움은 탈중앙화된 시스템이며, 이더리움의 노드는 블록체인 네트워크에서 발생한 모든 거래를 검증하고 채굴자가 채굴한 블록이 합당한지 검증(PoW 기준)하는 역할을 수행한다.\n블록체인 데이터베이스를 저장 및 관리하고 있는 중앙화된 시스템이 없고, 수많은 분산화된 노드를 이용해 데이터베이스를 유지/관리한다.\n풀 노드는 이더리움 네트워크의 제네시스 블록(Genesis Block, 블록체인 네트워크의 첫번째 블록)부터 현재까지의 모든 블록을 저장하고 있는 노드로 모든 블록(거래내역)이 저장되어 있기 때문에 스스로 거래를 검증할 수 있다.\n이더리움 블록체인 및 네트워크에 접근하기 위해서는 노드가 필요 하다.\nInfura나 Alchemy와 같은 이더리움 게이트웨이 역할을 수행하는 서비스를 통해 이더리움 네트워크에 접근해도 되지만, 속도가 매우 느리고 무료로 이용할 경우 쿼리 수에 제한이 있다.\n나의 경우 로컬 PC에 geth를 이용하여 풀노드를 구축해 사용 중이며, 로컬 풀노드를 통해 빠른 속도로 이더리움 네트워크에 접근하여 블록 및 데이터를 조회할 수 있다.\n(실제로 로컬노드와 Infura와 같은 상용노드에 같은 쿼리를 날려보면, 꽤 성능 차이가 발생하고 로컬노드를 사용하는 것이 매우 효율적이고 빠른 것을 확인할 수 있다) 이더리움 노드 및 컨트랙트 설정 let http_transport = web3::transports::Http::new(\"http://localhost:8545\")?; let bayc_addr = \"0xbc4ca0eda7647a8ab7c2061c2e118a18a936f13d\"; let addr = Address::from_str(bayc_addr).parse().unwrap(); let contract = Contract::from_json(web3s.lock().unwrap().eth(), addr, include_bytes!(\"../../../metadata/artifacts/token/ERC721/ERC721.json\")).unwrap(); Web3(JSON-RPC 기반) 쿼리를 전송하기 위해 로컬 이더리움 풀노드에 연결한다.\n컨트랙트 주소와 JSON ABI 파일을 이용해 홀더 목록을 수집하고자 하는 컨트랙트에 연결한다.\nNFT 컨트랙트의 발행 수량 획득 // Get Total Supply of NFT let mut total_supply: u64; let r: Result\u003cU256, web3::contract::Error\u003e = contract.query(\"totalSupply\", (), None, Options::default(), None).await; match r { Ok(ts) =\u003e total_supply = ts.as_u64(), _ =\u003e total_supply = 10000, } 대부분의 ERC721 스마트컨트랙트가 토큰의 총 발행수량을 totalSupply 라는 상태변수에 유지하기 때문에, 해당 값을 스마트컨트랙트의 스토리지부터 읽어온다. ex\u003e totalSupply 값이 5555인 경우, 토큰은 #1~#5555까지 총 5555개 발행된 것으로 간주 각 토큰을 소유한 지갑주소(홀더) 획득 let mut hm_holder: HashMap\u003cAddress, u64\u003e = HashMap::new(); let mtx = Arc::new(Mutex::new(hm_holder)); // task split let num_of_threads = 10; let range = total_supply / num_of_threads; let mut range_list = (0..total_supply).step_by(range as usize).collect::\u003cVec\u003cu64\u003e\u003e(); range_list.pop(); range_list.push(total_supply+1); let range_list = range_list.windows(2).map(|w| (w[0], w[1])).collect::\u003cVec\u003c(u64,u64)\u003e\u003e(); // collect wallet address to hashmap (async thread) let mut handles = vec![]; for i in range_list { let mtx_c = Arc::clone(\u0026mtx); let web3s_c = Arc::clone(\u0026web3s); let handle = tokio::spawn(async move { holder_crawl_thread(addr, i.0, i.1, mtx_c, web3s_c).await }); handles.push(handle); } for handle in handles { tokio::join!(handle); } 순차적으로 #1~#10000 토큰을 소유한 지갑주소를 쿼리하는 것은 시간이 오래걸리므로, 비동기 멀티쓰레딩을 이용한다. (1~1000, 1001~2000, …, 9001~10000) rust에서 비동기 쓰레드 사용 시 동일 개체 접근 및 값 변경을 위해 Arc와 Mutex를 사용 async fn holder_crawl_thread(contract_addr: Address, start_tokenid: u64, end_tokenid: u64, mtx_c: Arc\u003cMutex\u003cHashMap\u003cAddress, u64\u003e\u003e\u003e, web3s_c: Arc\u003cMutex\u003cweb3::Web3\u003cweb3::transports::Http\u003e\u003e\u003e) { for tid in start_tokenid..end_tokenid { let contract = Contract::from_json(web3s_c.lock().unwrap().eth(), contract_addr, include_bytes!(\"../../../metadata/artifacts/token/ERC721/ERC721.json\")).unwrap(); let id: U256 = U256::from(tid); let r: Result\u003cAddress, web3::contract::Error\u003e = contract.query(\"ownerOf\", (id,), None, Options::default(), None).await; match r { Ok(addr) =\u003e { let mut hm = mtx_c.lock().unwrap(); let cnt = hm.entry(addr).or_insert(0); *cnt += 1; }, Err(_) =\u003e {}, } } } 각 쓰레드는 자신이 쿼리할 토큰 ID의 시작과 끝을 전달받으며, 해당 범위 내에서 순차적으로 컨트랙트에 접근하여 토큰을 소유한 지갑 주소를 획득한다.\nERC721 컨트랙트의 onwerOf(uint256) 함수가 토큰을 소유한 지갑 주소를 반환해준다.\n획득한 지갑 주소는 Key-\u003eValue 를 매핑한 hashmap 구조체에 입력하며, 본 코드에서는 Key(Address)-\u003eValue(Token Quantity)로 구성된다.\nhashmap 구조체에 이미 지갑 주소(Key)가 존재하는 경우 수량을 +1 실행 결과 // totalSupply println!(\"Total Supply : {:?}\", total_supply); // Number of Holders let hm = mtx.lock().unwrap(); println!(\"# of Holders : {}\", hm.len()); // Top 20 let mut v: Vec\u003c_\u003e = hm.clone().into_iter().collect(); v.sort_by(|x,y| y.1.cmp(\u0026x.1)); for i in 0..20 { let t = v.get(i).unwrap(); println!(\"{:?} : {:?}\", t.0, t.1); } 실행 결과를 확인하기 위해 정보를 출력한다.\n(1) totalSupply (총 토큰 발행수량) (2) # of Holders (토큰을 가진 홀더 수) (3) 전체 홀더 중 보유 수량 상위 10개의 지갑 주소 및 보유 수량 BAYC를 대상으로 홀더 수집 시, 다음과 같은 결과를 확인할 수 있다. (Ethereum Block Number 15152072 기준)\nTotal Supply : 10000 # of Holders : 6453 0xdbfd76af2157dc15ee4e57f3f942bb45ba84af24 : 260 0x1b523dc90a79cf5ee5d095825e586e33780f7188 : 107 0x54be3a794282c030b15e43ae2bb182e14c409c5e : 105 0xd38a87d7b690323ef6883e887614502abcf9b1eb : 71 0x98e711f31e49c2e50c1a290b6f2b1e493e43ea76 : 71 0xf896527c49b44aab3cf22ae356fa3af8e331f280 : 66 0x8ad272ac86c6c88683d9a60eb8ed57e6c304bb0c : 57 0x020ca66c30bec2c4fe3861a94e4db4a498a35872 : 52 0xed2ab4948ba6a909a7751dec4f34f303eb8c7236 : 49 0x04f5df957ce0405ba0264eca6130161cfaa12571 : 34 0x720a4fab08cb746fc90e88d1924a98104c0822cf : 33 0x7a9fe22691c811ea339d9b73150e6911a5343dca : 31 0xca1257ade6f4fa6c6834fdc42e030be6c0f5a813 : 30 0xd66f8eaf84b11654a19126a98a3f55b960846dd8 : 28 0x1cfb8a2e4c2e849593882213b2468e369271dad2 : 27 이더스캔에서 확인한 값과 동일한 것을 확인할 수 있다. (.eth와 같은 ENS 주소도 resolve해보면 같은 값임) 4. 두 NFT 토큰 간의 Mutual Holder 확인 구현한 기능을 기반으로, 서로 다른 NFT 프로젝트의 Mutual Holder를 확인할 수 있다.\nMutual Holder는 A NFT 프로젝트의 토큰도 가지고 있고, B NFT 프로젝트의 토큰도 가지고 있는 홀더를 의미한다.\n쉽게 다시 설명하면 Mutual Holder 확인 기능은 BAYC NFT 토큰 홀더 중, Doodles NFT 토큰을 가지고 있는 지갑 주소와 보유 수량을 확인하는 것이다.\n이러한 기능은 고래 지갑 추적과 유사하게 NFT 블루칩 프로젝트의 토큰을 가진 지갑들이, 다른 특정 신규 NFT 프로젝트의 토큰을 얼마나 가지고 있는지 확인할 수 있다.\n(블루칩 프로젝트 홀더들의 알파가 무엇인지 빠르게 체크하여 2차 거래에 참고하는 목적 등 활용 가능)\n코드 use web3::contract::{Contract, Options}; use web3::types::{Address, U256}; // use web3::contract::Error; use std::str::FromStr; use std::collections::HashMap; use std::sync::{Mutex, Arc}; use std::collections::HashSet; #[tokio::main] async fn main() -\u003e web3::Result\u003c()\u003e { // BAYC Holder Crawl println!(\"[+] BAYC\"); let bayc_holder_tuple = holder_crawl(\"0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D\"); // BAYC let bayc_holder_tuple = bayc_holder_tuple.await.unwrap(); let bayc_holder = bayc_holder_tuple.0; let _num_of_nfts_bayc = bayc_holder_tuple.1; // Doodles Holder Crawl println!(\"[+] Doodles\"); let doodles_holder_tuple = holder_crawl(\"0x8a90CAb2b38dba80c64b7734e58Ee1dB38B8992e\"); // Doodles let doodles_holder_tuple = doodles_holder_tuple.await.unwrap(); let doodles_holder = doodles_holder_tuple.0; let num_of_nfts_doodles = doodles_holder_tuple.1; // Mutual Holder Calculation let unique_bayc = bayc_holder.keys().collect::\u003cHashSet\u003c_\u003e\u003e(); let unique_doodles = doodles_holder.keys().collect::\u003cHashSet\u003c_\u003e\u003e(); let intersect = unique_bayc.intersection(\u0026unique_doodles).collect::\u003cVec\u003c_\u003e\u003e(); let num_of_h = intersect.len(); let mut num_of_nft = 0; for s in intersect { num_of_nft += doodles_holder.get(\u0026s).unwrap(); } // Check println!(\"[+] {} BAYC Holders({:.3}%) have {} NFTs({:.3}%) of Doodles\", num_of_h, (num_of_h as f64 / doodles_holder.len() as f64 * 100 as f64), num_of_nft, (num_of_nft as f64 / num_of_nfts_doodles as f64) * 100 as f64); Ok(()) } async fn holder_crawl(contract_address: \u0026str) -\u003e web3::Result\u003c(HashMap\u003cAddress,u64\u003e, u64)\u003e { // Ethereum Node Set let http_transport = web3::transports::Http::new(\"http://localhost:8540\")?; let w3s = web3::Web3::new(http_transport); let web3s = Arc::new(Mutex::new(w3s)); // Contract Load let addr = Address::from_str(contract_address).unwrap(); let contract = Contract::from_json(web3s.lock().unwrap().eth(), addr, include_bytes!(\"../../metadata/artifacts/token/ERC721/ERC721.json\")).unwrap(); // Get Total Supply of NFT let total_supply: u64; let r: Result\u003cU256, web3::contract::Error\u003e = contract.query(\"totalSupply\", (), None, Options::default(), None).await; match r { Ok(ts) =\u003e total_supply = ts.as_u64(), _ =\u003e total_supply = 10000, } print!(\"Total Supply : {:?} / \", total_supply); // Get Owner List \u0026 balance let hm_holder: HashMap\u003cAddress, u64\u003e = HashMap::new(); let mtx = Arc::new(Mutex::new(hm_holder)); // task split let num_of_threads = 10; let range = total_supply / num_of_threads; let mut range_list = (0..total_supply).step_by(range as usize).collect::\u003cVec\u003cu64\u003e\u003e(); range_list.pop(); range_list.push(total_supply+1); let range_list = range_list.windows(2).map(|w| (w[0], w[1])).collect::\u003cVec\u003c(u64,u64)\u003e\u003e(); // async thread let mut handles = vec![]; for i in range_list { let mtx_c = Arc::clone(\u0026mtx); let web3s_c = Arc::clone(\u0026web3s); let handle = tokio::spawn(async move { holder_crawl_thread(addr, i.0, i.1, mtx_c, web3s_c).await }); handles.push(handle); } for handle in handles { tokio::join!(handle); } let hm = mtx.lock().unwrap(); println!(\"Holders : {}\", hm.len()); Ok((hm.clone(), total_supply)) } async fn holder_crawl_thread(contract_addr: Address, start_tokenid: u64, end_tokenid: u64, mtx_c: Arc\u003cMutex\u003cHashMap\u003cAddress, u64\u003e\u003e\u003e, web3s_c: Arc\u003cMutex\u003cweb3::Web3\u003cweb3::transports::Http\u003e\u003e\u003e) { for tid in start_tokenid..end_tokenid { let contract = Contract::from_json(web3s_c.lock().unwrap().eth(), contract_addr, include_bytes!(\"../../metadata/artifacts/token/ERC721/ERC721.json\")).unwrap(); let id: U256 = U256::from(tid); let r: Result\u003cAddress, web3::contract::Error\u003e = contract.query(\"ownerOf\", (id,), None, Options::default(), None).await; match r { Ok(addr) =\u003e { let mut hm = mtx_c.lock().unwrap(); let cnt = hm.entry(addr).or_insert(0); *cnt += 1; }, Err(_) =\u003e {}, } } } 결과 \u003e cargo run --release ... ... Finished release [optimized] target(s) in 37.71s Running `target\\release\\Erc721HolderCrawl_Web3.exe` [+] BAYC Total Supply : 10000 / Holders : 6453 [+] Doodles Total Supply : 10000 / Holders : 5207 [+] 543 BAYC Holders(10.428%) have 1228 NFTs(12.280%) of Doodles (Ethereum Block Number 15152171 기준)\nBAYC 토큰을 가진 6453개의 지갑 중 543개의 지갑이 Mutual Holder로써 Doodles 토큰을 가지고 있다.\n해당 Mutual Holder 543개의 지갑은 5207개의 Doodle 홀더 중에 10.428% 비중이며, Doodles 토큰 10000개중에 1228개(12.280%)를 가지고 있다.\n",
  "wordCount" : "2035",
  "inLanguage": "en",
  "datePublished": "2022-07-14T00:00:00Z",
  "dateModified": "2022-07-14T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "inhack"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://inhack.github.io/posts/nft_holder_collect_2_web3/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "inhack",
    "logo": {
      "@type": "ImageObject",
      "url": "https://inhack.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://inhack.github.io/" accesskey="h" title="inhack (Alt + H)">inhack</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                    <li>
                        <a href="https://inhack.github.io/kr/" title="Korean"
                            aria-label=":kr:">🇰🇷</a>
                    </li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://inhack.github.io/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://inhack.github.io/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="https://inhack.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://inhack.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://inhack.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://inhack.github.io/posts/">Posts</a></div>
    <h1 class="post-title">
      NFT 홀더 목록 수집하기 (2) - Web3
    </h1>
    <div class="post-meta"><span title='2022-07-14 00:00:00 +0000 UTC'>July 14, 2022</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;inhack&nbsp;|&nbsp;Translations:
<ul class="i18n_list">
    <li>
        <a href="https://inhack.github.io/kr/posts/nft_holder_collect_2_web3/">🇰🇷</a>
    </li>
</ul>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#1-%ea%b0%9c%ec%9a%94" aria-label="1. 개요">1. 개요</a></li>
                <li>
                    <a href="#2-erc721-%ec%bb%a8%ed%8a%b8%eb%9e%99%ed%8a%b8" aria-label="2. ERC721 컨트랙트">2. ERC721 컨트랙트</a></li>
                <li>
                    <a href="#3-web3-%ea%b8%b0%eb%b0%98-%ec%88%98%ec%a7%91-%ec%bd%94%eb%93%9c-%ea%b0%9c%eb%b0%9c" aria-label="3. Web3 기반 수집 코드 개발">3. Web3 기반 수집 코드 개발</a><ul>
                        
                <li>
                    <a href="#%ec%9d%b4%eb%8d%94%eb%a6%ac%ec%9b%80-%eb%a1%9c%ec%bb%ac-%ed%92%80%eb%85%b8%eb%93%9cfull-node-%ea%b5%ac%eb%8f%99" aria-label="이더리움 로컬 풀노드(Full Node) 구동">이더리움 로컬 풀노드(Full Node) 구동</a></li>
                <li>
                    <a href="#%ec%9d%b4%eb%8d%94%eb%a6%ac%ec%9b%80-%eb%85%b8%eb%93%9c-%eb%b0%8f-%ec%bb%a8%ed%8a%b8%eb%9e%99%ed%8a%b8-%ec%84%a4%ec%a0%95" aria-label="이더리움 노드 및 컨트랙트 설정">이더리움 노드 및 컨트랙트 설정</a></li>
                <li>
                    <a href="#nft-%ec%bb%a8%ed%8a%b8%eb%9e%99%ed%8a%b8%ec%9d%98-%eb%b0%9c%ed%96%89-%ec%88%98%eb%9f%89-%ed%9a%8d%eb%93%9d" aria-label="NFT 컨트랙트의 발행 수량 획득">NFT 컨트랙트의 발행 수량 획득</a></li>
                <li>
                    <a href="#%ea%b0%81-%ed%86%a0%ed%81%b0%ec%9d%84-%ec%86%8c%ec%9c%a0%ed%95%9c-%ec%a7%80%ea%b0%91%ec%a3%bc%ec%86%8c%ed%99%80%eb%8d%94-%ed%9a%8d%eb%93%9d" aria-label="각 토큰을 소유한 지갑주소(홀더) 획득">각 토큰을 소유한 지갑주소(홀더) 획득</a></li>
                <li>
                    <a href="#%ec%8b%a4%ed%96%89-%ea%b2%b0%ea%b3%bc" aria-label="실행 결과">실행 결과</a></li></ul>
                </li>
                <li>
                    <a href="#4-%eb%91%90-nft-%ed%86%a0%ed%81%b0-%ea%b0%84%ec%9d%98-mutual-holder-%ed%99%95%ec%9d%b8" aria-label="4. 두 NFT 토큰 간의 Mutual Holder 확인">4. 두 NFT 토큰 간의 Mutual Holder 확인</a><ul>
                        
                <li>
                    <a href="#%ec%bd%94%eb%93%9c" aria-label="코드">코드</a></li>
                <li>
                    <a href="#%ea%b2%b0%ea%b3%bc" aria-label="결과">결과</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><hr>
<p>Web3 방식(이더리움 기반의 특정 NFT 프로젝트의 스마트컨트랙트에 직접 접근)을 이용하여 홀더 목록을 수집하는 방법에 대해 설명</p>
<hr>
<h2 id="1-개요">1. 개요<a hidden class="anchor" aria-hidden="true" href="#1-개요">#</a></h2>
<p><a href="https://inhack.github.io/posts/nft_holder_collect_1_web_crawling/">이전 글(NFT 홀더 목록 수집하기 (1) - Web Crawling)</a>에서는 Web Crawling 방식을 이용해 이더리움 기반 NFT 프로젝트의 홀더 목록을 수집하는 방법에 대해 설명하였다.</p>
<p>해당 방식은 이더스캔 검색 결과를 크롤링하였으며, 이더스캔에서 최대 1000개의 홀더(지갑 주소) 목록만 출력해주기 때문에 전체 홀더 목록을 수집할 수 없는 단점이 존재했다.</p>
<p>본 글에서는 Web Crawling 방식의 단점을 극복하여 NFT 프로젝트의 모든 홀더 목록을 수집하기 위한 방법에 대해 설명한다.</p>
<p>홀더 목록을 가장 정확하게 수집할 수 있는 방법은 <strong>이더리움에 배포되어있는 대상 NFT 프로젝트의 스마트컨트랙트에 접근하여 NFT 토큰 별 소유하고 있는 지갑주소를 직접 쿼리하는 것</strong> 이다.</p>
<p>Rust의 Web3 라이브러리를 이용해 이더리움 네트워크 및 스마트컨트랙트에 접근하여 홀더 목록을 수집하는 기능에 대해 설명한다.</p>
<p>또한 2개 이상의 NFT 홀더 목록을 수집하여, 두 프로젝트의 Mutual Holder를 계산하는 기능에 대해서도 설명한다. (Mutual Holder의 의미와 활용에 대해서는 뒤에서 설명)</p>
<hr>
<h2 id="2-erc721-컨트랙트">2. ERC721 컨트랙트<a hidden class="anchor" aria-hidden="true" href="#2-erc721-컨트랙트">#</a></h2>
<p><a href="https://eips.ethereum.org/EIPS/eip-721">ERC721</a>은 NFT(Non-Fungible Token) Standard 즉 스마트컨트랙트에서 NFT에 대한 API 구현을 위한 표준이며, NFT를 추적하거나 전송하기 위한 등의 기본 기능을 제공한다.</p>
<p>NFT(Non-Fungible Token, 대체불가능 토큰) 디지털 자산에 대한 소유권을 나타내기 위한 목적을 가진다. (ERC20과 구별!)</p>
<p>이더리움에서 ERC20 표준을 따라서 개발된 토큰(ex. WETH, AAVE, APE 등)은 다른 토큰을 대체할 수 있으며, 소수점 단위로 쪼개서 거래가 가능하다.</p>
<p>하지만 ERC721 표준을 따라서 개발된 NFT 토큰은 다른 것과 대체 불가능하며 기본적으로는 쪼개서 거래가 불가능하다. (요즘 NFT 파생시장에서는 쪼개서 거래하는 등의 상품도 있는 것으로 알고 있음)</p>
<p>다른 토큰과 대체 가능하다는 것과 불가능하다는 것의 차이는 무엇일까?</p>
<ul>
<li>
<p>ERC20 토큰 WETH(WrappedETH) : Alice가 가진 1 WETH 토큰과 Bob이 가진 1 WETH 토큰은 같은 가치를 가지며 대체될 수 있다.</p>
</li>
<li>
<p>ERC721 토큰 BAYC :  Alice가 가진 BAYC#1 토큰과 Bob이 가진 BAYC#2 토큰은 가치가 다르며 대체가 불가능하다. (BAYC#1과 BAYC#2는 각각 아트웍이 다르다!)</p>
</li>
</ul>
<p>이처럼 ERC721 표준을 따라 개발된 NFT 토큰은 각 토큰별로 id 값(1,2,..)을 가지며, 각 토큰별로 다른 가치를 가진다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-solidity" data-lang="solidity"><span style="display:flex;"><span><span style="color:#66d9ef">pragma solidity</span> <span style="color:#f92672">^</span><span style="color:#ae81ff">0</span>.<span style="color:#ae81ff">4</span>.<span style="color:#ae81ff">20</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/// @title ERC-721 Non-Fungible Token Standard
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">/// @dev See https://eips.ethereum.org/EIPS/eip-721
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">///  Note: the ERC-165 identifier for this interface is 0x80ac58cd.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">ERC721</span> <span style="color:#75715e">/* is ERC165 */</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">event</span> <span style="color:#a6e22e">Transfer</span>(<span style="color:#66d9ef">address</span> <span style="color:#66d9ef">indexed</span> _from, <span style="color:#66d9ef">address</span> <span style="color:#66d9ef">indexed</span> _to, <span style="color:#66d9ef">uint256</span> <span style="color:#66d9ef">indexed</span> _tokenId);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">event</span> <span style="color:#a6e22e">Approval</span>(<span style="color:#66d9ef">address</span> <span style="color:#66d9ef">indexed</span> _owner, <span style="color:#66d9ef">address</span> <span style="color:#66d9ef">indexed</span> _approved, <span style="color:#66d9ef">uint256</span> <span style="color:#66d9ef">indexed</span> _tokenId);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">event</span> <span style="color:#a6e22e">ApprovalForAll</span>(<span style="color:#66d9ef">address</span> <span style="color:#66d9ef">indexed</span> _owner, <span style="color:#66d9ef">address</span> <span style="color:#66d9ef">indexed</span> _operator, <span style="color:#66d9ef">bool</span> _approved);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">balanceOf</span>(<span style="color:#66d9ef">address</span> _owner) <span style="color:#66d9ef">external</span> <span style="color:#66d9ef">view</span> <span style="color:#66d9ef">returns</span> (<span style="color:#66d9ef">uint256</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">ownerOf</span>(<span style="color:#66d9ef">uint256</span> _tokenId) <span style="color:#66d9ef">external</span> <span style="color:#66d9ef">view</span> <span style="color:#66d9ef">returns</span> (<span style="color:#66d9ef">address</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">safeTransferFrom</span>(<span style="color:#66d9ef">address</span> _from, <span style="color:#66d9ef">address</span> _to, <span style="color:#66d9ef">uint256</span> _tokenId, <span style="color:#66d9ef">bytes</span> data) <span style="color:#66d9ef">external</span> <span style="color:#66d9ef">payable</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">safeTransferFrom</span>(<span style="color:#66d9ef">address</span> _from, <span style="color:#66d9ef">address</span> _to, <span style="color:#66d9ef">uint256</span> _tokenId) <span style="color:#66d9ef">external</span> <span style="color:#66d9ef">payable</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">transferFrom</span>(<span style="color:#66d9ef">address</span> _from, <span style="color:#66d9ef">address</span> _to, <span style="color:#66d9ef">uint256</span> _tokenId) <span style="color:#66d9ef">external</span> <span style="color:#66d9ef">payable</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">approve</span>(<span style="color:#66d9ef">address</span> _approved, <span style="color:#66d9ef">uint256</span> _tokenId) <span style="color:#66d9ef">external</span> <span style="color:#66d9ef">payable</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">setApprovalForAll</span>(<span style="color:#66d9ef">address</span> _operator, <span style="color:#66d9ef">bool</span> _approved) <span style="color:#66d9ef">external</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">getApproved</span>(<span style="color:#66d9ef">uint256</span> _tokenId) <span style="color:#66d9ef">external</span> <span style="color:#66d9ef">view</span> <span style="color:#66d9ef">returns</span> (<span style="color:#66d9ef">address</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">isApprovedForAll</span>(<span style="color:#66d9ef">address</span> _owner, <span style="color:#66d9ef">address</span> _operator) <span style="color:#66d9ef">external</span> <span style="color:#66d9ef">view</span> <span style="color:#66d9ef">returns</span> (<span style="color:#66d9ef">bool</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">ERC165</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">supportsInterface</span>(<span style="color:#66d9ef">bytes4</span> interfaceID) <span style="color:#66d9ef">external</span> <span style="color:#66d9ef">view</span> <span style="color:#66d9ef">returns</span> (<span style="color:#66d9ef">bool</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>ERC721은 위와 같은 인터페이스로 구성되며, NFT 토큰을 추적/전송 등을 지원하기 위한 기능으로 구성되어 있다.</p>
<ul>
<li>
<p><code>balanceOf(address _owner)</code> : 특정 지갑 주소(_owner)가 가진 NFT 토큰 수량 반환</p>
</li>
<li>
<p><code>ownerOf(uint256 _tokenId)</code> : 특정 토큰(_tokenId)을 가진 지갑 주소 반환</p>
</li>
<li>
<p><code>safeTransferFrom() / transferFrom(), approve(), setApprovalForAll(), getApproved(), isApprovedForAll()</code> : NFT 토큰 전송을 위한 기능</p>
</li>
</ul>
<p>ERC165는 컨트랙트가 어떤 인터페이스를 구현하고 있는지 알려주기 위한 용도로 사용되며, NFT 컨트랙트 초기화 시 <code>supportInterface()</code>에 ERC721의 인터페이스 ID를 입력하여 실행함으로써 ERC721 인터페이스를 구현하고 있음을 다른 컨트랙트에게 알려줄 수 있다.</p>
<p>인터페이스 ID는 지원하고 있는 인터페이스 함수들의 selector들을 모두 계산한 후, XOR한 결과값을 사용한다.</p>
<pre tabindex="0"><code>bytes4(keccak256(&#39;balanceOf(address)&#39;)) == 0x70a08231
bytes4(keccak256(&#39;ownerOf(uint256)&#39;)) == 0x6352211e
bytes4(keccak256(&#39;approve(address,uint256)&#39;)) == 0x095ea7b3
bytes4(keccak256(&#39;getApproved(uint256)&#39;)) == 0x081812fc
bytes4(keccak256(&#39;setApprovalForAll(address,bool)&#39;)) == 0xa22cb465
bytes4(keccak256(&#39;isApprovedForAll(address,address)&#39;)) == 0xe985e9c
bytes4(keccak256(&#39;transferFrom(address,address,uint256)&#39;)) == 0x23b872dd
bytes4(keccak256(&#39;safeTransferFrom(address,address,uint256)&#39;)) == 0x42842e0e
bytes4(keccak256(&#39;safeTransferFrom(address,address,uint256,bytes)&#39;)) == 0xb88d4fde

0x70a08231 ^ 0x6352211e ^ 0x095ea7b3 ^ 0x081812fc ^ 0xa22cb465 ^ 0xe985e9c ^ 0x23b872dd ^ 0x42842e0e ^ 0xb88d4fde
== 0x80ac58cd

supportInterface(0x80ac58cd);
</code></pre><p>위처럼 ERC165로 인터페이스 ID를 등록한 경우, 다른 컨트랙트에서 ERC165Checker를 이용하여 해당 컨트랙트가 위 ERC721의 인터페이스가 구현된 컨트랙트임을 확인할 수 있다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-solidity" data-lang="solidity"><span style="display:flex;"><span><span style="color:#75715e">/// @dev Note: the ERC-165 identifier for this interface is 0x150b7a02.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">ERC721TokenReceiver</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">onERC721Received</span>(<span style="color:#66d9ef">address</span> _operator, <span style="color:#66d9ef">address</span> _from, <span style="color:#66d9ef">uint256</span> _tokenId, <span style="color:#66d9ef">bytes</span> _data) <span style="color:#66d9ef">external</span> <span style="color:#66d9ef">returns</span>(<span style="color:#66d9ef">bytes4</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>onERC721Received()</code>는 safe transfer를 위해 필요한 인터페이스로, safe transfer를 통해 NFT 토큰을 전송받을 컨트랙트(Receiver)에서는 해당 인터페이스를 꼭 구현해줘야 한다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-solidity" data-lang="solidity"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">safeTransferFrom</span>(
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">address</span> <span style="color:#66d9ef">from</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">address</span> to,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint256</span> tokenId,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bytes</span> <span style="color:#66d9ef">memory</span> data
</span></span><span style="display:flex;"><span>) <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">override</span> {
</span></span><span style="display:flex;"><span>    require(_isApprovedOrOwner(_msgSender(), tokenId), <span style="color:#e6db74">&#34;ERC721: caller is not token owner nor approved&#34;</span>);
</span></span><span style="display:flex;"><span>    _safeTransfer(<span style="color:#66d9ef">from</span>, to, tokenId, data);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>NFT 토큰을 전송하려는 개체(Sender)가 토큰 전송을 위해 <code>safeTransferFrom()</code> 호출 시, 내부적으로 <code>_safeTransfer()</code>가 호출되고 해당 함수는 토큰을 전송하기 전에 Receiver 컨트랙트에 <code>onERC721Received()</code> 인터페이스가 구현되었는지 require문을 통해 체크한다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-solidity" data-lang="solidity"><span style="display:flex;"><span><span style="color:#75715e">/// @title ERC-721 Non-Fungible Token Standard, optional metadata extension
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">/// @dev See https://eips.ethereum.org/EIPS/eip-721
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">///  Note: the ERC-165 identifier for this interface is 0x5b5e139f.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">ERC721Metadata</span> <span style="color:#75715e">/* is ERC721 */</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">name</span>() <span style="color:#66d9ef">external</span> <span style="color:#66d9ef">view</span> <span style="color:#66d9ef">returns</span> (<span style="color:#66d9ef">string</span> _name);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">symbol</span>() <span style="color:#66d9ef">external</span> <span style="color:#66d9ef">view</span> <span style="color:#66d9ef">returns</span> (<span style="color:#66d9ef">string</span> _symbol);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">tokenURI</span>(<span style="color:#66d9ef">uint256</span> _tokenId) <span style="color:#66d9ef">external</span> <span style="color:#66d9ef">view</span> <span style="color:#66d9ef">returns</span> (<span style="color:#66d9ef">string</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>name()</code>은 ERC721 NFT 토큰 이름(ex. Bored Ape Yacht Club)을 의미하고, <code>symbol()</code>은 ERC721 NFT 토큰의 심볼(ex. BAYC)을 의미한다.</p>
<p><code>tokenURI()</code>는 토큰 ID를 인자로 입력받아 해당 NFT 토큰의 JSON 객체 정보가 담긴 URI를 반환해준다.</p>
<p>BAYC#1의 <code>tokenURI()</code>는 이더스캔에서 확인 할 수 있으며, &ldquo;ipfs://QmeSjSinHpPnmXmspMjwiXyN6zS4E9zccariGR3jxcaWtq/1&rdquo; 값을 가진다.</p>
<p><img loading="lazy" src="/posts/image-nft-holder-collect-2-web3/image1.png" alt="image1"  />
</p>
<p>해당 IPFS 값을 조회해보면 아래와 같이 JSON 객체 정보를 확인할 수 있으며, OpenSea에서 확인한 BAYC#1과 동일한 특성 정보를 가진 것을 확인할 수 있다.</p>
<p><img loading="lazy" src="/posts/image-nft-holder-collect-2-web3/image2.png" alt="image2"  />
</p>
<p><img loading="lazy" src="/posts/image-nft-holder-collect-2-web3/image3.png" alt="image3"  />
</p>
<hr>
<h2 id="3-web3-기반-수집-코드-개발">3. Web3 기반 수집 코드 개발<a hidden class="anchor" aria-hidden="true" href="#3-web3-기반-수집-코드-개발">#</a></h2>
<h3 id="이더리움-로컬-풀노드full-node-구동">이더리움 로컬 풀노드(Full Node) 구동<a hidden class="anchor" aria-hidden="true" href="#이더리움-로컬-풀노드full-node-구동">#</a></h3>
<p>이더리움은 탈중앙화된 시스템이며, 이더리움의 노드는 블록체인 네트워크에서 발생한 모든 거래를 검증하고 채굴자가 채굴한 블록이 합당한지 검증(PoW 기준)하는 역할을 수행한다.</p>
<p>블록체인 데이터베이스를 저장 및 관리하고 있는 중앙화된 시스템이 없고, 수많은 분산화된 노드를 이용해 데이터베이스를 유지/관리한다.</p>
<p>풀 노드는 이더리움 네트워크의 제네시스 블록(Genesis Block, 블록체인 네트워크의 첫번째 블록)부터 현재까지의 모든 블록을 저장하고 있는 노드로 모든 블록(거래내역)이 저장되어 있기 때문에 스스로 거래를 검증할 수 있다.</p>
<p><strong>이더리움 블록체인 및 네트워크에 접근하기 위해서는 노드가 필요</strong> 하다.</p>
<p>Infura나 Alchemy와 같은 이더리움 게이트웨이 역할을 수행하는 서비스를 통해 이더리움 네트워크에 접근해도 되지만, 속도가 매우 느리고 무료로 이용할 경우 쿼리 수에 제한이 있다.</p>
<p>나의 경우 로컬 PC에 geth를 이용하여 풀노드를 구축해 사용 중이며, 로컬 풀노드를 통해 빠른 속도로 이더리움 네트워크에 접근하여 블록 및 데이터를 조회할 수 있다.</p>
<ul>
<li>(실제로 로컬노드와 Infura와 같은 상용노드에 같은 쿼리를 날려보면, 꽤 성능 차이가 발생하고 로컬노드를 사용하는 것이 매우 효율적이고 빠른 것을 확인할 수 있다)</li>
</ul>
<p><img loading="lazy" src="/posts/image-nft-holder-collect-2-web3/image4.png" alt="image4"  />
</p>
<h3 id="이더리움-노드-및-컨트랙트-설정">이더리움 노드 및 컨트랙트 설정<a hidden class="anchor" aria-hidden="true" href="#이더리움-노드-및-컨트랙트-설정">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> http_transport <span style="color:#f92672">=</span> web3::transports::Http::new(<span style="color:#e6db74">&#34;http://localhost:8545&#34;</span>)<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> bayc_addr <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;0xbc4ca0eda7647a8ab7c2061c2e118a18a936f13d&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> addr <span style="color:#f92672">=</span> Address::from_str(bayc_addr).parse().unwrap();
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> contract <span style="color:#f92672">=</span> Contract::from_json(web3s.lock().unwrap().eth(), addr, include_bytes!(<span style="color:#e6db74">&#34;../../../metadata/artifacts/token/ERC721/ERC721.json&#34;</span>)).unwrap();
</span></span></code></pre></div><ul>
<li>
<p>Web3(JSON-RPC 기반) 쿼리를 전송하기 위해 로컬 이더리움 풀노드에 연결한다.</p>
</li>
<li>
<p>컨트랙트 주소와 JSON ABI 파일을 이용해 홀더 목록을 수집하고자 하는 컨트랙트에 연결한다.</p>
</li>
</ul>
<h3 id="nft-컨트랙트의-발행-수량-획득">NFT 컨트랙트의 발행 수량 획득<a hidden class="anchor" aria-hidden="true" href="#nft-컨트랙트의-발행-수량-획득">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">// Get Total Supply of NFT
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> total_supply: <span style="color:#66d9ef">u64</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> r: Result<span style="color:#f92672">&lt;</span>U256, web3::contract::Error<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> contract.query(<span style="color:#e6db74">&#34;totalSupply&#34;</span>, (), None, Options::default(), None).<span style="color:#66d9ef">await</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">match</span> r {
</span></span><span style="display:flex;"><span>    Ok(ts) <span style="color:#f92672">=&gt;</span> total_supply <span style="color:#f92672">=</span> ts.as_u64(),
</span></span><span style="display:flex;"><span>    _ <span style="color:#f92672">=&gt;</span> total_supply <span style="color:#f92672">=</span> <span style="color:#ae81ff">10000</span>,
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>대부분의 ERC721 스마트컨트랙트가 토큰의 총 발행수량을 <code>totalSupply</code> 라는 상태변수에 유지하기 때문에, 해당 값을 스마트컨트랙트의 스토리지부터 읽어온다.
<ul>
<li>ex&gt; <code>totalSupply</code> 값이 5555인 경우, 토큰은 #1~#5555까지 총 5555개 발행된 것으로 간주</li>
</ul>
</li>
</ul>
<h3 id="각-토큰을-소유한-지갑주소홀더-획득">각 토큰을 소유한 지갑주소(홀더) 획득<a hidden class="anchor" aria-hidden="true" href="#각-토큰을-소유한-지갑주소홀더-획득">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> hm_holder: <span style="color:#a6e22e">HashMap</span><span style="color:#f92672">&lt;</span>Address, <span style="color:#66d9ef">u64</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> HashMap::new();
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> mtx <span style="color:#f92672">=</span> Arc::new(Mutex::new(hm_holder));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// task split
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> num_of_threads <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> range <span style="color:#f92672">=</span> total_supply <span style="color:#f92672">/</span> num_of_threads;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> range_list <span style="color:#f92672">=</span> (<span style="color:#ae81ff">0</span><span style="color:#f92672">..</span>total_supply).step_by(range <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">usize</span>).collect::<span style="color:#f92672">&lt;</span>Vec<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">u64</span><span style="color:#f92672">&gt;&gt;</span>();
</span></span><span style="display:flex;"><span>range_list.pop(); range_list.push(total_supply<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> range_list <span style="color:#f92672">=</span> range_list.windows(<span style="color:#ae81ff">2</span>).map(<span style="color:#f92672">|</span>w<span style="color:#f92672">|</span> (w[<span style="color:#ae81ff">0</span>], w[<span style="color:#ae81ff">1</span>])).collect::<span style="color:#f92672">&lt;</span>Vec<span style="color:#f92672">&lt;</span>(<span style="color:#66d9ef">u64</span>,<span style="color:#66d9ef">u64</span>)<span style="color:#f92672">&gt;&gt;</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// collect wallet address to hashmap (async thread)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> handles <span style="color:#f92672">=</span> vec![];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> i <span style="color:#66d9ef">in</span> range_list {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> mtx_c <span style="color:#f92672">=</span> Arc::clone(<span style="color:#f92672">&amp;</span>mtx);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> web3s_c <span style="color:#f92672">=</span> Arc::clone(<span style="color:#f92672">&amp;</span>web3s);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> handle <span style="color:#f92672">=</span> tokio::spawn(<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">move</span> { holder_crawl_thread(addr, i.<span style="color:#ae81ff">0</span>, i.<span style="color:#ae81ff">1</span>, mtx_c, web3s_c).<span style="color:#66d9ef">await</span> });
</span></span><span style="display:flex;"><span>    handles.push(handle);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> handle <span style="color:#66d9ef">in</span> handles {
</span></span><span style="display:flex;"><span>    tokio::join<span style="color:#f92672">!</span>(handle);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>순차적으로 #1~#10000 토큰을 소유한 지갑주소를 쿼리하는 것은 시간이 오래걸리므로, 비동기 멀티쓰레딩을 이용한다. (1~1000, 1001~2000, &hellip;, 9001~10000)
<ul>
<li>rust에서 비동기 쓰레드 사용 시 동일 개체 접근 및 값 변경을 위해 <code>Arc</code>와 <code>Mutex</code>를 사용</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">holder_crawl_thread</span>(contract_addr: <span style="color:#a6e22e">Address</span>, start_tokenid: <span style="color:#66d9ef">u64</span>, end_tokenid: <span style="color:#66d9ef">u64</span>, mtx_c: <span style="color:#a6e22e">Arc</span><span style="color:#f92672">&lt;</span>Mutex<span style="color:#f92672">&lt;</span>HashMap<span style="color:#f92672">&lt;</span>Address, <span style="color:#66d9ef">u64</span><span style="color:#f92672">&gt;&gt;&gt;</span>, web3s_c: <span style="color:#a6e22e">Arc</span><span style="color:#f92672">&lt;</span>Mutex<span style="color:#f92672">&lt;</span>web3::Web3<span style="color:#f92672">&lt;</span>web3::transports::Http<span style="color:#f92672">&gt;&gt;&gt;</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> tid <span style="color:#66d9ef">in</span> start_tokenid<span style="color:#f92672">..</span>end_tokenid {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> contract <span style="color:#f92672">=</span> Contract::from_json(web3s_c.lock().unwrap().eth(), contract_addr, include_bytes!(<span style="color:#e6db74">&#34;../../../metadata/artifacts/token/ERC721/ERC721.json&#34;</span>)).unwrap();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> id: <span style="color:#a6e22e">U256</span> <span style="color:#f92672">=</span> U256::from(tid);                    
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> r: Result<span style="color:#f92672">&lt;</span>Address, web3::contract::Error<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> contract.query(<span style="color:#e6db74">&#34;ownerOf&#34;</span>, (id,), None, Options::default(), None).<span style="color:#66d9ef">await</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">match</span> r {
</span></span><span style="display:flex;"><span>            Ok(addr) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                            <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> hm <span style="color:#f92672">=</span> mtx_c.lock().unwrap();
</span></span><span style="display:flex;"><span>                            <span style="color:#66d9ef">let</span> cnt <span style="color:#f92672">=</span> hm.entry(addr).or_insert(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>                            <span style="color:#f92672">*</span>cnt <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>                        },
</span></span><span style="display:flex;"><span>            Err(_) <span style="color:#f92672">=&gt;</span> {},
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>
<p>각 쓰레드는 자신이 쿼리할 토큰 ID의 시작과 끝을 전달받으며, 해당 범위 내에서 순차적으로 컨트랙트에 접근하여 토큰을 소유한 지갑 주소를 획득한다.</p>
</li>
<li>
<p>ERC721 컨트랙트의 <code>onwerOf(uint256)</code> 함수가 토큰을 소유한 지갑 주소를 반환해준다.</p>
</li>
<li>
<p>획득한 지갑 주소는 Key-&gt;Value 를 매핑한 hashmap 구조체에 입력하며, 본 코드에서는 Key(Address)-&gt;Value(Token Quantity)로 구성된다.</p>
<ul>
<li>hashmap 구조체에 이미 지갑 주소(Key)가 존재하는 경우 수량을 +1</li>
</ul>
</li>
</ul>
<h3 id="실행-결과">실행 결과<a hidden class="anchor" aria-hidden="true" href="#실행-결과">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">// totalSupply
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>println!(<span style="color:#e6db74">&#34;Total Supply : {:?}&#34;</span>, total_supply);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Number of Holders
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> hm <span style="color:#f92672">=</span> mtx.lock().unwrap();
</span></span><span style="display:flex;"><span>println!(<span style="color:#e6db74">&#34;# of Holders : {}&#34;</span>, hm.len());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Top 20
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> v: Vec<span style="color:#f92672">&lt;</span>_<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> hm.clone().into_iter().collect();
</span></span><span style="display:flex;"><span>v.sort_by(<span style="color:#f92672">|</span>x,y<span style="color:#f92672">|</span> y.<span style="color:#ae81ff">1.</span>cmp(<span style="color:#f92672">&amp;</span>x.<span style="color:#ae81ff">1</span>));
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> i <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">..</span><span style="color:#ae81ff">20</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> t <span style="color:#f92672">=</span> v.get(i).unwrap();
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;{:?} : {:?}&#34;</span>, t.<span style="color:#ae81ff">0</span>, t.<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>
<p>실행 결과를 확인하기 위해 정보를 출력한다.</p>
<ul>
<li>(1) totalSupply (총 토큰 발행수량)</li>
<li>(2) # of Holders (토큰을 가진 홀더 수)</li>
<li>(3) 전체 홀더 중 보유 수량 상위 10개의 지갑 주소 및 보유 수량</li>
</ul>
</li>
<li>
<p>BAYC를 대상으로 홀더 수집 시, 다음과 같은 결과를 확인할 수 있다. (Ethereum Block Number 15152072 기준)</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>Total Supply : 10000
</span></span><span style="display:flex;"><span># of Holders : 6453
</span></span><span style="display:flex;"><span>0xdbfd76af2157dc15ee4e57f3f942bb45ba84af24 : 260
</span></span><span style="display:flex;"><span>0x1b523dc90a79cf5ee5d095825e586e33780f7188 : 107
</span></span><span style="display:flex;"><span>0x54be3a794282c030b15e43ae2bb182e14c409c5e : 105
</span></span><span style="display:flex;"><span>0xd38a87d7b690323ef6883e887614502abcf9b1eb : 71
</span></span><span style="display:flex;"><span>0x98e711f31e49c2e50c1a290b6f2b1e493e43ea76 : 71
</span></span><span style="display:flex;"><span>0xf896527c49b44aab3cf22ae356fa3af8e331f280 : 66
</span></span><span style="display:flex;"><span>0x8ad272ac86c6c88683d9a60eb8ed57e6c304bb0c : 57
</span></span><span style="display:flex;"><span>0x020ca66c30bec2c4fe3861a94e4db4a498a35872 : 52
</span></span><span style="display:flex;"><span>0xed2ab4948ba6a909a7751dec4f34f303eb8c7236 : 49
</span></span><span style="display:flex;"><span>0x04f5df957ce0405ba0264eca6130161cfaa12571 : 34
</span></span><span style="display:flex;"><span>0x720a4fab08cb746fc90e88d1924a98104c0822cf : 33
</span></span><span style="display:flex;"><span>0x7a9fe22691c811ea339d9b73150e6911a5343dca : 31
</span></span><span style="display:flex;"><span>0xca1257ade6f4fa6c6834fdc42e030be6c0f5a813 : 30
</span></span><span style="display:flex;"><span>0xd66f8eaf84b11654a19126a98a3f55b960846dd8 : 28
</span></span><span style="display:flex;"><span>0x1cfb8a2e4c2e849593882213b2468e369271dad2 : 27
</span></span></code></pre></div><ul>
<li>이더스캔에서 확인한 값과 동일한 것을 확인할 수 있다. (.eth와 같은 ENS 주소도 resolve해보면 같은 값임)</li>
</ul>
<p><img loading="lazy" src="/posts/image-nft-holder-collect-2-web3/image5.png" alt="image5"  />
</p>
<p><img loading="lazy" src="/posts/image-nft-holder-collect-2-web3/image6.png" alt="image6"  />
</p>
<h2 id="4-두-nft-토큰-간의-mutual-holder-확인">4. 두 NFT 토큰 간의 Mutual Holder 확인<a hidden class="anchor" aria-hidden="true" href="#4-두-nft-토큰-간의-mutual-holder-확인">#</a></h2>
<p>구현한 기능을 기반으로, 서로 다른 NFT 프로젝트의 Mutual Holder를 확인할 수 있다.</p>
<p>Mutual Holder는 A NFT 프로젝트의 토큰도 가지고 있고, B NFT 프로젝트의 토큰도 가지고 있는 홀더를 의미한다.</p>
<p>쉽게 다시 설명하면 Mutual Holder 확인 기능은 BAYC NFT 토큰 홀더 중, Doodles NFT 토큰을 가지고 있는 지갑 주소와 보유 수량을 확인하는 것이다.</p>
<p>이러한 기능은 고래 지갑 추적과 유사하게 NFT 블루칩 프로젝트의 토큰을 가진 지갑들이, 다른 특정 신규 NFT 프로젝트의 토큰을 얼마나 가지고 있는지 확인할 수 있다.</p>
<p>(블루칩 프로젝트 홀더들의 알파가 무엇인지 빠르게 체크하여 2차 거래에 참고하는 목적 등 활용 가능)</p>
<h3 id="코드">코드<a hidden class="anchor" aria-hidden="true" href="#코드">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">use</span> web3::contract::{Contract, Options};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> web3::types::{Address, U256};
</span></span><span style="display:flex;"><span><span style="color:#75715e">// use web3::contract::Error;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> std::<span style="color:#66d9ef">str</span>::FromStr;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> std::collections::HashMap;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> std::sync::{Mutex, Arc};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> std::collections::HashSet;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#[tokio::main]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() -&gt; <span style="color:#a6e22e">web3</span>::Result<span style="color:#f92672">&lt;</span>()<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// BAYC Holder Crawl
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    println!(<span style="color:#e6db74">&#34;[+] BAYC&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> bayc_holder_tuple <span style="color:#f92672">=</span> holder_crawl(<span style="color:#e6db74">&#34;0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D&#34;</span>);      <span style="color:#75715e">// BAYC
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> bayc_holder_tuple <span style="color:#f92672">=</span> bayc_holder_tuple.<span style="color:#66d9ef">await</span>.unwrap();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> bayc_holder <span style="color:#f92672">=</span> bayc_holder_tuple.<span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> _num_of_nfts_bayc <span style="color:#f92672">=</span> bayc_holder_tuple.<span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Doodles Holder Crawl
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    println!(<span style="color:#e6db74">&#34;[+] Doodles&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> doodles_holder_tuple <span style="color:#f92672">=</span> holder_crawl(<span style="color:#e6db74">&#34;0x8a90CAb2b38dba80c64b7734e58Ee1dB38B8992e&#34;</span>);      <span style="color:#75715e">// Doodles
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> doodles_holder_tuple <span style="color:#f92672">=</span> doodles_holder_tuple.<span style="color:#66d9ef">await</span>.unwrap();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> doodles_holder <span style="color:#f92672">=</span> doodles_holder_tuple.<span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> num_of_nfts_doodles <span style="color:#f92672">=</span> doodles_holder_tuple.<span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Mutual Holder Calculation
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> unique_bayc <span style="color:#f92672">=</span> bayc_holder.keys().collect::<span style="color:#f92672">&lt;</span>HashSet<span style="color:#f92672">&lt;</span>_<span style="color:#f92672">&gt;&gt;</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> unique_doodles <span style="color:#f92672">=</span> doodles_holder.keys().collect::<span style="color:#f92672">&lt;</span>HashSet<span style="color:#f92672">&lt;</span>_<span style="color:#f92672">&gt;&gt;</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> intersect <span style="color:#f92672">=</span> unique_bayc.intersection(<span style="color:#f92672">&amp;</span>unique_doodles).collect::<span style="color:#f92672">&lt;</span>Vec<span style="color:#f92672">&lt;</span>_<span style="color:#f92672">&gt;&gt;</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> num_of_h <span style="color:#f92672">=</span> intersect.len();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> num_of_nft <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> s <span style="color:#66d9ef">in</span> intersect {
</span></span><span style="display:flex;"><span>        num_of_nft <span style="color:#f92672">+=</span> doodles_holder.get(<span style="color:#f92672">&amp;</span>s).unwrap();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Check
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    println!(<span style="color:#e6db74">&#34;[+] {} BAYC Holders({:.3}%) have {} NFTs({:.3}%) of Doodles&#34;</span>, 
</span></span><span style="display:flex;"><span>                    num_of_h, 
</span></span><span style="display:flex;"><span>                    (num_of_h <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">f64</span> <span style="color:#f92672">/</span> doodles_holder.len() <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">f64</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">100</span> <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">f64</span>), 
</span></span><span style="display:flex;"><span>                    num_of_nft, 
</span></span><span style="display:flex;"><span>                    (num_of_nft <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">f64</span> <span style="color:#f92672">/</span> num_of_nfts_doodles <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">f64</span>) <span style="color:#f92672">*</span> <span style="color:#ae81ff">100</span> <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">f64</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    Ok(())
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">holder_crawl</span>(contract_address: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>) -&gt; <span style="color:#a6e22e">web3</span>::Result<span style="color:#f92672">&lt;</span>(HashMap<span style="color:#f92672">&lt;</span>Address,<span style="color:#66d9ef">u64</span><span style="color:#f92672">&gt;</span>, <span style="color:#66d9ef">u64</span>)<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Ethereum Node Set
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> http_transport <span style="color:#f92672">=</span> web3::transports::Http::new(<span style="color:#e6db74">&#34;http://localhost:8540&#34;</span>)<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> w3s <span style="color:#f92672">=</span> web3::Web3::new(http_transport);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> web3s <span style="color:#f92672">=</span> Arc::new(Mutex::new(w3s));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Contract Load
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> addr <span style="color:#f92672">=</span> Address::from_str(contract_address).unwrap();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> contract <span style="color:#f92672">=</span> Contract::from_json(web3s.lock().unwrap().eth(), addr, include_bytes!(<span style="color:#e6db74">&#34;../../metadata/artifacts/token/ERC721/ERC721.json&#34;</span>)).unwrap();
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Get Total Supply of NFT
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> total_supply: <span style="color:#66d9ef">u64</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> r: Result<span style="color:#f92672">&lt;</span>U256, web3::contract::Error<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> contract.query(<span style="color:#e6db74">&#34;totalSupply&#34;</span>, (), None, Options::default(), None).<span style="color:#66d9ef">await</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">match</span> r {
</span></span><span style="display:flex;"><span>        Ok(ts) <span style="color:#f92672">=&gt;</span> total_supply <span style="color:#f92672">=</span> ts.as_u64(),
</span></span><span style="display:flex;"><span>        _ <span style="color:#f92672">=&gt;</span> total_supply <span style="color:#f92672">=</span> <span style="color:#ae81ff">10000</span>,
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    print!(<span style="color:#e6db74">&#34;Total Supply : {:?} / &#34;</span>, total_supply);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Get Owner List &amp; balance
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> hm_holder: <span style="color:#a6e22e">HashMap</span><span style="color:#f92672">&lt;</span>Address, <span style="color:#66d9ef">u64</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> HashMap::new();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> mtx <span style="color:#f92672">=</span> Arc::new(Mutex::new(hm_holder));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// task split
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> num_of_threads <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> range <span style="color:#f92672">=</span> total_supply <span style="color:#f92672">/</span> num_of_threads;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> range_list <span style="color:#f92672">=</span> (<span style="color:#ae81ff">0</span><span style="color:#f92672">..</span>total_supply).step_by(range <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">usize</span>).collect::<span style="color:#f92672">&lt;</span>Vec<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">u64</span><span style="color:#f92672">&gt;&gt;</span>();
</span></span><span style="display:flex;"><span>    range_list.pop(); range_list.push(total_supply<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> range_list <span style="color:#f92672">=</span> range_list.windows(<span style="color:#ae81ff">2</span>).map(<span style="color:#f92672">|</span>w<span style="color:#f92672">|</span> (w[<span style="color:#ae81ff">0</span>], w[<span style="color:#ae81ff">1</span>])).collect::<span style="color:#f92672">&lt;</span>Vec<span style="color:#f92672">&lt;</span>(<span style="color:#66d9ef">u64</span>,<span style="color:#66d9ef">u64</span>)<span style="color:#f92672">&gt;&gt;</span>();
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// async thread 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> handles <span style="color:#f92672">=</span> vec![];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#66d9ef">in</span> range_list {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> mtx_c <span style="color:#f92672">=</span> Arc::clone(<span style="color:#f92672">&amp;</span>mtx);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> web3s_c <span style="color:#f92672">=</span> Arc::clone(<span style="color:#f92672">&amp;</span>web3s);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> handle <span style="color:#f92672">=</span> tokio::spawn(<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">move</span> { holder_crawl_thread(addr, i.<span style="color:#ae81ff">0</span>, i.<span style="color:#ae81ff">1</span>, mtx_c, web3s_c).<span style="color:#66d9ef">await</span> });
</span></span><span style="display:flex;"><span>        handles.push(handle);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> handle <span style="color:#66d9ef">in</span> handles {
</span></span><span style="display:flex;"><span>        tokio::join<span style="color:#f92672">!</span>(handle);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> hm <span style="color:#f92672">=</span> mtx.lock().unwrap();
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;Holders : {}&#34;</span>, hm.len());
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    Ok((hm.clone(), total_supply))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">holder_crawl_thread</span>(contract_addr: <span style="color:#a6e22e">Address</span>, start_tokenid: <span style="color:#66d9ef">u64</span>, end_tokenid: <span style="color:#66d9ef">u64</span>, mtx_c: <span style="color:#a6e22e">Arc</span><span style="color:#f92672">&lt;</span>Mutex<span style="color:#f92672">&lt;</span>HashMap<span style="color:#f92672">&lt;</span>Address, <span style="color:#66d9ef">u64</span><span style="color:#f92672">&gt;&gt;&gt;</span>, web3s_c: <span style="color:#a6e22e">Arc</span><span style="color:#f92672">&lt;</span>Mutex<span style="color:#f92672">&lt;</span>web3::Web3<span style="color:#f92672">&lt;</span>web3::transports::Http<span style="color:#f92672">&gt;&gt;&gt;</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> tid <span style="color:#66d9ef">in</span> start_tokenid<span style="color:#f92672">..</span>end_tokenid {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> contract <span style="color:#f92672">=</span> Contract::from_json(web3s_c.lock().unwrap().eth(), contract_addr, include_bytes!(<span style="color:#e6db74">&#34;../../metadata/artifacts/token/ERC721/ERC721.json&#34;</span>)).unwrap();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> id: <span style="color:#a6e22e">U256</span> <span style="color:#f92672">=</span> U256::from(tid);                    
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> r: Result<span style="color:#f92672">&lt;</span>Address, web3::contract::Error<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> contract.query(<span style="color:#e6db74">&#34;ownerOf&#34;</span>, (id,), None, Options::default(), None).<span style="color:#66d9ef">await</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">match</span> r {
</span></span><span style="display:flex;"><span>            Ok(addr) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                            <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> hm <span style="color:#f92672">=</span> mtx_c.lock().unwrap();
</span></span><span style="display:flex;"><span>                            <span style="color:#66d9ef">let</span> cnt <span style="color:#f92672">=</span> hm.entry(addr).or_insert(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>                            <span style="color:#f92672">*</span>cnt <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>                        },
</span></span><span style="display:flex;"><span>            Err(_) <span style="color:#f92672">=&gt;</span> {},
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="결과">결과<a hidden class="anchor" aria-hidden="true" href="#결과">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>&gt; cargo run --release
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>    Finished release [optimized] target(s) in 37.71s
</span></span><span style="display:flex;"><span>     Running `target\release\Erc721HolderCrawl_Web3.exe`
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>[+] BAYC
</span></span><span style="display:flex;"><span>Total Supply : 10000 / Holders : 6453
</span></span><span style="display:flex;"><span>[+] Doodles
</span></span><span style="display:flex;"><span>Total Supply : 10000 / Holders : 5207
</span></span><span style="display:flex;"><span>[+] 543 BAYC Holders(10.428%) have 1228 NFTs(12.280%) of Doodles
</span></span></code></pre></div><p>(Ethereum Block Number 15152171 기준)</p>
<p>BAYC 토큰을 가진 6453개의 지갑 중 543개의 지갑이 Mutual Holder로써 Doodles 토큰을 가지고 있다.</p>
<p>해당 Mutual Holder 543개의 지갑은 5207개의 Doodle 홀더 중에 10.428% 비중이며, Doodles 토큰 10000개중에 1228개(12.280%)를 가지고 있다.</p>
<hr>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://inhack.github.io/tags/ethereum/">Ethereum</a></li>
      <li><a href="https://inhack.github.io/tags/nft/">NFT</a></li>
      <li><a href="https://inhack.github.io/tags/erc721/">ERC721</a></li>
      <li><a href="https://inhack.github.io/tags/rust/">Rust</a></li>
      <li><a href="https://inhack.github.io/tags/web3/">Web3</a></li>
    </ul>
<nav class="paginav">
  <a class="next" href="https://inhack.github.io/posts/nft_holder_collect_1_web_crawling/">
    <span class="title">Next »</span>
    <br>
    <span>NFT 홀더 목록 수집하기 (1) - Web Crawling</span>
  </a>
</nav>


<div class="share-buttons">
    <a target="_blank" rel="noopener noreferrer" aria-label="share NFT 홀더 목록 수집하기 (2) - Web3 on twitter"
        href="https://twitter.com/intent/tweet/?text=NFT%20%ed%99%80%eb%8d%94%20%eb%aa%a9%eb%a1%9d%20%ec%88%98%ec%a7%91%ed%95%98%ea%b8%b0%20%282%29%20-%20Web3&amp;url=https%3a%2f%2finhack.github.io%2fposts%2fnft_holder_collect_2_web3%2f&amp;hashtags=Ethereum%2cNFT%2cERC721%2cRust%2cWeb3">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-253.927,424.544c135.939,0 210.268,-112.643 210.268,-210.268c0,-3.218 0,-6.437 -0.153,-9.502c14.406,-10.421 26.973,-23.448 36.935,-38.314c-13.18,5.824 -27.433,9.809 -42.452,11.648c15.326,-9.196 26.973,-23.602 32.49,-40.92c-14.252,8.429 -30.038,14.56 -46.896,17.931c-13.487,-14.406 -32.644,-23.295 -53.946,-23.295c-40.767,0 -73.87,33.104 -73.87,73.87c0,5.824 0.613,11.494 1.992,16.858c-61.456,-3.065 -115.862,-32.49 -152.337,-77.241c-6.284,10.881 -9.962,23.601 -9.962,37.088c0,25.594 13.027,48.276 32.95,61.456c-12.107,-0.307 -23.448,-3.678 -33.41,-9.196l0,0.92c0,35.862 25.441,65.594 59.311,72.49c-6.13,1.686 -12.72,2.606 -19.464,2.606c-4.751,0 -9.348,-0.46 -13.946,-1.38c9.349,29.426 36.628,50.728 68.965,51.341c-25.287,19.771 -57.164,31.571 -91.8,31.571c-5.977,0 -11.801,-0.306 -17.625,-1.073c32.337,21.15 71.264,33.41 112.95,33.41Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share NFT 홀더 목록 수집하기 (2) - Web3 on linkedin"
        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2finhack.github.io%2fposts%2fnft_holder_collect_2_web3%2f&amp;title=NFT%20%ed%99%80%eb%8d%94%20%eb%aa%a9%eb%a1%9d%20%ec%88%98%ec%a7%91%ed%95%98%ea%b8%b0%20%282%29%20-%20Web3&amp;summary=NFT%20%ed%99%80%eb%8d%94%20%eb%aa%a9%eb%a1%9d%20%ec%88%98%ec%a7%91%ed%95%98%ea%b8%b0%20%282%29%20-%20Web3&amp;source=https%3a%2f%2finhack.github.io%2fposts%2fnft_holder_collect_2_web3%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share NFT 홀더 목록 수집하기 (2) - Web3 on reddit"
        href="https://reddit.com/submit?url=https%3a%2f%2finhack.github.io%2fposts%2fnft_holder_collect_2_web3%2f&title=NFT%20%ed%99%80%eb%8d%94%20%eb%aa%a9%eb%a1%9d%20%ec%88%98%ec%a7%91%ed%95%98%ea%b8%b0%20%282%29%20-%20Web3">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share NFT 홀더 목록 수집하기 (2) - Web3 on facebook"
        href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2finhack.github.io%2fposts%2fnft_holder_collect_2_web3%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share NFT 홀더 목록 수집하기 (2) - Web3 on whatsapp"
        href="https://api.whatsapp.com/send?text=NFT%20%ed%99%80%eb%8d%94%20%eb%aa%a9%eb%a1%9d%20%ec%88%98%ec%a7%91%ed%95%98%ea%b8%b0%20%282%29%20-%20Web3%20-%20https%3a%2f%2finhack.github.io%2fposts%2fnft_holder_collect_2_web3%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share NFT 홀더 목록 수집하기 (2) - Web3 on telegram"
        href="https://telegram.me/share/url?text=NFT%20%ed%99%80%eb%8d%94%20%eb%aa%a9%eb%a1%9d%20%ec%88%98%ec%a7%91%ed%95%98%ea%b8%b0%20%282%29%20-%20Web3&amp;url=https%3a%2f%2finhack.github.io%2fposts%2fnft_holder_collect_2_web3%2f">
        <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
            <path
                d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
        </svg>
    </a>
</div>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2022 <a href="https://inhack.github.io/">inhack</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
